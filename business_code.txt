
===== backend/app.py =====
"""
Flask API åº”ç”¨ - Discord è‡ªåŠ¨è¥é”€æœºå™¨äººç³»ç»Ÿ

æä¾› REST API æ¥å£ï¼š
- è´¦å·ç®¡ç† (CRUD + å¯åŠ¨/åœæ­¢)
- åº—é“ºç®¡ç† (CRUD + æŠ“å–)
- è‡ªåŠ¨å‘é€ä»»åŠ¡æ§åˆ¶
"""
import asyncio
import threading
import logging
from flask import Flask, request, jsonify
from flask_cors import CORS

from config import config
from database import Database
from bot import DiscordBotClient, bot_clients
from auto_sender import (
    start_sending_task,
    stop_sending_task,
    get_task_status
)
from weidian_scraper import WeidianScraper
from license_manager import activate_license, validate_local_license

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# åˆå§‹åŒ– Flask åº”ç”¨
app = Flask(__name__)
CORS(app)

# åˆå§‹åŒ–æ•°æ®åº“
db = Database()

# Discord bot äº‹ä»¶å¾ªç¯ï¼ˆåœ¨å•ç‹¬çº¿ç¨‹ä¸­è¿è¡Œï¼‰
bot_loop: asyncio.AbstractEventLoop = None
bot_thread: threading.Thread = None


# ============== è®¸å¯è¯ API ==============

@app.route('/api/license/status', methods=['GET'])
def get_license_status():
    """è·å–æœ¬åœ°è®¸å¯è¯çŠ¶æ€"""
    try:
        activated, payload = validate_local_license()
        if activated:
            return jsonify({'success': True, 'activated': True, 'license': payload})
        return jsonify({'success': True, 'activated': False, 'error': payload})
    except Exception as e:
        logger.error(f"è·å–è®¸å¯è¯çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/license/activate', methods=['POST'])
def activate_license_api():
    """æ¿€æ´»è®¸å¯è¯"""
    try:
        data = request.get_json() or {}
        license_key = data.get('key', '').strip()
        if not license_key:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥'}), 400

        success, result = activate_license(license_key)
        if success:
            return jsonify({'success': True, **result})
        return jsonify({'success': False, 'error': result.get('message', 'æ¿€æ´»å¤±è´¥')}), 400
    except Exception as e:
        logger.error(f"æ¿€æ´»è®¸å¯è¯å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== æ—¥å¿— API ==============

@app.route('/api/logs/add', methods=['POST'])
def add_log():
    """æ¥æ”¶å®¢æˆ·ç«¯æ—¥å¿—"""
    try:
        data = request.get_json() or {}
        message = data.get('message', '')
        module = data.get('module', '')
        func = data.get('func', '')
        level = data.get('level', 'INFO')
        logger.info("BOT_LOG [%s] %s %s %s", level, module, func, message)
        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"æ¥æ”¶æ—¥å¿—å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== è´¦å·ç®¡ç† API ==============

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """è·å–æ‰€æœ‰ Discord è´¦å·"""
    try:
        accounts = db.get_all_accounts()
        # æ·»åŠ åœ¨çº¿çŠ¶æ€
        online_ids = {c.account_id for c in bot_clients if c.is_ready() and not c.is_closed()}
        for acc in accounts:
            acc['is_online'] = acc['id'] in online_ids
        return jsonify({'success': True, 'accounts': accounts})
    except Exception as e:
        logger.error(f"è·å–è´¦å·åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts', methods=['POST'])
def add_account():
    """æ·»åŠ æ–°è´¦å· (é€šè¿‡ token)"""
    try:
        data = request.get_json()
        token = data.get('token', '').strip()
        username = data.get('username', '').strip()

        if not token:
            return jsonify({'success': False, 'error': 'Token ä¸èƒ½ä¸ºç©º'}), 400

        account_id = db.add_account(token=token, username=username)
        return jsonify({'success': True, 'account_id': account_id, 'message': 'è´¦å·æ·»åŠ æˆåŠŸ'})
    except Exception as e:
        logger.error(f"æ·»åŠ è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>', methods=['DELETE'])
def delete_account(account_id):
    """åˆ é™¤è´¦å·"""
    try:
        # å…ˆåœæ­¢è¯¥è´¦å·çš„è¿æ¥
        for client in bot_clients:
            if client.account_id == account_id:
                asyncio.run_coroutine_threadsafe(client.close(), bot_loop)
                bot_clients.remove(client)
                break

        db.delete_account(account_id)
        return jsonify({'success': True, 'message': 'è´¦å·å·²åˆ é™¤'})
    except Exception as e:
        logger.error(f"åˆ é™¤è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>/start', methods=['POST'])
def start_account(account_id):
    """å¯åŠ¨è´¦å·è¿æ¥"""
    try:
        account = db.get_account_by_id(account_id)
        if not account:
            return jsonify({'success': False, 'error': 'è´¦å·ä¸å­˜åœ¨'}), 404

        # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨çº¿
        for client in bot_clients:
            if client.account_id == account_id and client.is_ready():
                return jsonify({'success': False, 'error': 'è´¦å·å·²åœ¨çº¿'}), 400

        # åˆ›å»ºæ–°çš„å®¢æˆ·ç«¯å¹¶å¯åŠ¨
        client = DiscordBotClient(account_id=account_id)
        token = account['token']

        async def start_bot():
            try:
                await client.start(token, reconnect=True)
            except Exception as e:
                logger.error(f"è´¦å· {account_id} å¯åŠ¨å¤±è´¥: {e}")

        asyncio.run_coroutine_threadsafe(start_bot(), bot_loop)
        bot_clients.append(client)

        db.update_account_status(account_id, 'online')
        return jsonify({'success': True, 'message': 'è´¦å·å¯åŠ¨ä¸­...'})
    except Exception as e:
        logger.error(f"å¯åŠ¨è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>/stop', methods=['POST'])
def stop_account(account_id):
    """åœæ­¢è´¦å·è¿æ¥"""
    try:
        for client in bot_clients:
            if client.account_id == account_id:
                asyncio.run_coroutine_threadsafe(client.close(), bot_loop)
                bot_clients.remove(client)
                db.update_account_status(account_id, 'offline')
                return jsonify({'success': True, 'message': 'è´¦å·å·²åœæ­¢'})

        return jsonify({'success': False, 'error': 'è´¦å·æœªåœ¨çº¿'}), 400
    except Exception as e:
        logger.error(f"åœæ­¢è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== åº—é“ºç®¡ç† API ==============

@app.route('/api/shops', methods=['GET'])
def get_shops():
    """è·å–æ‰€æœ‰åº—é“º"""
    try:
        shops = db.get_all_shops()
        return jsonify({'success': True, 'shops': shops})
    except Exception as e:
        logger.error(f"è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops', methods=['POST'])
def add_shop():
    """æ·»åŠ æ–°åº—é“º"""
    try:
        data = request.get_json()
        shop_id = data.get('shop_id', '').strip()
        name = data.get('name', '').strip()

        if not shop_id:
            return jsonify({'success': False, 'error': 'åº—é“ºIDä¸èƒ½ä¸ºç©º'}), 400

        result_id = db.add_shop(shop_id=shop_id, name=name or f"åº—é“º{shop_id}")
        return jsonify({'success': True, 'id': result_id, 'message': 'åº—é“ºæ·»åŠ æˆåŠŸ'})
    except Exception as e:
        logger.error(f"æ·»åŠ åº—é“ºå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>', methods=['DELETE'])
def delete_shop(shop_id):
    """åˆ é™¤åº—é“º"""
    try:
        db.delete_shop(shop_id)
        return jsonify({'success': True, 'message': 'åº—é“ºå·²åˆ é™¤'})
    except Exception as e:
        logger.error(f"åˆ é™¤åº—é“ºå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>/scrape', methods=['POST'])
def scrape_shop(shop_id):
    """æŠ“å–åº—é“ºå•†å“"""
    try:
        shop = db.get_shop_by_id(shop_id)
        if not shop:
            return jsonify({'success': False, 'error': 'åº—é“ºä¸å­˜åœ¨'}), 404

        # å¯åŠ¨æŠ“å–ä»»åŠ¡ï¼ˆåœ¨åå°çº¿ç¨‹ï¼‰
        def scrape_task():
            try:
                scraper = WeidianScraper()
                # è¿™é‡Œéœ€è¦å®ç° scrape_shop_products æ–¹æ³•
                # products = scraper.scrape_shop_products(shop['shop_id'])
                # for product in products:
                #     db.insert_product(product)
                logger.info(f"åº—é“º {shop['name']} æŠ“å–å®Œæˆ")
            except Exception as e:
                logger.error(f"æŠ“å–åº—é“ºå¤±è´¥: {e}")

        thread = threading.Thread(target=scrape_task, daemon=True)
        thread.start()

        return jsonify({'success': True, 'message': 'æŠ“å–ä»»åŠ¡å·²å¯åŠ¨'})
    except Exception as e:
        logger.error(f"å¯åŠ¨æŠ“å–å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>/products', methods=['GET'])
def get_shop_products(shop_id):
    """è·å–åº—é“ºçš„æ‰€æœ‰å•†å“"""
    try:
        shop = db.get_shop_by_id(shop_id)
        if not shop:
            return jsonify({'success': False, 'error': 'åº—é“ºä¸å­˜åœ¨'}), 404

        products = db.get_products_by_shop(shop['name'])
        return jsonify({'success': True, 'products': products})
    except Exception as e:
        logger.error(f"è·å–å•†å“åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== è‡ªåŠ¨å‘é€ä»»åŠ¡ API ==============

@app.route('/api/sender/start', methods=['POST'])
def start_sender():
    """å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡"""
    try:
        data = request.get_json()
        shop_id = data.get('shopId')
        channel_id = data.get('channelId')
        account_ids = data.get('accountIds', [])
        interval = data.get('interval', config.DEFAULT_SEND_INTERVAL)

        # å‚æ•°éªŒè¯
        if not shop_id:
            return jsonify({'success': False, 'error': 'è¯·é€‰æ‹©åº—é“º'}), 400
        if not channel_id:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç›®æ ‡é¢‘é“ID'}), 400
        if not account_ids:
            return jsonify({'success': False, 'error': 'è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªè´¦å·'}), 400

        # éªŒè¯é—´éš”èŒƒå›´
        interval = max(config.MIN_SEND_INTERVAL, min(interval, config.MAX_SEND_INTERVAL))

        result = start_sending_task(
            shop_id=int(shop_id),
            channel_id=str(channel_id),
            account_ids=[int(id) for id in account_ids],
            interval=int(interval),
            db=db,
            bot_clients=bot_clients,
            bot_loop=bot_loop
        )

        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        logger.error(f"å¯åŠ¨å‘é€ä»»åŠ¡å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/sender/stop', methods=['POST'])
def stop_sender():
    """åœæ­¢è‡ªåŠ¨å‘é€ä»»åŠ¡"""
    try:
        result = stop_sending_task()
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        logger.error(f"åœæ­¢å‘é€ä»»åŠ¡å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/sender/status', methods=['GET'])
def sender_status():
    """è·å–å‘é€ä»»åŠ¡çŠ¶æ€"""
    try:
        status = get_task_status()
        return jsonify({'success': True, 'status': status})
    except Exception as e:
        logger.error(f"è·å–ä»»åŠ¡çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== ç³»ç»Ÿ API ==============

@app.route('/api/health', methods=['GET'])
def health_check():
    """å¥åº·æ£€æŸ¥"""
    return jsonify({
        'success': True,
        'status': 'running',
        'bot_count': len(bot_clients),
        'online_bots': len([c for c in bot_clients if c.is_ready()])
    })


# ============== Bot çº¿ç¨‹ç®¡ç† ==============

def run_bot_loop():
    """åœ¨å•ç‹¬çº¿ç¨‹ä¸­è¿è¡Œ Discord bot äº‹ä»¶å¾ªç¯"""
    global bot_loop
    bot_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(bot_loop)
    logger.info("Discord bot äº‹ä»¶å¾ªç¯å·²å¯åŠ¨")
    bot_loop.run_forever()


def start_bot_thread():
    """å¯åŠ¨ bot çº¿ç¨‹"""
    global bot_thread
    bot_thread = threading.Thread(target=run_bot_loop, daemon=True)
    bot_thread.start()
    logger.info("Bot çº¿ç¨‹å·²å¯åŠ¨")


# ============== ä¸»å…¥å£ ==============

if __name__ == '__main__':
    # å¯åŠ¨ bot äº‹ä»¶å¾ªç¯çº¿ç¨‹
    start_bot_thread()

    # ç­‰å¾…äº‹ä»¶å¾ªç¯å¯åŠ¨
    import time
    time.sleep(0.5)

    logger.info(f"å¯åŠ¨ Flask æœåŠ¡: {config.FLASK_HOST}:{config.FLASK_PORT}")
    app.run(
        host=config.FLASK_HOST,
        port=config.FLASK_PORT,
        debug=config.FLASK_DEBUG,
        threaded=True
    )

===== backend/auto_sender.py =====
"""
è‡ªåŠ¨å‘é€ä»»åŠ¡è°ƒåº¦æ¨¡å— - Discord å•†å“é“¾æ¥è‡ªåŠ¨å‘é€

å®ç°åŠŸèƒ½ï¼š
1. ä»æ•°æ®åº“è¯»å–æŒ‡å®šåº—é“ºçš„æ‰€æœ‰å•†å“
2. è·å–ç”¨æˆ·é€‰æ‹©çš„å¤šä¸ª Discord è´¦å·
3. è½®è¯¢ç®—æ³•ï¼šæ¯å‘ä¸€æ¡ï¼Œæ¢ä¸€ä¸ªè´¦å· (Round Robin)
4. é¢‘ç‡æ§åˆ¶ï¼šå‘é€åç­‰å¾…æŒ‡å®šç§’æ•°
5. æ”¯æŒéšæ—¶ä¸­æ–­ä»»åŠ¡
"""
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

# å…¨å±€å˜é‡æ§åˆ¶ä»»åŠ¡çŠ¶æ€
current_task: Optional[asyncio.Task] = None
stop_sender_event = asyncio.Event()
task_status = {
    'is_running': False,
    'shop_id': None,
    'channel_id': None,
    'total_products': 0,
    'sent_count': 0,
    'current_product': None,
    'current_account': None,
    'started_at': None,
    'last_sent_at': None,
    'error': None
}


def get_task_status() -> Dict:
    """è·å–å½“å‰ä»»åŠ¡çŠ¶æ€"""
    return task_status.copy()


def reset_task_status():
    """é‡ç½®ä»»åŠ¡çŠ¶æ€"""
    global task_status
    task_status = {
        'is_running': False,
        'shop_id': None,
        'channel_id': None,
        'total_products': 0,
        'sent_count': 0,
        'current_product': None,
        'current_account': None,
        'started_at': None,
        'last_sent_at': None,
        'error': None
    }


async def auto_send_loop(
    shop_id: int,
    target_channel_id: str,
    selected_account_ids: List[int],
    interval: int,
    db,
    bot_clients: List
):
    """
    è‡ªåŠ¨å‘é€å¾ªç¯ä»»åŠ¡

    :param shop_id: é€‰ä¸­çš„åº—é“ºIDï¼ˆç”¨äºä»æ•°æ®åº“æå•†å“ï¼‰
    :param target_channel_id: ç›®æ ‡ Discord é¢‘é“ ID
    :param selected_account_ids: ç”¨æˆ·å‹¾é€‰çš„ Account ID åˆ—è¡¨ [1, 2, 5]
    :param interval: å‘é€é—´éš”ï¼ˆç§’ï¼‰
    :param db: æ•°æ®åº“å®ä¾‹
    :param bot_clients: æœºå™¨äººå®¢æˆ·ç«¯åˆ—è¡¨
    """
    global task_status

    logger.info(f"å¯åŠ¨è‡ªåŠ¨å‘é€: åº—é“º{shop_id} -> é¢‘é“{target_channel_id}ï¼Œé—´éš”{interval}s")

    task_status['is_running'] = True
    task_status['shop_id'] = shop_id
    task_status['channel_id'] = target_channel_id
    task_status['started_at'] = datetime.now().isoformat()
    task_status['error'] = None

    try:
        # 1. è·å–è¯¥åº—é“ºæ‰€æœ‰å•†å“é“¾æ¥
        shop_info = db.get_shop_by_id(shop_id)
        if not shop_info:
            task_status['error'] = f"åº—é“º {shop_id} ä¸å­˜åœ¨"
            logger.error(task_status['error'])
            return

        shop_name = shop_info.get('name', '')

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, product_url, title, cnfans_url FROM products WHERE shop_name = ?",
                (shop_name,)
            )
            products = [dict(row) for row in cursor.fetchall()]

        if not products:
            task_status['error'] = f"åº—é“º '{shop_name}' æ²¡æœ‰å•†å“æ•°æ®ï¼Œè¯·å…ˆæ‰§è¡ŒæŠ“å–"
            logger.warning(task_status['error'])
            return

        task_status['total_products'] = len(products)
        logger.info(f"å¾…å‘é€å•†å“æ•°: {len(products)}")

        # 2. ç­›é€‰å‡ºå¯ç”¨çš„åœ¨çº¿ Bot å®¢æˆ·ç«¯
        active_bots = [
            client for client in bot_clients
            if hasattr(client, 'account_id')
            and client.account_id in selected_account_ids
            and client.is_ready()
            and not client.is_closed()
        ]

        if not active_bots:
            task_status['error'] = "æ²¡æœ‰é€‰ä¸­çš„è´¦å·åœ¨çº¿ï¼Œè¯·å…ˆå¯åŠ¨è´¦å·"
            logger.error(task_status['error'])
            return

        logger.info(f"å¯ç”¨è´¦å·æ•°: {len(active_bots)}")

        product_idx = 0
        bot_idx = 0

        # 3. å¾ªç¯å‘é€
        while not stop_sender_event.is_set():
            if product_idx >= len(products):
                logger.info("æ‰€æœ‰å•†å“å·²å‘é€å®Œæ¯•ï¼Œä»»åŠ¡ç»“æŸ")
                break

            # è·å–å½“å‰è¦å‘çš„å•†å“
            product = products[product_idx]
            link_to_send = product.get('cnfans_url') or product.get('product_url', '')
            title = product.get('title', 'æœªçŸ¥å•†å“')
            message_content = f"{title}\n{link_to_send}"

            # è·å–å½“å‰è½®æ¢çš„è´¦å· (Round Robin)
            current_bot = active_bots[bot_idx % len(active_bots)]

            task_status['current_product'] = title[:50]
            task_status['current_account'] = getattr(current_bot, 'user', None)
            if task_status['current_account']:
                task_status['current_account'] = str(task_status['current_account'])

            try:
                channel = current_bot.get_channel(int(target_channel_id))
                if channel:
                    await channel.send(message_content)
                    task_status['sent_count'] += 1
                    task_status['last_sent_at'] = datetime.now().isoformat()
                    logger.info(
                        f"âœ… è´¦å· {current_bot.user.name if current_bot.user else 'Unknown'} "
                        f"å‘é€æˆåŠŸ ({task_status['sent_count']}/{task_status['total_products']}): {title[:30]}..."
                    )
                else:
                    logger.error(
                        f"è´¦å· {current_bot.user.name if current_bot.user else 'Unknown'} "
                        f"æ‰¾ä¸åˆ°é¢‘é“ {target_channel_id}"
                    )
            except Exception as e:
                logger.error(f"å‘é€å¤±è´¥: {e}")
                # ç»§ç»­ä¸‹ä¸€æ¡ï¼Œä¸ä¸­æ–­ä»»åŠ¡

            # ç´¢å¼•é€’å¢
            product_idx += 1
            bot_idx += 1

            # ç­‰å¾…é—´éš”ï¼ˆæ”¯æŒéšæ—¶ä¸­æ–­ï¼‰
            try:
                await asyncio.wait_for(
                    stop_sender_event.wait(),
                    timeout=float(interval)
                )
                # å¦‚æœ wait è¿”å›äº†ï¼Œè¯´æ˜ event è¢« set äº†ï¼Œæ”¶åˆ°åœæ­¢ä¿¡å·
                logger.info("æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œä»»åŠ¡ä¸­æ–­")
                break
            except asyncio.TimeoutError:
                # è¶…æ—¶æ„å‘³ç€æ—¶é—´åˆ°äº†ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯
                continue

    except asyncio.CancelledError:
        logger.info("ä»»åŠ¡è¢«å–æ¶ˆ")
    except Exception as e:
        task_status['error'] = str(e)
        logger.error(f"è‡ªåŠ¨å‘é€ä»»åŠ¡å¼‚å¸¸: {e}")
    finally:
        task_status['is_running'] = False
        logger.info("è‡ªåŠ¨å‘é€ä»»åŠ¡ç»“æŸ")


def start_sending_task(
    shop_id: int,
    channel_id: str,
    account_ids: List[int],
    interval: int,
    db,
    bot_clients: List,
    bot_loop: asyncio.AbstractEventLoop
) -> Dict:
    """
    å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡ï¼ˆä» Flask çº¿ç¨‹è°ƒç”¨ï¼‰

    :param shop_id: åº—é“º ID
    :param channel_id: ç›®æ ‡é¢‘é“ ID
    :param account_ids: è´¦å· ID åˆ—è¡¨
    :param interval: å‘é€é—´éš”ï¼ˆç§’ï¼‰
    :param db: æ•°æ®åº“å®ä¾‹
    :param bot_clients: æœºå™¨äººå®¢æˆ·ç«¯åˆ—è¡¨
    :param bot_loop: Discord bot çš„äº‹ä»¶å¾ªç¯
    :return: æ“ä½œç»“æœ
    """
    global current_task, stop_sender_event

    if task_status['is_running']:
        return {'success': False, 'error': 'å·²æœ‰ä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œè¯·å…ˆåœæ­¢'}

    # é‡ç½®åœæ­¢äº‹ä»¶
    stop_sender_event.clear()
    reset_task_status()

    # åœ¨ bot çš„äº‹ä»¶å¾ªç¯ä¸­åˆ›å»ºä»»åŠ¡
    try:
        future = asyncio.run_coroutine_threadsafe(
            auto_send_loop(
                shop_id=shop_id,
                target_channel_id=channel_id,
                selected_account_ids=account_ids,
                interval=interval,
                db=db,
                bot_clients=bot_clients
            ),
            bot_loop
        )
        logger.info("è‡ªåŠ¨å‘é€ä»»åŠ¡å·²æäº¤åˆ°äº‹ä»¶å¾ªç¯")
        return {'success': True, 'message': 'è‡ªåŠ¨å‘é€ä»»åŠ¡å·²å¯åŠ¨'}
    except Exception as e:
        logger.error(f"å¯åŠ¨ä»»åŠ¡å¤±è´¥: {e}")
        return {'success': False, 'error': str(e)}


def stop_sending_task() -> Dict:
    """
    åœæ­¢è‡ªåŠ¨å‘é€ä»»åŠ¡

    :return: æ“ä½œç»“æœ
    """
    global stop_sender_event

    if not task_status['is_running']:
        return {'success': False, 'error': 'å½“å‰æ²¡æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡'}

    stop_sender_event.set()
    logger.info("å·²å‘é€åœæ­¢ä¿¡å·")
    return {'success': True, 'message': 'ä»»åŠ¡åœæ­¢æŒ‡ä»¤å·²å‘é€'}

===== backend/bot.py =====
import discord
import aiohttp
import logging
import time
import asyncio
import random
import os
import json
import io
import sqlite3
from datetime import datetime
try:
    from config import config
except ImportError:
    from .config import config

# å…¨å±€å˜é‡ç”¨äºå¤šè´¦å·æœºå™¨äººç®¡ç†
bot_clients = []
bot_tasks = []

# å…¨å±€å†·å´ç®¡ç†å™¨ï¼š(account_id, channel_id) -> timestamp (ä¸Šæ¬¡å‘é€æ—¶é—´)
account_last_sent = {}

# ã€æ–°å¢ã€‘AIå¹¶å‘é™åˆ¶ï¼šæœ€å¤šåŒæ—¶2ä¸ªAIæ¨ç†ä»»åŠ¡ï¼Œé˜²æ­¢CPUé¥±å’Œå¯¼è‡´Flaské˜»å¡
ai_concurrency_limit = asyncio.Semaphore(2)


def get_all_cooldowns():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„å†·å´çŠ¶æ€ï¼ˆä¾› API æŸ¥è¯¢ï¼‰"""
    current_time = time.time()
    cooldowns = []

    snapshot = account_last_sent.copy()

    for key, last_sent in snapshot.items():
        try:
            acc_id, ch_id = key
            time_passed = current_time - last_sent

            if time_passed < 86400:
                cooldowns.append({
                    'account_id': int(acc_id),
                    'channel_id': str(ch_id),
                    'last_sent': last_sent,
                    'time_passed': time_passed
                })
        except Exception:
            continue

    return cooldowns

def is_account_on_cooldown(account_id, channel_id, interval):
    """æ£€æŸ¥è´¦å·åœ¨æŒ‡å®šé¢‘é“æ˜¯å¦åœ¨å†·å´ä¸­"""
    key = (int(account_id), str(channel_id))

    last = account_last_sent.get(key, 0)
    time_passed = time.time() - last
    is_cooldown = time_passed < interval

    if is_cooldown:
        logger.info(f"â„ï¸ [å†·å´ä¸­] è´¦å·ID:{account_id} é¢‘é“:{channel_id} | å‰©ä½™: {interval - time_passed:.1f}ç§’")

    return is_cooldown

def set_account_cooldown(account_id, channel_id):
    """è®¾ç½®è´¦å·åœ¨æŒ‡å®šé¢‘é“çš„å†·å´æ—¶é—´"""
    key = (int(account_id), str(channel_id))
    account_last_sent[key] = time.time()
    logger.info(f"ğŸ”¥ [è®¾ç½®å†·å´] è´¦å·ID:{account_id} é¢‘é“:{channel_id} | Key: {key}")

def cleanup_expired_cooldowns():
    """æ¸…ç†è¿‡æœŸçš„å†·å´çŠ¶æ€"""
    current_time = time.time()
    expired_keys = []
    for key, last_sent in account_last_sent.items():
        # å¦‚æœå†·å´æ—¶é—´è¶…è¿‡24å°æ—¶ï¼Œæ¸…ç†æ‰ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
        if current_time - last_sent > 86400:  # 24å°æ—¶
            expired_keys.append(key)

    for key in expired_keys:
        del account_last_sent[key]
        logger.debug(f"æ¸…ç†è¿‡æœŸå†·å´: {key}")

    if expired_keys:
        logger.info(f"æ¸…ç†äº† {len(expired_keys)} ä¸ªè¿‡æœŸçš„å†·å´çŠ¶æ€")

def mark_message_as_processed(message_id):
    """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å¤„ç†ï¼ˆåŸå­æ“ä½œï¼‰"""
    try:
        from database import db
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO processed_messages (message_id) VALUES (?)", (str(message_id),))
            conn.commit()
        return True  # æŠ¢é”æˆåŠŸ
    except sqlite3.IntegrityError:
        return False  # å·²ç»è¢«å…¶ä»–BotæŠ¢é”

def get_response_url_for_channel(product, channel_id, user_id=None):
    """æ ¹æ®é¢‘é“IDå’Œç½‘ç«™é…ç½®å†³å®šå‘é€å“ªä¸ªé“¾æ¥"""
    import re
    try:
        from database import db
    except ImportError:
        from .database import db

    channel_id_str = str(channel_id)

    # 1. é¦–å…ˆå°è¯•æ ¹æ®é¢‘é“ç»‘å®šè·å–ç½‘ç«™é…ç½®
    website_config = db.get_website_config_by_channel(channel_id_str, user_id)

    if website_config and website_config.get('url_template'):
        # ä»å•†å“URLä¸­æå–å¾®åº—ID
        weidian_url = product.get('weidianUrl') or product.get('product_url') or ''
        weidian_id = None

        # å°è¯•ä»URLä¸­æå–itemID
        match = re.search(r'itemID=(\d+)', weidian_url)
        if match:
            weidian_id = match.group(1)
        else:
            # å°è¯•ä»weidianIdå­—æ®µè·å–
            weidian_id = product.get('weidianId')

        if weidian_id:
            # ä½¿ç”¨URLæ¨¡æ¿ç”Ÿæˆé“¾æ¥
            url = website_config['url_template'].replace('{id}', weidian_id)
            logger.info(f"ä½¿ç”¨ç½‘ç«™é…ç½® '{website_config['name']}' çš„URLæ¨¡æ¿ç”Ÿæˆé“¾æ¥: {url[:50]}...")
            return url

    # 2. å›é€€åˆ°æ—§çš„ç¡¬ç¼–ç é€»è¾‘ï¼ˆå…¼å®¹æ€§ï¼‰
    if config.CNFANS_CHANNEL_ID and channel_id_str == config.CNFANS_CHANNEL_ID:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        elif product.get('acbuyUrl'):
            return product['acbuyUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    elif config.ACBUY_CHANNEL_ID and channel_id_str == config.ACBUY_CHANNEL_ID:
        if product.get('acbuyUrl'):
            return product['acbuyUrl']
        elif product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    # 3. é»˜è®¤å‘é€CNFansé“¾æ¥
    else:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

class HTTPLogHandler(logging.Handler):
    """é€šè¿‡HTTPå‘é€æ—¥å¿—åˆ°Flaskåº”ç”¨"""
    def __init__(self):
        super().__init__()
        self.pending_logs = []
        self.is_sending = False

    def emit(self, record):
        try:
            if record.name.startswith('werkzeug'):
                return
            if record.module == 'app' and record.funcName == 'add_log':
                return
            message = record.getMessage()
            if message.startswith('BOT_LOG'):
                return
            # åªå‘é€æˆ‘ä»¬å…³å¿ƒçš„æ—¥å¿—çº§åˆ«
            if record.levelno >= logging.INFO:
                log_data = {
                    'timestamp': datetime.now().isoformat(),
                    'level': record.levelname,
                    'message': message,
                    'module': record.module,
                    'func': record.funcName
                }

                # æ·»åŠ åˆ°å¾…å‘é€é˜Ÿåˆ—
                self.pending_logs.append(log_data)

                # å¦‚æœæ²¡æœ‰æ­£åœ¨å‘é€ï¼Œå¯åŠ¨å‘é€ä»»åŠ¡
                if not self.is_sending:
                    # åœ¨æœºå™¨äººçš„äº‹ä»¶å¾ªç¯ä¸­åˆ›å»ºä»»åŠ¡
                    try:
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            loop.create_task(self.send_pending_logs())
                        else:
                            # å¦‚æœå¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥å‘é€ï¼ˆåŒæ­¥æ–¹å¼ï¼‰
                            self.send_sync(log_data)
                    except RuntimeError:
                        # æ²¡æœ‰äº‹ä»¶å¾ªç¯ï¼Œç›´æ¥åŒæ­¥å‘é€
                        self.send_sync(log_data)

        except Exception as e:
            print(f"HTTPæ—¥å¿—å¤„ç†å™¨é”™è¯¯: {e}")

    def send_sync(self, log_data):
        """åŒæ­¥å‘é€æ—¥å¿—ï¼ˆä½œä¸ºfallbackï¼‰"""
        try:
            import requests
            # ã€ä¿®å¤ã€‘å¼ºåˆ¶ä½¿ç”¨ 127.0.0.1ï¼Œå› ä¸ºè¿™æ˜¯è¿›ç¨‹é—´é€šä¿¡ï¼Œä¸åº”èµ°å…¬ç½‘
            local_api_url = 'http://127.0.0.1:5001/api'
            response = requests.post(f'{local_api_url}/logs/add',
                                   json=log_data, timeout=2, proxies={'http': None, 'https': None, 'all': None})
            if response.status_code != 200:
                print(f"åŒæ­¥å‘é€æ—¥å¿—å¤±è´¥: {response.status_code}")
        except Exception as e:
            # è¿™é‡Œçš„ print å¯èƒ½ä¼šè¢«é‡å®šå‘ï¼Œä½†è‡³å°‘ä¸ä¼šæŠ›å‡º ConnectionRefusedError ç‚¸æ–­æµç¨‹
            pass

    async def send_pending_logs(self):
        """å¼‚æ­¥å‘é€å¾…å¤„ç†çš„æ—¥å¿—"""
        if self.is_sending:
            return

        self.is_sending = True

        # ã€ä¿®å¤ã€‘å¼ºåˆ¶ä½¿ç”¨ 127.0.0.1
        local_api_url = 'http://127.0.0.1:5001/api'

        try:
            while self.pending_logs:
                log_data = self.pending_logs.pop(0)

                try:
                    async with aiohttp.ClientSession(trust_env=False) as session:
                        async with session.post(f'{local_api_url}/logs/add',
                                              json=log_data, timeout=aiohttp.ClientTimeout(total=2)) as resp:
                            if resp.status != 200:
                                print(f"å‘é€æ—¥å¿—å¤±è´¥: {resp.status}")
                except Exception as e:
                    # é˜Ÿåˆ—æ»¡äº†å°±ä¸¢å¼ƒï¼Œä¸è¦æ— é™å †ç§¯
                    if len(self.pending_logs) < 1000:
                        self.pending_logs.insert(0, log_data)
                    break

                # å°å»¶è¿Ÿé¿å…å‘é€å¤ªå¿«
                await asyncio.sleep(0.01) # åŠ å¿«å‘é€é€Ÿåº¦ï¼Œå‡å°‘ç§¯å‹

        finally:
            self.is_sending = False

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)

# æ·»åŠ HTTPæ—¥å¿—å¤„ç†å™¨
http_handler = HTTPLogHandler()
http_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(http_handler)

logger = logging.getLogger(__name__)

# ç¡®ä¿discordåº“ä¹Ÿä½¿ç”¨æˆ‘ä»¬çš„æ—¥å¿—é…ç½®
logging.getLogger('discord').setLevel(logging.INFO)

class DiscordBotClient(discord.Client):
    # ã€æ–°å¢ã€‘é¢‘é“ç™½åå•ç¼“å­˜ï¼ˆç±»çº§åˆ«å…±äº«ï¼Œæ‰€æœ‰Botå®ä¾‹å…±ç”¨ï¼‰
    _bound_channels_cache = set()  # å·²ç»‘å®šçš„é¢‘é“IDé›†åˆ
    _last_cache_update = 0  # ä¸Šæ¬¡ç¼“å­˜æ›´æ–°æ—¶é—´æˆ³
    _cache_ttl = 60  # ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰

    def __init__(self, account_id=None, user_id=None, user_shops=None, role='both'):
        # discord.py-self å¯èƒ½ä¸éœ€è¦ intentsï¼Œæˆ–è€…ä½¿ç”¨ä¸åŒçš„è¯­æ³•
        try:
            # å°è¯•ä½¿ç”¨æ ‡å‡†çš„ intents
            intents = discord.Intents.default()
            intents.message_content = True
            intents.messages = True
            intents.guilds = True
            super().__init__(intents=intents)
        except AttributeError:
            # å¦‚æœ Intents ä¸å­˜åœ¨ï¼Œç›´æ¥åˆå§‹åŒ–ï¼ˆdiscord.py-self å¯èƒ½ä¸éœ€è¦ï¼‰
            super().__init__()
        self.current_token = None
        self.running = False
        self.account_id = account_id
        self.user_id = user_id  # ç”¨æˆ·IDï¼Œç”¨äºè·å–ä¸ªæ€§åŒ–è®¾ç½®
        self.user_shops = user_shops  # ç”¨æˆ·ç®¡ç†çš„åº—é“ºåˆ—è¡¨
        self.role = role  # 'listener', 'sender', 'both' - è´¦å·è§’è‰²

    async def _refresh_channel_cache(self):
        """ã€æ–°å¢ã€‘åˆ·æ–°é¢‘é“ç™½åå•ç¼“å­˜ï¼ˆ60ç§’TTLï¼‰

        ä»æ•°æ®åº“è·å–æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDï¼Œæ›´æ–°ç±»çº§åˆ«ç¼“å­˜ã€‚
        ä½¿ç”¨TTLæœºåˆ¶é¿å…é¢‘ç¹æŸ¥è¯¢æ•°æ®åº“ã€‚
        """
        current_time = time.time()

        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
        if current_time - DiscordBotClient._last_cache_update < DiscordBotClient._cache_ttl:
            return  # ç¼“å­˜ä»ç„¶æœ‰æ•ˆï¼Œæ— éœ€åˆ·æ–°

        try:
            # åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢ï¼ˆé¿å…é˜»å¡äº‹ä»¶å¾ªç¯ï¼‰
            try:
                from database import db
            except ImportError:
                from .database import db

            channel_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_all_bound_channel_ids
            )

            # æ›´æ–°ç±»çº§åˆ«ç¼“å­˜
            DiscordBotClient._bound_channels_cache = channel_ids
            DiscordBotClient._last_cache_update = current_time

            logger.debug(f"âœ… é¢‘é“ç™½åå•ç¼“å­˜å·²åˆ·æ–°ï¼Œå…± {len(channel_ids)} ä¸ªé¢‘é“")

        except Exception as e:
            logger.error(f"âŒ åˆ·æ–°é¢‘é“ç™½åå•ç¼“å­˜å¤±è´¥: {e}")
            # å¤±è´¥æ—¶ä¸æ›´æ–°æ—¶é—´æˆ³ï¼Œä¸‹æ¬¡ä¼šé‡è¯•

    async def schedule_reply(self, message, product, custom_reply=None):
        """è°ƒåº¦å›å¤åˆ°åˆé€‚çš„å‘é€è´¦å· (å¢å¼ºç‰ˆï¼šå¸¦è¯¦ç»†çŠ¶æ€è¯Šæ–­)"""

        try:
            # æ¸…ç†è¿‡æœŸçš„å†·å´çŠ¶æ€
            cleanup_expired_cooldowns()

            try:
                from database import db
            except ImportError:
                from .database import db

            # è·å–ç”¨æˆ·è®¾ç½®ä»¥ç¡®å®šå»¶è¿Ÿæ—¶é—´
            user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
            min_delay = user_settings.get('global_reply_min_delay', 3.0)
            max_delay = user_settings.get('global_reply_max_delay', 8.0)

            # ç”Ÿæˆå›å¤å†…å®¹
            response_content = self._generate_reply_content(product, message.channel.id, custom_reply)

            # 1. å°è¯•è·å–ç½‘ç«™é…ç½®ï¼ˆå¿…é¡»ç»‘å®šï¼Œå¦åˆ™ä¸å›å¤ï¼‰
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            if not website_config:
                logger.info(f"é¢‘é“ {message.channel.id} æœªç»‘å®šç½‘ç«™é…ç½®ï¼Œè·³è¿‡å›å¤")
                return

            target_client = None

            # 2. è·å–æ•°æ®åº“é…ç½®çš„å‘é€è€… ID
            db_sender_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_senders, website_config['id']
            )

            if not db_sender_ids:
                logger.warning(
                    f"âŒ [é…ç½®é”™è¯¯] ç½‘ç«™é…ç½® '{website_config.get('name')}' æœªç»‘å®šä»»ä½•ã€å‘é€ã€‘è´¦å·ã€‚è¯·åœ¨ç½‘ç«™é…ç½®ä¸­ç»‘å®šè´¦å·ã€‚"
                )
                return

            # === è·å–å½“å‰çœŸæ­£åœ¨çº¿çš„æœºå™¨äººè´¦å· ID ===
            online_client_ids = [c.account_id for c in bot_clients if c.is_ready() and not c.is_closed()]

            # è°ƒè¯•ä¿¡æ¯ï¼šæ‰“å°å½“å‰çŠ¶æ€
            logger.info(f"é…ç½®è´¦å·ID: {db_sender_ids} | åœ¨çº¿è´¦å·ID: {online_client_ids}")

            # å–äº¤é›†ï¼šæ—¢åœ¨æ•°æ®åº“é…ç½®äº†ï¼Œåˆæ˜¯å½“å‰åœ¨çº¿çš„
            valid_senders = [uid for uid in db_sender_ids if uid in online_client_ids]

            if not valid_senders:
                logger.warning("âŒ [çŠ¶æ€é”™è¯¯] é…ç½®çš„å‘é€è´¦å·å‡ä¸åœ¨çº¿ã€‚è¯·æ£€æŸ¥ Discord è´¦å·è¿æ¥çŠ¶æ€ã€‚")
                return

            # 3. è½®æ¢/å†·å´é€»è¾‘ - ä½¿ç”¨ç”¨æˆ·çº§åˆ«è®¾ç½®
            # ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é…ç½®
            rotation_enabled = website_config.get('rotation_enabled', 1)
            rotation_interval = website_config.get('rotation_interval', 180)

            if self.user_id and website_config.get('id'):
                user_website_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_website_settings, self.user_id, website_config['id']
                )
                if user_website_settings:
                    rotation_enabled = user_website_settings.get('rotation_enabled', rotation_enabled)
                    rotation_interval = user_website_settings.get('rotation_interval', rotation_interval)
                    logger.info(f"ğŸ“‹ ä½¿ç”¨ç”¨æˆ·çº§åˆ«è®¾ç½®: rotation_interval={rotation_interval}ç§’, rotation_enabled={rotation_enabled}")

            available_senders = []

            if rotation_enabled:
                # ç­›é€‰éå†·å´çš„ï¼ˆæŒ‰é¢‘é“åŒºåˆ†å†·å´ï¼‰
                available_senders = [
                    uid for uid in valid_senders
                    if not is_account_on_cooldown(uid, message.channel.id, rotation_interval)
                ]

                # åªæœ‰ valid_senders æœ‰å€¼ä½† available_senders ä¸ºç©ºï¼Œæ‰æ˜¯çœŸæ­£çš„â€œå†·å´ä¸­â€
                if not available_senders:
                    logger.info(
                        f"â³ [å†·å´ä¸­] é¢‘é“ {message.channel.id} æ‰€æœ‰åœ¨çº¿è´¦å· ({len(valid_senders)}ä¸ª) "
                        f"å‡å¤„äº {rotation_interval}ç§’ å†·å´æœŸå†…ï¼Œè·³è¿‡å‘é€"
                    )
                    return

            else:
                available_senders = valid_senders

            # 4. é€‰ä¸­ä¸€ä¸ª ID
            if available_senders:
                selected_id = random.choice(available_senders)
                target_client = next((c for c in bot_clients if c.account_id == selected_id), None)
                logger.info(
                    f"âœ… æœ¬æ¬¡é€‰ä¸­å‘é€è´¦å·: {target_client.user.name if target_client else selected_id} (ID: {selected_id})"
                )
            else:
                logger.warning("âŒ é€»è¾‘å¼‚å¸¸ï¼šæœ‰ valid_senders ä½†æ— å¯ç”¨å‘é€è´¦å·")
                return

            # 5. æ‰§è¡Œå‘é€
            if target_client:
                try:
                    target_channel = target_client.get_channel(message.channel.id)

                    if target_channel:
                        async with target_channel.typing():
                            await asyncio.sleep(random.uniform(min_delay, max_delay))

                        # ã€å…³é”®ä¿®å¤ã€‘
                        # ä¸è¦ä½¿ç”¨ message.reply()ï¼Œå› ä¸º message ç»‘å®šçš„æ˜¯ç›‘å¬è€…(Listener)å®¢æˆ·ç«¯
                        # å¿…é¡»ç”¨ target_channel.send(..., reference=message) æ‰ä¼šä½¿ç”¨ target_client(Sender) çš„ token
                        try:
                            # === 1. æ”¶é›†æ‰€æœ‰è¦å‘é€çš„å›¾ç‰‡æ–‡ä»¶ ===
                            files = []

                            # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰æ¨¡å¼ï¼Œä¸”æœ‰å›¾ç‰‡
                            is_custom_mode = custom_reply and (
                                custom_reply.get('reply_type') == 'custom_only' or
                                custom_reply.get('reply_type') == 'text'
                            )

                            if is_custom_mode:
                                # è·å–å›¾ç‰‡ä¿¡æ¯
                                # æ³¨æ„ï¼šå¦‚æœæ˜¯ä» search_similar_text è¿”å›çš„ productï¼Œå­—æ®µåå¯èƒ½å·²ç»æ ¼å¼åŒ–
                                # éœ€è¦å…¼å®¹å¤„ç†

                                # 1. å°è¯•è·å–è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥
                                custom_urls = product.get('customImageUrls', []) or product.get('custom_image_urls', [])
                                if isinstance(custom_urls, str):
                                    try:
                                        custom_urls = json.loads(custom_urls)
                                    except:
                                        custom_urls = []

                                image_source = product.get('imageSource') or product.get('image_source') or 'product'

                                # æ”¶é›†å›¾ç‰‡æ–‡ä»¶ï¼ˆDiscordé™åˆ¶æœ€å¤š10ä¸ªæ–‡ä»¶ï¼‰
                                if image_source == 'custom' and custom_urls:
                                    for url in custom_urls[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                        if len(files) >= 10:
                                            break
                                        try:
                                            async with aiohttp.ClientSession() as session:
                                                async with session.get(url) as resp:
                                                    if resp.status == 200:
                                                        data = await resp.read()
                                                        filename = url.split('/')[-1] or 'image.jpg'
                                                        files.append(discord.File(io.BytesIO(data), filename))
                                        except Exception as e:
                                            logger.error(f"ä¸‹è½½è‡ªå®šä¹‰å›¾ç‰‡å¤±è´¥: {e}")

                                elif image_source == 'upload':
                                    # å¤„ç†ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡
                                    pid = product.get('id')

                                    # ä» uploaded_reply_images å­—æ®µè·å–ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶ååˆ—è¡¨
                                    uploaded_filenames = product.get('uploaded_reply_images', [])
                                    if isinstance(uploaded_filenames, str):
                                        try:
                                            uploaded_filenames = json.loads(uploaded_filenames)
                                        except:
                                            # å¦‚æœè§£æå¤±è´¥ï¼Œä¸”å®ƒæœ¬èº«å°±æ˜¯åˆ—è¡¨ï¼Œåˆ™ä¿æŒåŸæ ·ï¼Œå¦åˆ™ç½®ç©º
                                            uploaded_filenames = uploaded_filenames if isinstance(uploaded_filenames, list) else []

                                    if pid and uploaded_filenames:
                                        # ä½¿ç”¨æ–°çš„APIç«¯ç‚¹è·å–ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡
                                        for filename in uploaded_filenames[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/custom_reply_image/{pid}/{filename}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), filename))
                                            except Exception as e:
                                                logger.error(f"ä¸‹è½½ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡å¤±è´¥: {e}")

                                elif image_source == 'product':
                                    # å¤„ç†å•†å“å›¾é›†ä¸­çš„å›¾ç‰‡
                                    pid = product.get('id')
                                    indexes = product.get('selectedImageIndexes', []) or product.get('custom_reply_images', [])

                                    if isinstance(indexes, str):
                                        try:
                                            indexes = json.loads(indexes)
                                        except:
                                            indexes = []

                                    if pid and indexes:
                                        # ä½¿ç”¨åŸæœ‰çš„APIç«¯ç‚¹è·å–å•†å“å›¾é›†ä¸­çš„å›¾ç‰‡
                                        for idx in indexes[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/image/{pid}/{idx}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), f"{pid}_{idx}.jpg"))
                                            except Exception as e:
                                                logger.error(f"ä¸‹è½½å•†å“å›¾ç‰‡å¤±è´¥: {e}")

                            # === 2. å‘é€æ–‡å­—å’Œæ‰€æœ‰å›¾ç‰‡ï¼ˆåˆå¹¶ä¸ºä¸€æ¡æ¶ˆæ¯ï¼‰ ===
                            if not response_content and not files:
                                logger.warning(
                                    f"âš ï¸ æ— å¯å‘é€å†…å®¹: å•†å“ID={product.get('id')}ï¼Œæœªç”Ÿæˆæ–‡å­—ä¸”æ— å›¾ç‰‡"
                                )
                                return

                            await target_channel.send(
                                content=response_content if response_content else None,
                                files=files if files else None,
                                reference=message,
                                mention_author=True
                            )

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"âœ… [å›å¤æˆåŠŸ] çœŸå®å‘é€è´¦å·: {target_client.user.name} (ID: {target_client.account_id}) | å•†å“ID: {product.get('id')} | å›¾ç‰‡æ•°é‡: {len(files)}"
                            )

                        except Exception as reply_error:
                            logger.warning(f"å›å¤å¤±è´¥ï¼Œå°è¯•ç›´æ¥å‘é€: {reply_error}")
                            if response_content:
                                await target_channel.send(response_content)

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"âœ… [å‘é€æˆåŠŸ] çœŸå®å‘é€è´¦å·: {target_client.user.name} | å•†å“ID: {product.get('id')}"
                            )

                    else:
                        logger.warning(
                            f"âŒ é€‰ä¸­çš„è´¦å· {target_client.user.name} æ— æ³•è®¿é—®é¢‘é“ {message.channel.id} (å¯èƒ½ä¸åœ¨è¯¥æœåŠ¡å™¨)"
                        )
                        return

                except Exception as e:
                    logger.error(f"âŒ å‘é€å¼‚å¸¸: {e}")

        except Exception as e:
            logger.error(f"âŒ ä¸¥é‡é”™è¯¯: {e}")

    def _generate_reply_content(self, product, channel_id, custom_reply=None):
        """ç”Ÿæˆå›å¤å†…å®¹"""
        if custom_reply:
            reply_type = custom_reply.get('reply_type')

            if reply_type == 'custom_only':
                # åªå‘é€è‡ªå®šä¹‰å†…å®¹ï¼Œä¸å‘é€é“¾æ¥
                return custom_reply.get('content', '')

            elif reply_type == 'text_and_link':
                # å‘é€æ–‡å­— + é“¾æ¥
                response = get_response_url_for_channel(product, channel_id, self.user_id)
                return f"{custom_reply.get('content', '')}\n{response}".strip()

            elif reply_type == 'text':
                # åªå‘é€æ–‡å­—
                return custom_reply.get('content', '')

        # é»˜è®¤è¡Œä¸ºï¼šå‘é€é“¾æ¥
        return get_response_url_for_channel(product, channel_id, self.user_id)

    def get_website_config_by_channel(self, channel_id):
        """æ ¹æ®é¢‘é“IDè·å–å¯¹åº”çš„ç½‘ç«™é…ç½®"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # æŸ¥è¯¢é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            configs = db.get_website_configs()
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"è·å–é¢‘é“ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    async def get_website_config_by_channel_async(self, channel_id):
        """å¼‚æ­¥ç‰ˆæœ¬ï¼šæ ¹æ®é¢‘é“IDè·å–å¯¹åº”çš„ç½‘ç«™é…ç½®"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # å¼‚æ­¥æŸ¥è¯¢é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            configs = await asyncio.get_event_loop().run_in_executor(None, db.get_website_configs)
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"å¼‚æ­¥è·å–é¢‘é“ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    def _should_filter_message(self, message):
        """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åº”è¯¥è¢«è¿‡æ»¤"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 1. æ£€æŸ¥å…¨å±€æ¶ˆæ¯è¿‡æ»¤è§„åˆ™
            filters = db.get_message_filters()
            message_content = message.content.lower()

            for filter_rule in filters:
                filter_value = filter_rule['filter_value'].lower()
                filter_type = filter_rule['filter_type']

                if filter_type == 'contains':
                    if filter_value in message_content:
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å« "{filter_value}"')
                        return True
                elif filter_type == 'starts_with':
                    if message_content.startswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" å¼€å¤´')
                        return True
                elif filter_type == 'ends_with':
                    if message_content.endswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" ç»“å°¾')
                        return True
                elif filter_type == 'regex':
                    import re
                    try:
                        if re.search(filter_value, message_content, re.IGNORECASE):
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ¹é…æ­£åˆ™ "{filter_value}"')
                            return True
                    except re.error:
                        logger.warning(f'æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: {filter_value}')
                elif filter_type == 'user_id':
                    # æ£€æŸ¥ç”¨æˆ·IDè¿‡æ»¤
                    filter_user_ids = [uid.strip() for uid in filter_value.split(',') if uid.strip()]
                    sender_id = str(message.author.id)
                    sender_name = str(message.author.name).lower()

                    for blocked_id in filter_user_ids:
                        blocked_id = blocked_id.strip()
                        if blocked_id == sender_id or blocked_id.lower() in sender_name:
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} (ID: {sender_id}) åœ¨è¿‡æ»¤åˆ—è¡¨ä¸­')
                            return True

            # 2. æ£€æŸ¥ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®çš„è¿‡æ»¤è§„åˆ™
            if self.user_id:
                user_settings = db.get_user_settings(self.user_id)
                if user_settings:
                    # æ£€æŸ¥ç”¨æˆ·é»‘åå•
                    user_blacklist = user_settings.get('user_blacklist', '')
                    if user_blacklist:
                        blacklist_users = [u.strip().lower() for u in user_blacklist.split(',') if u.strip()]
                        sender_name = str(message.author.name).lower()
                        sender_id = str(message.author.id).lower()

                        for blocked_user in blacklist_users:
                            blocked_user = blocked_user.lower()
                            if blocked_user in sender_name or blocked_user == sender_id:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} åœ¨é»‘åå•ä¸­')
                                return True

                    # æ£€æŸ¥å…³é”®è¯è¿‡æ»¤
                    keyword_filters = user_settings.get('keyword_filters', '')
                    if keyword_filters:
                        filter_keywords = [k.strip().lower() for k in keyword_filters.split(',') if k.strip()]

                        for keyword in filter_keywords:
                            if keyword in message_content:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å«å…³é”®è¯ "{keyword}"')
                                return True

        except Exception as e:
            logger.error(f'æ£€æŸ¥æ¶ˆæ¯è¿‡æ»¤å¤±è´¥: {e}')

        return False

    def _get_custom_reply(self):
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            replies = db.get_custom_replies()

            if replies:
                # è¿”å›ä¼˜å…ˆçº§æœ€é«˜çš„æ´»è·ƒå›å¤
                return replies[0]
        except Exception as e:
            logger.error(f'è·å–è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}')

        return None

    async def on_ready(self):
        logger.info(f'Discordæœºå™¨äººå·²ç™»å½•: {self.user} (ID: {self.user.id})')
        logger.info(f'æœºå™¨äººå·²å°±ç»ªï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯')
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            bound_channels = await asyncio.get_event_loop().run_in_executor(None, db.get_all_bound_channel_ids)
            if bound_channels:
                bound_list = sorted(bound_channels)
                preview = ", ".join(bound_list[:5])
                suffix = " ..." if len(bound_list) > 5 else ""
                logger.info(f'ç›‘å¬é¢‘é“: å·²ç»‘å®š {len(bound_list)} ä¸ª ({preview}{suffix})')
            else:
                logger.info('ç›‘å¬é¢‘é“: æœªç»‘å®šé¢‘é“')
        except Exception as e:
            logger.error(f'è·å–ç›‘å¬é¢‘é“å¤±è´¥: {e}')
        self.running = True

        # æ›´æ–°æ•°æ®åº“ä¸­çš„è´¦å·çŠ¶æ€ä¸ºåœ¨çº¿
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            if hasattr(self, 'account_id'):
                db.update_account_status(self.account_id, 'online')
                logger.info(f'è´¦å· {self.account_id} çŠ¶æ€å·²æ›´æ–°ä¸ºåœ¨çº¿')
        except Exception as e:
            logger.error(f'æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}')

    async def on_message(self, message):
        if not self.running:
            return

        # å¿½ç•¥è‡ªå·±çš„æ¶ˆæ¯
        if message.author == self.user:
            return

        # å¿½ç•¥æœºå™¨äººå’Œwebhookçš„æ¶ˆæ¯
        if message.author.bot or message.webhook_id:
            return

        # 1. å¿½ç•¥ @åˆ«äººçš„ä¿¡æ¯
        if message.mentions:
            return

        # 2. å¿½ç•¥å›å¤åˆ«äººçš„ä¿¡æ¯
        if message.reference is not None:
            return

        # 3. è§’è‰²è¿‡æ»¤ï¼šçº¯ sender è´¦å·å®Œå…¨ä¸å¤„ç†æ¶ˆæ¯
        if self.role == 'sender':
            return

        # =================================================================
        # ã€æ ¸å¿ƒä¿®å¤ã€‘å…ˆæ£€æŸ¥ï¼šè¿™æ¡æ¶ˆæ¯æ‰€åœ¨çš„é¢‘é“ï¼Œæ˜¯å¦å½’å½“å‰è´¦å·"ç›‘å¬"ï¼Ÿ
        # =================================================================
        try:
            # å¼‚æ­¥è·å–è¯¥é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            # å¦‚æœè¿™ä¸ªé¢‘é“æ²¡æœ‰ç»‘å®šä»»ä½•é…ç½®ï¼Œç›´æ¥å¿½ç•¥
            if not website_config:
                # logger.debug(f"é¢‘é“ {message.channel.id} æœªç»‘å®šé…ç½®ï¼Œè´¦å· {self.account_id} å¿½ç•¥æ­¤æ¶ˆæ¯")
                return

            # è¿›ä¸€æ­¥æ£€æŸ¥ï¼šå½“å‰è´¦å·æ˜¯å¦æ˜¯è¯¥é…ç½®çš„åˆæ³•ç›‘å¬è€…ï¼Ÿ
            # è¿™æ˜¯ä¸€ä¸ªå…³é”®æ­¥éª¤ï¼Œé˜²æ­¢æœªç»‘å®šçš„è´¦å·å¤„ç†å·²ç»‘å®šé¢‘é“çš„æ¶ˆæ¯
            try:
                from database import db
            except ImportError:
                from .database import db

            # è·å–è¯¥ç½‘ç«™é…ç½®ç»‘å®šçš„æ‰€æœ‰ç›‘å¬è€…ID
            listener_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_listeners, website_config['id']
            )

            # å¦‚æœå½“å‰è´¦å·ä¸åœ¨ç›‘å¬åˆ—è¡¨ä¸­ï¼Œç›´æ¥å¿½ç•¥
            if self.account_id not in listener_ids:
                # logger.debug(f"è´¦å· {self.account_id} ä¸æ˜¯é¢‘é“ {message.channel.id} çš„ç›‘å¬è€…ï¼Œå¿½ç•¥")
                return

        except Exception as e:
            logger.error(f"æ£€æŸ¥é¢‘é“ç»‘å®šæƒé™å¤±è´¥: {e}")
            return

        # =================================================================
        # ã€æ ¸å¿ƒä¿®å¤ã€‘ç¡®è®¤æˆ‘æœ‰èµ„æ ¼å¤„ç†åï¼Œå†æŠ¢å…¨å±€é”
        # =================================================================
        try:
            if not mark_message_as_processed(message.id):
                logger.info(f"æ¶ˆæ¯ {message.id} å·²è¢«å…¶ä»–(åˆæ³•çš„)Botå¤„ç†ï¼Œè·³è¿‡")
                return
        except Exception as e:
            logger.error(f"æ¶ˆæ¯å»é‡æ£€æŸ¥å¤±è´¥: {e}")
            return

        # 4. è§¦å‘å†…å®¹è¿‡æ»¤è§„åˆ™
        if self._should_filter_message(message):
            return

        logger.info(f'ğŸ“¨ [æ¥æ”¶] è´¦å·:{self.user.name} | é¢‘é“:{message.channel.name} | å†…å®¹: "{message.content[:50]}..."')

        # è·å–ç”¨æˆ·è®¾ç½®
        keyword_reply_enabled = True
        image_reply_enabled = True
        if self.user_id:
            try:
                user_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_settings, self.user_id
                )
                keyword_reply_enabled = user_settings.get('keyword_reply_enabled', 1) == 1
                image_reply_enabled = user_settings.get('image_reply_enabled', 1) == 1
            except Exception as e:
                logger.error(f'è·å–ç”¨æˆ·å›å¤å¼€å…³è®¾ç½®å¤±è´¥: {e}')

        # å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘
        await self.handle_keyword_forward(message)

        # å¤„ç†å…³é”®è¯æœç´¢
        if keyword_reply_enabled:
            await self.handle_keyword_search(message)

        # å¤„ç†å›¾ç‰‡
        if image_reply_enabled and message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and attachment.content_type.startswith('image/'):
                    logger.info(f"ğŸ“· æ£€æµ‹åˆ°å›¾ç‰‡ï¼Œå¼€å§‹å¤„ç†: {attachment.filename}")
                    await self.handle_image(message, attachment)

    async def handle_image(self, message, attachment):
        try:
            # ã€å¢å¼ºç¨³å®šæ€§ã€‘å¢åŠ è¶…æ—¶æ—¶é—´ï¼Œæ·»åŠ ä»£ç†æ”¯æŒ
            timeout = aiohttp.ClientTimeout(total=30, connect=10)  # 30ç§’æ€»è¶…æ—¶ï¼Œ10ç§’è¿æ¥è¶…æ—¶
            image_data = None

            # ã€ä»£ç†é…ç½®ã€‘ä»ç¯å¢ƒå˜é‡è·å–ä»£ç†ï¼ˆæ”¯æŒå›½å†…ç½‘ç»œç¯å¢ƒï¼‰
            proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None

            # ã€ä¼ªè£…å¤´ã€‘æ·»åŠ  User-Agent é˜²æ­¢è¢« Discord CDN æ‹’ç»
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }

            # é‡è¯•æœ€å¤š3æ¬¡
            for attempt in range(3):
                try:
                    logger.info(f"ä¸‹è½½Discordå›¾ç‰‡ (å°è¯• {attempt + 1}/3): {attachment.filename}")
                    # ã€å…³é”®ä¿®å¤ã€‘trust_env=True å…è®¸ä½¿ç”¨ç³»ç»Ÿä»£ç†
                    async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                        async with session.get(attachment.url, proxy=proxy_url) as resp:
                            if resp.status == 200:
                                image_data = await resp.read()
                                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸï¼Œå¤§å°: {len(image_data)} bytes")
                                break
                            else:
                                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : {resp.status}")
                except aiohttp.ClientError as e:
                    logger.warning(f"å›¾ç‰‡ä¸‹è½½ç½‘ç»œé”™è¯¯ (å°è¯• {attempt + 1}/3): {e}")
                    if attempt < 2:  # ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•
                        await asyncio.sleep(2)  # ã€å¢å¼ºã€‘ç­‰å¾…2ç§’åé‡è¯•
                except Exception as e:
                    logger.error(f"å›¾ç‰‡ä¸‹è½½æœªçŸ¥é”™è¯¯ (å°è¯• {attempt + 1}/3): {e}")
                    break

            if image_data is None:
                logger.error("å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                return  # é™é»˜å¤±è´¥ï¼Œä¸å‘é€é”™è¯¯æ¶ˆæ¯

            # ã€æ–°å¢ã€‘AIå¹¶å‘é™åˆ¶ï¼šæœ€å¤šåŒæ—¶2ä¸ªAIæ¨ç†ä»»åŠ¡
            # ä½¿ç”¨Semaphoreæ§åˆ¶å¹¶å‘ï¼Œé˜²æ­¢CPUé¥±å’Œå¯¼è‡´Flaskä¸»çº¿ç¨‹é˜»å¡
            async with ai_concurrency_limit:
                logger.debug(f"ğŸ”’ è·å–AIå¹¶å‘é”ï¼Œå½“å‰ç­‰å¾…é˜Ÿåˆ—: {ai_concurrency_limit._value}")

                # è°ƒç”¨ DINOv2 æœåŠ¡è¯†åˆ«å›¾ç‰‡ï¼Œä¸ä½¿ç”¨åº—é“ºè¿‡æ»¤ï¼ˆæ‰€æœ‰ç”¨æˆ·éƒ½èƒ½è¯†åˆ«æ‰€æœ‰å•†å“ï¼‰
                result = await self.recognize_image(image_data, user_shops=None)

                logger.debug(f"ğŸ”“ é‡Šæ”¾AIå¹¶å‘é”")

            logger.info(f'å›¾ç‰‡è¯†åˆ«ç»“æœ: success={result.get("success") if result else False}, results_count={len(result.get("results", [])) if result else 0}')

            if result and result.get('success') and result.get('results'):
                # è·å–æœ€ä½³åŒ¹é…ç»“æœ
                best_match = result['results'][0]
                similarity = best_match.get('similarity', 0)

                # è·å–ç”¨æˆ·ä¸ªæ€§åŒ–ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                user_threshold = config.DISCORD_SIMILARITY_THRESHOLD  # é»˜è®¤å€¼
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # å¼‚æ­¥è·å–ç”¨æˆ·è®¾ç½®
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            user_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                logger.info(f'æœ€ä½³åŒ¹é…ç›¸ä¼¼åº¦: {similarity:.4f}, ç”¨æˆ·é˜ˆå€¼: {user_threshold:.4f}')

                # ä¸¥æ ¼æ‰§è¡Œç”¨æˆ·è®¾ç½®çš„é˜ˆå€¼
                if similarity >= user_threshold:
                    product = best_match.get('product', {})
                    logger.info(f'âœ… åŒ¹é…æˆåŠŸ! ç›¸ä¼¼åº¦: {similarity:.2f} | å•†å“: {product.get("id")} | é¢‘é“: {message.channel.name}')

                    # æ£€æŸ¥å•†å“æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨å›å¤è§„åˆ™
                    product_rule_enabled = product.get('ruleEnabled', True)

                    if product_rule_enabled:
                        # ä½¿ç”¨å…¨å±€è‡ªå®šä¹‰å›å¤
                        custom_reply = self._get_custom_reply()

                        # ä½¿ç”¨è°ƒåº¦æœºåˆ¶å›å¤ï¼Œè€Œä¸æ˜¯ç›´æ¥å›å¤
                        await self.schedule_reply(message, product, custom_reply)
                    else:
                        # å•†å“çº§è‡ªå®šä¹‰å›å¤
                        custom_text = product.get('custom_reply_text', '').strip()
                        custom_image_indexes = product.get('selectedImageIndexes', [])
                        custom_image_urls = product.get('customImageUrls', [])

                        # å‘é€è‡ªå®šä¹‰æ–‡æœ¬æ¶ˆæ¯
                        if custom_text:
                            await message.reply(custom_text)

                        # å‘é€å›¾ç‰‡ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼šæœ¬åœ°ä¸Šä¼  > è‡ªå®šä¹‰é“¾æ¥ > å•†å“å›¾ç‰‡ï¼‰
                        images_sent = False

                        # ä¼˜å…ˆæ£€æŸ¥å›¾ç‰‡æ¥æºç±»å‹
                        image_source = product.get('image_source', 'product')

                        if image_source == 'upload':
                            # å‘é€æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡
                            try:
                                from database import db
                                # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾ç‰‡ï¼ˆåŒ…æ‹¬ä¸Šä¼ çš„ï¼‰
                                product_images = db.get_product_images(product['id'])
                                if product_images:
                                    for img_data in product_images[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                        try:
                                            image_path = img_data.get('image_path')
                                            # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ„å»ºå®Œæ•´è·¯å¾„
                                            if image_path and not os.path.isabs(image_path):
                                                image_path = os.path.join(os.path.dirname(__file__), image_path)
                                            if image_path and os.path.exists(image_path):
                                                await message.reply(file=discord.File(image_path, os.path.basename(image_path)))
                                                images_sent = True
                                        except Exception as e:
                                            logger.error(f'å‘é€æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif image_source == 'custom' and custom_image_urls and len(custom_image_urls) > 0:
                            # å‘é€è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥
                            try:
                                # ã€ä»£ç†é…ç½®ã€‘ä»ç¯å¢ƒå˜é‡è·å–ä»£ç†
                                proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None
                                # ã€ä¼ªè£…å¤´ã€‘æ·»åŠ  User-Agent
                                headers = {
                                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                                }
                                timeout = aiohttp.ClientTimeout(total=30, connect=10)

                                for url in custom_image_urls[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                    try:
                                        # ã€å…³é”®ä¿®å¤ã€‘trust_env=True å…è®¸ä½¿ç”¨ç³»ç»Ÿä»£ç†
                                        async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                                            async with session.get(url.strip(), proxy=proxy_url) as resp:
                                                if resp.status == 200:
                                                    image_data = await resp.read()
                                                    # ä»URLæå–æ–‡ä»¶å
                                                    filename = url.split('/')[-1].split('?')[0] or f"image_{custom_image_urls.index(url)}.jpg"
                                                    if not filename.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
                                                        filename += '.jpg'
                                                    await message.reply(file=discord.File(io.BytesIO(image_data), filename))
                                                    images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€è‡ªå®šä¹‰å›¾ç‰‡å¤±è´¥ {url}: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†è‡ªå®šä¹‰å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif custom_image_indexes and len(custom_image_indexes) > 0:
                            # å‘é€é€‰ä¸­çš„å•†å“å›¾ç‰‡
                            try:
                                import aiofiles
                                from database import db

                                for image_index in custom_image_indexes:
                                    try:
                                        # è·å–å›¾ç‰‡è·¯å¾„
                                        image_path = db.get_product_image_path(product['id'], image_index)
                                        if image_path and os.path.exists(image_path):
                                            # å‘é€å›¾ç‰‡æ–‡ä»¶
                                            await message.reply(file=discord.File(image_path, f"image_{image_index}.jpg"))
                                            images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€å•†å“å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†å•†å“å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        # å¦‚æœæ—¢æ²¡æœ‰æ–‡æœ¬ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œåˆ™å‘é€é»˜è®¤é“¾æ¥
                        if not custom_text and not images_sent:
                            response = get_response_url_for_channel(product, message.channel.id, self.user_id)
                            await message.reply(response)

                    logger.info(f'å›¾ç‰‡è¯†åˆ«æˆåŠŸï¼Œç›¸ä¼¼åº¦: {similarity:.4f}')
                else:
                    # ç›¸ä¼¼åº¦ä½äºé˜ˆå€¼ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                    logger.info(f'å›¾ç‰‡è¯†åˆ«ç›¸ä¼¼åº¦ {similarity:.4f} ä½äºç”¨æˆ·é˜ˆå€¼ {user_threshold:.4f}ï¼Œä¸å›å¤')

        except Exception as e:
            logger.error(f'Error handling image: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def handle_keyword_forward(self, message):
        """å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘"""
        try:
            # æ£€æŸ¥æ¶ˆæ¯å†…å®¹æ˜¯å¦åŒ…å«å…³é”®è¯
            message_content = message.content.lower() if message.content else ""
            has_keyword = any(keyword.strip().lower() in message_content for keyword in config.FORWARD_KEYWORDS)

            if has_keyword and config.FORWARD_TARGET_CHANNEL_ID:
                # è·å–ç›®æ ‡é¢‘é“
                target_channel = self.get_channel(config.FORWARD_TARGET_CHANNEL_ID)
                if target_channel:
                    # æ„å»ºè½¬å‘æ¶ˆæ¯
                    forward_embed = discord.Embed(
                        title="ğŸ“¢ å•†å“ç›¸å…³æ¶ˆæ¯è½¬å‘",
                        description=f"**åŸå§‹æ¶ˆæ¯:** {message.content[:500]}{'...' if len(message.content) > 500 else ''}",
                        color=0x00ff00,
                        timestamp=message.created_at
                    )

                    forward_embed.add_field(
                        name="å‘é€è€…",
                        value=f"{message.author.name}#{message.author.discriminator}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æ¥æºé¢‘é“",
                        value=f"#{message.channel.name}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æœåŠ¡å™¨",
                        value=message.guild.name if message.guild else "DM",
                        inline=True
                    )

                    # å¦‚æœæœ‰é™„ä»¶ï¼Œæ·»åŠ åˆ°embedä¸­
                    if message.attachments:
                        attachment_urls = [att.url for att in message.attachments]
                        forward_embed.add_field(
                            name="é™„ä»¶",
                            value="\n".join(attachment_urls),
                            inline=False
                        )

                    forward_embed.set_footer(text=f"æ¶ˆæ¯ID: {message.id}")

                    await target_channel.send(embed=forward_embed)
                    logger.info(f"è½¬å‘äº†åŒ…å«å…³é”®è¯çš„æ¶ˆæ¯: {message.content[:100]}...")
                else:
                    logger.warning(f"æ‰¾ä¸åˆ°ç›®æ ‡é¢‘é“: {config.FORWARD_TARGET_CHANNEL_ID}")

        except Exception as e:
            logger.error(f'Error handling keyword forward: {e}')

    async def handle_keyword_search(self, message):
        """å¤„ç†å…³é”®è¯å•†å“æœç´¢"""
        try:
            # åªå¤„ç†çº¯æ–‡å­—æ¶ˆæ¯ï¼ˆä¸åŒ…å«å›¾ç‰‡çš„ï¼‰
            if not message.content or message.attachments:
                return

            search_query = message.content.strip()
            if not search_query:
                return

            # è¿‡æ»¤å¤ªçŸ­çš„æ¶ˆæ¯ï¼ˆè‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦ï¼‰
            if len(search_query) < 2:
                return

            # è¿‡æ»¤çº¯æ•°å­—æ¶ˆæ¯ï¼ˆå¦‚ "1", "2", "123"ï¼‰
            if search_query.isdigit():
                return

            # è¿‡æ»¤åªåŒ…å«æ•°å­—å’Œç©ºæ ¼çš„æ¶ˆæ¯ï¼ˆå¦‚ "1 2 3"ï¼‰
            if search_query.replace(' ', '').isdigit():
                return

            # è¿‡æ»¤å¸¸è§çš„æ— æ„ä¹‰çŸ­æ¶ˆæ¯
            meaningless_patterns = {'ok', 'no', 'yes', 'hi', 'hey', 'lol', 'lmao', 'wtf', 'omg', 'bruh'}
            if search_query.lower() in meaningless_patterns:
                return

            # è°ƒç”¨æœç´¢API
            result = await self.search_products_by_keyword(search_query)

            products = []
            if result and result.get('success') and result.get('products'):
                products = result['products'][:5]  # æœ€å¤šæ˜¾ç¤º5ä¸ªç»“æœ

            # åªåœ¨æ‰¾åˆ°å•†å“æ—¶å›å¤å’Œè®°å½•æ—¥å¿—
            if products:
                logger.info(f'å…³é”®è¯æœç´¢æˆåŠŸ: "{search_query}" -> æ‰¾åˆ° {len(products)} ä¸ªå•†å“')
                product = products[0]

                # æ£€æŸ¥é¢‘é“æ˜¯å¦ç»‘å®šäº†ç½‘ç«™é…ç½®ï¼ˆå¿…é¡»ç»‘å®šæ‰èƒ½å›å¤ï¼‰
                website_config = await self.get_website_config_by_channel_async(message.channel.id)
                if not website_config:
                    logger.info(f"é¢‘é“ {message.channel.id} æœªç»‘å®šç½‘ç«™é…ç½®ï¼Œè·³è¿‡å…³é”®è¯å›å¤")
                    return

                # === å…³é”®ä¿®å¤é€»è¾‘ ===
                # æ£€æŸ¥è§„åˆ™æ˜¯å¦å¯ç”¨ï¼ˆå…¼å®¹å­—ç¬¦ä¸²/æ•°å­—ï¼‰
                # æ³¨æ„ï¼šåç«¯APIè¿”å›çš„ autoReplyEnabled å³ ruleEnabled
                rule_enabled = product.get('autoReplyEnabled', True)
                if isinstance(rule_enabled, str):
                    rule_enabled = rule_enabled.strip().lower() not in {'0', 'false', 'no', 'off'}
                elif isinstance(rule_enabled, (int, float)):
                    rule_enabled = bool(rule_enabled)

                custom_reply = None

                # æ£€æŸ¥æ˜¯å¦é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡
                def _coerce_list(value):
                    if not value:
                        return []
                    if isinstance(value, str):
                        try:
                            parsed = json.loads(value)
                        except json.JSONDecodeError:
                            return []
                        return parsed if isinstance(parsed, list) else []
                    if isinstance(value, list):
                        return value
                    return []

                has_custom_images = False
                image_source = product.get('imageSource') or product.get('image_source')

                if image_source == 'upload':
                    uploaded_imgs = _coerce_list(product.get('uploaded_reply_images'))
                    product['uploaded_reply_images'] = uploaded_imgs
                    has_custom_images = bool(uploaded_imgs)
                elif image_source == 'custom':
                    custom_urls = _coerce_list(product.get('customImageUrls')) or _coerce_list(product.get('custom_image_urls'))
                    if custom_urls:
                        product['customImageUrls'] = custom_urls
                    has_custom_images = bool(custom_urls)
                elif image_source == 'product':
                    selected_indexes = _coerce_list(product.get('selectedImageIndexes')) or _coerce_list(product.get('custom_reply_images'))
                    if selected_indexes:
                        product['selectedImageIndexes'] = selected_indexes
                    has_custom_images = bool(selected_indexes)

                # å¦‚æœè§„åˆ™ç¦ç”¨äº†ï¼Œæˆ–è€…é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡ï¼Œéƒ½éœ€è¦åˆ›å»º custom_reply
                if not rule_enabled or has_custom_images:
                    # æ„é€  custom_reply å¯¹è±¡ä¾› schedule_reply ä½¿ç”¨
                    custom_text = (product.get('custom_reply_text') or '').strip()

                    # å³ä½¿æ²¡æœ‰æ–‡æœ¬ï¼Œåªè¦æ˜¯è¦å‘å›¾ç‰‡ï¼Œä¹Ÿéœ€è¦ä¼ é€’ custom_reply ä¿¡å·
                    # schedule_reply ä¼šè¿›ä¸€æ­¥å¤„ç†å›¾ç‰‡é€»è¾‘
                    custom_reply = {
                        'reply_type': 'text' if custom_text else 'custom_only', # custom_only è¡¨ç¤ºä¸å‘é»˜è®¤é“¾æ¥
                        'content': custom_text,
                        # ä¼ é€’å›¾ç‰‡ä¿¡æ¯ä¾› schedule_reply å†…éƒ¨å¤„ç†
                        'product_data': product
                    }
                    if not rule_enabled:
                        logger.info(f"å•†å“ {product['id']} è§„åˆ™å·²ç¦ç”¨ï¼Œå‡†å¤‡å‘é€è‡ªå®šä¹‰å›å¤")
                    elif has_custom_images:
                        logger.info(f"å•†å“ {product['id']} é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡ï¼Œå‡†å¤‡å‘é€è‡ªå®šä¹‰å›å¤")

                # ä½¿ç”¨ schedule_reply ç»Ÿä¸€å‘é€
                await self.schedule_reply(message, product, custom_reply)
            else:
                # æ²¡æœ‰æ‰¾åˆ°å•†å“ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                logger.info(f'å…³é”®è¯æœç´¢æ— ç»“æœ: {search_query}')

        except Exception as e:
            logger.error(f'Error handling keyword search: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def search_products_by_keyword(self, keyword):
        """æ ¹æ®å…³é”®è¯æœç´¢å•†å“"""
        try:
            # è®¾ç½®è¶…æ—¶æ—¶é—´
            timeout = aiohttp.ClientTimeout(total=10)  # 10ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # æ„å»ºæœç´¢è¯·æ±‚
                search_data = {
                    'query': keyword,
                    'limit': 10  # æœç´¢æ›´å¤šç»“æœï¼Œä½†åªæ˜¾ç¤ºå‰5ä¸ª
                }

                # è°ƒç”¨åç«¯æœç´¢API
                async with session.post(f'{config.BACKEND_API_URL}/api/search_similar_text',
                                      json=search_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'Keyword search API error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error searching products by keyword: {e}')
            return None

    async def recognize_image(self, image_data, user_shops=None):
        try:
            # å¢åŠ è¶…æ—¶æ—¶é—´ï¼ŒFAISSæœç´¢å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´
            timeout = aiohttp.ClientTimeout(total=30)  # 30ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # å‡†å¤‡å›¾ç‰‡æ•°æ®
                form_data = aiohttp.FormData()
                form_data.add_field('image', image_data, filename='image.jpg', content_type='image/jpeg')
                # ä½¿ç”¨é…ç½®çš„é˜ˆå€¼
                # ä½¿ç”¨ç”¨æˆ·ä¸ªæ€§åŒ–é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                api_threshold = config.DISCORD_SIMILARITY_THRESHOLD
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # å¼‚æ­¥è·å–ç”¨æˆ·è®¾ç½®
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            api_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                form_data.add_field('threshold', str(api_threshold))
                form_data.add_field('limit', '1')  # Discordåªè¿”å›æœ€ç›¸ä¼¼çš„ä¸€ä¸ªç»“æœ

                # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
                if user_shops:
                    form_data.add_field('user_shops', json.dumps(user_shops))

                # è°ƒç”¨ DINOv2 + FAISS æœåŠ¡ï¼ˆæœ¬åœ°ï¼‰
                async with session.post(f'{config.BACKEND_API_URL.replace("/api", "")}/search_similar', data=form_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        return None

        except asyncio.TimeoutError:
            logger.error('Error recognizing image: Request timeout (30s)')
            return None
        except aiohttp.ClientError as e:
            logger.error(f'Error recognizing image: Network error - {type(e).__name__}: {e}')
            return None
        except Exception as e:
            logger.error(f'Error recognizing image: {type(e).__name__}: {e}')
            return None

async def get_all_accounts_from_backend():
    """ä»åç«¯ API è·å–æ‰€æœ‰å¯ç”¨çš„ Discord è´¦å·"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f'{config.BACKEND_API_URL}/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    # åªè¿”å›çŠ¶æ€ä¸ºonlineçš„è´¦å·
                    return [account for account in accounts if account.get('status') == 'online']
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def bot_loop(client):
    """ä¸»å¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥å¹¶é‡è¿"""
    while True:
        try:
            token = await get_token_from_backend()
            if token:
                if not client.is_ready():
                    logger.info('Starting Discord bot with token from database...')
                    await client.start(token, reconnect=True)
                elif client.current_token != token:
                    logger.info('Token changed, reconnecting...')
                    await client.close()
                    await asyncio.sleep(2)
                    client.current_token = token
                    await client.start(token, reconnect=True)
            else:
                logger.warning('No active token found in database, waiting...')
                if client.is_ready():
                    await client.close()
                client.current_token = None

        except Exception as e:
            logger.error(f'Bot loop error: {e}')
            if client.is_ready():
                await client.close()

        # ç­‰å¾… 30 ç§’åå†æ¬¡æ£€æŸ¥
        await asyncio.sleep(30)

async def start_multi_bot_loop():
    """å¯åŠ¨å¤šè´¦å·æœºå™¨äººå¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥è´¦å·çŠ¶æ€"""
    global bot_clients, bot_tasks

    while True:
        try:
            # è·å–å½“å‰æ‰€æœ‰è´¦å·
            accounts = await get_all_accounts_from_backend()
            current_account_ids = {account['id'] for account in accounts}

            # åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº
            to_remove = []
            for i, client in enumerate(bot_clients):
                if client.account_id not in current_account_ids:
                    logger.info(f'åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº: {client.account_id}')
                    try:
                        if not client.is_closed():
                            await client.close()
                    except Exception as e:
                        logger.error(f'åœæ­¢æœºå™¨äººæ—¶å‡ºé”™: {e}')

                    # å–æ¶ˆå¯¹åº”çš„ä»»åŠ¡
                    if i < len(bot_tasks) and bot_tasks[i] and not bot_tasks[i].done():
                        bot_tasks[i].cancel()

                    to_remove.append(i)

            # ä»åˆ—è¡¨ä¸­ç§»é™¤å·²åœæ­¢çš„æœºå™¨äºº
            for i in reversed(to_remove):
                bot_clients.pop(i)
                if i < len(bot_tasks):
                    bot_tasks.pop(i)

            # ä¸ºæ–°è´¦å·å¯åŠ¨æœºå™¨äºº
            existing_account_ids = {client.account_id for client in bot_clients}
            for account in accounts:
                account_id = account['id']
                if account_id not in existing_account_ids:
                    token = account['token']
                    username = account.get('username', f'account_{account_id}')

                    logger.info(f'å¯åŠ¨æ–°è´¦å·æœºå™¨äºº: {username}')

                    # åˆ›å»ºæœºå™¨äººå®ä¾‹
                    client = DiscordBotClient(account_id=account_id)

                    # å¯åŠ¨æœºå™¨äºº
                    try:
                        task = asyncio.create_task(client.start(token, reconnect=True))
                        bot_clients.append(client)
                        bot_tasks.append(task)
                        logger.info(f'æœºå™¨äººå¯åŠ¨æˆåŠŸ: {username}')
                    except Exception as e:
                        logger.error(f'å¯åŠ¨æœºå™¨äººå¤±è´¥ {username}: {e}')

            # ç­‰å¾…ä¸€æ®µæ—¶é—´åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(30)

        except Exception as e:
            logger.error(f'å¤šè´¦å·æœºå™¨äººå¾ªç¯é”™è¯¯: {e}')
            await asyncio.sleep(30)

async def main():
    client = DiscordBotClient()

    # å¯åŠ¨ä¸»å¾ªç¯
    await bot_loop(client)

if __name__ == '__main__':
    asyncio.run(main())

===== backend/config.py =====
"""
é…ç½®æ–‡ä»¶ - Discord è‡ªåŠ¨è¥é”€æœºå™¨äººç³»ç»Ÿ
"""
import os


class Config:
    """åº”ç”¨é…ç½®ç±»"""

    # Flask æœåŠ¡é…ç½®
    FLASK_HOST = "127.0.0.1"
    FLASK_PORT = 5001
    FLASK_DEBUG = False

    # åç«¯ API URL (ç”¨äºå†…éƒ¨é€šä¿¡)
    BACKEND_API_URL = f"http://{FLASK_HOST}:{FLASK_PORT}/api"

    # æ•°æ®åº“é…ç½®
    DATABASE_PATH = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

    # Discord é…ç½®
    DISCORD_SIMILARITY_THRESHOLD = 0.6  # å›¾ç‰‡ç›¸ä¼¼åº¦é˜ˆå€¼

    # ä¸‹è½½é…ç½®
    DOWNLOAD_THREADS = 4  # ä¸‹è½½çº¿ç¨‹æ•°
    FEATURE_EXTRACT_THREADS = 4  # ç‰¹å¾æå–çº¿ç¨‹æ•°
    SCRAPE_THREADS = 2  # æŠ“å–çº¿ç¨‹æ•°

    # æ¶ˆæ¯è½¬å‘é…ç½® (å¯é€‰)
    FORWARD_KEYWORDS = []  # è§¦å‘è½¬å‘çš„å…³é”®è¯åˆ—è¡¨
    FORWARD_TARGET_CHANNEL_ID = None  # è½¬å‘ç›®æ ‡é¢‘é“ ID

    # ç‰¹å®šå¹³å°é¢‘é“ ID (å¯é€‰ï¼Œç”¨äºå‘é€ç‰¹å®šå¹³å°é“¾æ¥)
    CNFANS_CHANNEL_ID = None
    ACBUY_CHANNEL_ID = None

    # è‡ªåŠ¨å‘é€é»˜è®¤é…ç½®
    DEFAULT_SEND_INTERVAL = 60  # é»˜è®¤å‘é€é—´éš”ï¼ˆç§’ï¼‰
    MIN_SEND_INTERVAL = 10  # æœ€å°å‘é€é—´éš”ï¼ˆç§’ï¼‰
    MAX_SEND_INTERVAL = 3600  # æœ€å¤§å‘é€é—´éš”ï¼ˆç§’ï¼‰

    # è®¸å¯è¯æ¿€æ´»æœåŠ¡é…ç½®
    LICENSE_SERVER_URL = "http://107.172.1.7:8888"
    LICENSE_ALLOW_TEST_KEYS = True
    LICENSE_TEST_KEYS = [
        "TEST-FOREVER-0001",
        "TEST-FOREVER-0002",
        "TEST-FOREVER-0003"
    ]


# å…¨å±€é…ç½®å®ä¾‹
config = Config()

===== backend/database.py =====
import sqlite3
import numpy as np
import os
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager
try:
    from config import config
except ImportError:
    from .config import config

logger = logging.getLogger(__name__)

class Database:
    def __init__(self):
        # SQLite æ•°æ®åº“è·¯å¾„ (ç”¨äºå­˜å‚¨å•†å“å…ƒæ•°æ®å’ŒDiscordè´¦å·ä¿¡æ¯)
        self.db_path = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

        # ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # åˆå§‹åŒ– SQLite æ•°æ®åº“
        self.init_sqlite_database()

    def init_sqlite_database(self):
        """åˆå§‹åŒ– SQLite æ•°æ®åº“ (ç”¨äºå…ƒæ•°æ®å­˜å‚¨)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # åˆ›å»ºå•†å“è¡¨ï¼ˆç§»é™¤å•†å“çº§åˆ«å»¶è¿Ÿï¼Œä½¿ç”¨å…¨å±€å»¶è¿Ÿï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_url TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    english_title TEXT,
                    cnfans_url TEXT,
                    acbuy_url TEXT,
                    shop_name TEXT,
                    ruleEnabled BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_shop_name ON products(shop_name)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_rule_enabled ON products(ruleEnabled)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_image_index ON product_images(image_index)')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºåº—é“ºè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS shops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    shop_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    product_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # ä¸ºç°æœ‰è¡¨æ·»åŠ æ–°å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN ruleEnabled BOOLEAN DEFAULT 1')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN min_delay INTEGER DEFAULT 3')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN max_delay INTEGER DEFAULT 8')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # æ–°å¢è‹±æ–‡æ ‡é¢˜ä¸ cnfans é“¾æ¥å­—æ®µï¼ˆå…¼å®¹å·²æœ‰æ•°æ®åº“ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN english_title TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN cnfans_url TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN acbuy_url TEXT')
            except sqlite3.OperationalError:
                pass

            # æ·»åŠ è‡ªå®šä¹‰å›å¤å­—æ®µ
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_text TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_images TEXT')  # JSONæ ¼å¼å­˜å‚¨å›¾ç‰‡ç´¢å¼•æ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_image_urls TEXT')  # JSONæ ¼å¼å­˜å‚¨è‡ªå®šä¹‰å›¾ç‰‡URLæ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN image_source TEXT DEFAULT \'product\'')  # å›¾ç‰‡æ¥æºï¼š'product'(å•†å“å›¾ç‰‡), 'upload'(æœ¬åœ°ä¸Šä¼ ), 'custom'(URL)
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN shop_name TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN item_id TEXT')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN updated_at TIMESTAMP')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN uploaded_reply_images TEXT')  # JSONæ ¼å¼å­˜å‚¨ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡æ–‡ä»¶åæ•°ç»„
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN cnfans_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN acbuy_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºå›¾ç‰‡è¡¨ (milvus_id æ›¿ä»£ faiss_id)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS product_images (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    image_index INTEGER NOT NULL,
                    features TEXT,  -- å­˜å‚¨åºåˆ—åŒ–çš„ç‰¹å¾å‘é‡
                    milvus_id INTEGER UNIQUE,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE,
                    UNIQUE(product_id, image_index)
                )
            ''')

            # åˆ›å»ºç”¨æˆ·è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT DEFAULT 'user',  -- admin, user
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç”¨æˆ·-åº—é“ºæƒé™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_shop_permissions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    shop_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id, shop_id)
                )
            ''')

            # åˆ›å»º Discord è´¦å·è¡¨ï¼ˆå…³è”åˆ°ç”¨æˆ·ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS discord_accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    token TEXT UNIQUE NOT NULL,
                    user_id INTEGER,
                    status TEXT DEFAULT 'offline',
                    last_active TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL
                )
            ''')

            # æ’å…¥é»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO users (id, username, password_hash, role, is_active)
                    VALUES (1, 'admin', 'hashed_admin123', 'admin', 1)
                ''')  # å¯†ç : admin123
            except sqlite3.Error as e:
                logger.warning(f"åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜å¤±è´¥: {e}")

            # åˆ›å»ºè´¦å·è½®æ¢é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS account_rotation_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    enabled BOOLEAN DEFAULT 0,
                    rotation_interval INTEGER DEFAULT 10,
                    current_account_id INTEGER,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤è½®æ¢é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO account_rotation_config (id, enabled, rotation_interval)
                VALUES (1, 0, 10)
            ''')

            # åˆ›å»ºæœç´¢å†å²è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS search_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    query_image_path TEXT NOT NULL,
                    matched_product_id INTEGER,
                    matched_image_index INTEGER,
                    similarity REAL NOT NULL,
                    threshold REAL NOT NULL,
                    search_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (matched_product_id) REFERENCES products (id) ON DELETE SET NULL
                )
            ''')

            # ã€æ–°å¢ä¼˜åŒ–ã€‘ä¸ºæœç´¢å†å²åˆ›å»ºæ—¶é—´ç´¢å¼•ï¼Œæå¤§æå‡ç¿»é¡µé€Ÿåº¦
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_search_history_time ON search_history(search_time DESC)')
            except Exception:
                pass

            # åˆ›å»ºå…¨å±€å»¶è¿Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS global_reply_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    min_delay REAL DEFAULT 3.0,
                    max_delay REAL DEFAULT 8.0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    discord_channel_id TEXT DEFAULT '',
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    cnfans_channel_id TEXT DEFAULT '',
                    acbuy_channel_id TEXT DEFAULT '',
                    scrape_threads INTEGER DEFAULT 2,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç³»ç»Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                VALUES (1, '', 4, 4, 0.6, '', '')
            ''')

            # ä¸ºç°æœ‰è®°å½•æ·»åŠ scrape_threadså­—æ®µ
            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN scrape_threads INTEGER DEFAULT 2')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # åˆ›å»ºç½‘ç«™é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_configs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    display_name TEXT NOT NULL,
                    url_template TEXT NOT NULL,
                    id_pattern TEXT NOT NULL,
                    badge_color TEXT DEFAULT 'blue',
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨è½®æ¢åŠŸèƒ½ (1=å¯ç”¨, 0=ç¦ç”¨)
                    message_filters TEXT DEFAULT '[]',  -- JSONæ ¼å¼å­˜å‚¨è¿‡æ»¤æ¡ä»¶æ•°ç»„
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # ä¸ºwebsite_configsè¡¨æ·»åŠ rotation_intervalå­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_interval INTEGER DEFAULT 180')
            except sqlite3.OperationalError:
                pass

            # ä¸ºwebsite_configsè¡¨æ·»åŠ message_filterså­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN message_filters TEXT DEFAULT \'[]\'')
            except sqlite3.OperationalError:
                pass

            # ä¸ºwebsite_configsè¡¨æ·»åŠ rotation_enabledå­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # 1. æ¶ˆæ¯å¤„ç†å»é‡è¡¨ï¼ˆé˜²æ­¢å¤šä¸ªBotå›å¤åŒä¸€æ¡æ¶ˆæ¯ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS processed_messages (
                    message_id TEXT PRIMARY KEY,
                    processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºè‡ªå®šä¹‰å›å¤å†…å®¹è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS custom_replies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reply_type TEXT NOT NULL, -- 'text', 'image', 'text_and_link', 'custom_only'
                    content TEXT, -- æ–‡å­—å†…å®¹æˆ–å›¾ç‰‡URL
                    image_url TEXT, -- å¦‚æœæ˜¯å›¾ç‰‡å›å¤
                    is_active BOOLEAN DEFAULT 1,
                    priority INTEGER DEFAULT 0, -- ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 2. ä¿®æ”¹é¢‘é“ç»‘å®šè¡¨ï¼Œå¢åŠ  user_id å®ç°ç”¨æˆ·éš”ç¦»
            try:
                cursor.execute('ALTER TABLE website_channel_bindings ADD COLUMN user_id INTEGER')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºç½‘ç«™é¢‘é“ç»‘å®šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_channel_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    channel_id TEXT NOT NULL,
                    user_id INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(website_id, channel_id)
                )
            ''')

            # åˆ›å»ºç½‘ç«™è´¦å·ç»‘å®šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_account_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    account_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    role TEXT NOT NULL CHECK (role IN ('listener', 'sender', 'both')),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    FOREIGN KEY (account_id) REFERENCES discord_accounts (id) ON DELETE CASCADE,
                    UNIQUE(website_id, account_id)
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿå…¬å‘Šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_announcements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºæ¶ˆæ¯è¿‡æ»¤è§„åˆ™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS message_filters (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filter_type TEXT NOT NULL, -- 'contains', 'starts_with', 'ends_with', 'regex'
                    filter_value TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç”¨æˆ·è®¾ç½®è¡¨ï¼ˆæ¯ä¸ªç”¨æˆ·çš„ä¸ªæ€§åŒ–è®¾ç½®ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    global_reply_min_delay REAL DEFAULT 3.0,
                    global_reply_max_delay REAL DEFAULT 8.0,
                    user_blacklist TEXT DEFAULT '',  -- ç”¨æˆ·é»‘åå•ï¼Œé€—å·åˆ†éš”
                    keyword_filters TEXT DEFAULT '',  -- å…³é”®è¯è¿‡æ»¤ï¼Œé€—å·åˆ†éš”
                    keyword_reply_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨å…³é”®è¯å›å¤
                    image_reply_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨å›¾ç‰‡å›å¤
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id)
                )
            ''')

            # ä¸º user_settings è¡¨æ·»åŠ æ–°å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN keyword_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN image_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºç”¨æˆ·çº§åˆ«çš„ç½‘ç«™è®¾ç½®è¡¨ï¼ˆè½®æ¢è®¾ç½®å’Œæ¶ˆæ¯è¿‡æ»¤ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_website_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    website_id INTEGER NOT NULL,
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,
                    message_filters TEXT DEFAULT '[]',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(user_id, website_id)
                )
            ''')

            # åˆ›å»ºæŠ“å–çŠ¶æ€è¡¨ï¼ˆæŒä¹…åŒ–å­˜å‚¨æŠ“å–çŠ¶æ€ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scrape_status (
                    id INTEGER PRIMARY KEY CHECK (id = 1),  -- åªå…è®¸ä¸€æ¡è®°å½•
                    is_scraping BOOLEAN DEFAULT 0,
                    stop_signal BOOLEAN DEFAULT 0,
                    current_shop_id TEXT,
                    total INTEGER DEFAULT 0,
                    processed INTEGER DEFAULT 0,
                    success INTEGER DEFAULT 0,
                    progress REAL DEFAULT 0,
                    message TEXT DEFAULT 'ç­‰å¾…å¼€å§‹...',
                    completed BOOLEAN DEFAULT 0,
                    thread_id TEXT,  -- è®°å½•å½“å‰çº¿ç¨‹ID
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç½‘ç«™é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                VALUES
                    ('cnfans', 'CNFans', 'https://cnfans.com/product?id={id}&platform=WEIDIAN', '{id}', 'blue'),
                    ('acbuy', 'AcBuy', 'https://www.acbuy.com/product?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD', '{id}', 'orange'),
                    ('weidian', 'å¾®åº—', 'https://weidian.com/item.html?itemID={id}', '{id}', 'gray')
            ''')

            # æ’å…¥é»˜è®¤çŠ¶æ€è®°å½•
            cursor.execute('''
                INSERT OR IGNORE INTO scrape_status (id, is_scraping, stop_signal, message)
                VALUES (1, 0, 0, 'ç­‰å¾…å¼€å§‹...')
            ''')

            # æ’å…¥é»˜è®¤å…¨å±€å»¶è¿Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO global_reply_config (id, min_delay, max_delay)
                VALUES (1, 3.0, 8.0)
            ''')

            conn.commit()

    def cleanup_processed_messages(self):
        """æ¸…ç†æ—§çš„æ¶ˆæ¯å¤„ç†è®°å½•ï¼Œåªä¿ç•™æœ€è¿‘1å°æ—¶çš„è®°å½•"""
        try:
            with self.get_connection() as conn:
                conn.execute("DELETE FROM processed_messages WHERE processed_at < datetime('now', '-1 hour')")
                conn.commit()
        except Exception as e:
            logger.error(f"æ¸…ç†æ¶ˆæ¯è®°å½•å¤±è´¥: {e}")


    @contextmanager
    def get_connection(self):
        """è·å– SQLite æ•°æ®åº“è¿æ¥çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0) # å¢åŠ è¶…æ—¶æ—¶é—´
            conn.row_factory = sqlite3.Row

            # å…³é”®ä¼˜åŒ–ï¼šå¼€å¯ WAL æ¨¡å¼
            conn.execute('PRAGMA journal_mode=WAL;')
            conn.execute('PRAGMA synchronous=NORMAL;') # ç¨å¾®é™ä½å®‰å…¨æ€§ä»¥æ¢å–æ€§èƒ½

            yield conn
        except sqlite3.IntegrityError:
            # è¿™æ˜¯ä¸€ä¸ªé€»è¾‘æ§åˆ¶ä¿¡å·ï¼ˆå¦‚å”¯ä¸€æ€§çº¦æŸï¼‰ï¼Œç›´æ¥æŠ›å‡ºç»™ä¸Šå±‚å¤„ç†ï¼Œä¸è®°å½•ä¸ºè¿æ¥é”™è¯¯
            raise
        except Exception as e:
            logger.error("æ•°æ®åº“è¿æ¥å¤±è´¥: %s", str(e))
            raise
        finally:
            if conn:
                conn.close()

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> List[Dict]:
        """æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›ç»“æœ"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            if fetch:
                results = [dict(row) for row in cursor.fetchall()]
                conn.commit()
                return results
            conn.commit()
            return []

    def insert_product(self, product_data: Dict) -> int:
        """æ’å…¥å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO products
                (product_url, title, description, english_title, cnfans_url, acbuy_url, shop_name, ruleEnabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                product_data['product_url'],
                product_data.get('title', ''),
                product_data.get('description', ''),
                product_data.get('english_title', ''),
                product_data.get('cnfans_url', ''),
                product_data.get('acbuy_url', ''),
                product_data.get('shop_name', ''),
                product_data.get('ruleEnabled', True)
            ))
            product_id = cursor.lastrowid
            conn.commit()
            return product_id

    def insert_image_record(self, product_id: int, image_path: str, image_index: int, features: np.ndarray = None) -> int:
        """æ’å…¥å›¾åƒè®°å½•åˆ°æ•°æ®åº“ï¼Œè¿”å›è®°å½•IDä¾›FAISSä½¿ç”¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # å°†ç‰¹å¾å‘é‡åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²å­˜å‚¨
                features_str = None
                if features is not None:
                    import json
                    features_str = json.dumps(features.tolist())

                cursor.execute('''
                    INSERT INTO product_images
                    (product_id, image_path, image_index, features)
                    VALUES (?, ?, ?, ?)
                ''', (product_id, image_path, image_index, features_str))
                conn.commit()
                record_id = cursor.lastrowid
                logger.info(f"å›¾åƒè®°å½•æ’å…¥æˆåŠŸ: product_id={product_id}, image_index={image_index}, record_id={record_id}")
                return record_id

        except Exception as e:
            logger.error(f"æ’å…¥å›¾åƒè®°å½•å¤±è´¥: {e}")
            raise e

    def search_similar_images(self, query_vector: np.ndarray, limit: int = 1,
                             threshold: float = 0.6, user_shops: Optional[List[str]] = None) -> List[Dict]:
        """ä½¿ç”¨FAISSæœç´¢ç›¸ä¼¼å›¾åƒ"""
        import time
        start_time = time.time()

        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine

            logger.info(f"å¼€å§‹è·å–FAISSå¼•æ“...")
            engine_start = time.time()
            engine = get_vector_engine()
            logger.info(f"è·å–FAISSå¼•æ“è€—æ—¶: {time.time() - engine_start:.3f}ç§’")

            print(f"DEBUG DB: Starting FAISS search, threshold: {threshold}, limit: {limit}")
            print(f"DEBUG DB: Query vector length: {len(query_vector) if hasattr(query_vector, '__len__') else 'unknown'}")

            # æ‰§è¡ŒFAISSæœç´¢
            faiss_start = time.time()
            faiss_results = engine.search(query_vector, top_k=min(limit * 3, 50))
            logger.info(f"FAISSæœç´¢è€—æ—¶: {time.time() - faiss_start:.3f}ç§’")
            print(f"DEBUG DB: FAISS search returned {len(faiss_results)} results")

            matched_results = []

            for result in faiss_results:
                score = result['score']
                db_id = result['db_id']

                print(f"DEBUG DB: Processing result - db_id: {db_id}, score: {score}, threshold: {threshold}")

                # é€šè¿‡image_db_idè·å–äº§å“ä¿¡æ¯
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    print(f"DEBUG DB: Found image info for db_id {db_id}: product_id={image_info['product_id']}")
                    product_info = self._get_product_info_by_id(image_info['product_id'])

                    if product_info:
                        # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œè¿›è¡Œè¿‡æ»¤
                        if user_shops and product_info.get('shop_name') not in user_shops:
                            print(f"DEBUG DB: Skipping product from shop {product_info.get('shop_name')} - not in user shops {user_shops}")
                            continue

                        print(f"DEBUG DB: Found product info for product_id {image_info['product_id']}: ruleEnabled={product_info.get('ruleEnabled', True)}")
                        result_dict = {
                            **product_info,
                            'similarity': score,
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added result with similarity {score}")

                        # å¦‚æœæ‰¾åˆ°äº†è¶³å¤Ÿçš„ç»“æœï¼Œå°±åœæ­¢
                        if len(matched_results) >= limit:
                            break
                    else:
                        print(f"DEBUG DB: Product info not found for product_id {image_info['product_id']}")
                else:
                    print(f"DEBUG DB: Image info not found for db_id {db_id}")

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç»“æœï¼Œè¿”å›æœ€ä½³åŒ¹é…ï¼ˆå³ä½¿ä½äºé˜ˆå€¼ï¼‰
            if not matched_results and faiss_results:
                print(f"DEBUG DB: No results above threshold {threshold}, returning best match")
                best_result = faiss_results[0]
                db_id = best_result['db_id']
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    product_info = self._get_product_info_by_id(image_info['product_id'])
                    if product_info:
                        result_dict = {
                            **product_info,
                            'similarity': best_result['score'],
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added best match with similarity {best_result['score']}")

            return matched_results

        except Exception as e:
            logger.error(f"FAISSæœç´¢å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _get_product_url_by_id(self, product_id: int) -> Optional[str]:
        """æ ¹æ®äº§å“IDè·å–äº§å“URL"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT product_url FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return row['product_url'] if row else None

    def get_image_info_by_id(self, image_id: int) -> Optional[Dict]:
        """æ ¹æ®å›¾åƒè®°å½•IDè·å–å›¾åƒä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM product_images WHERE id = ?", (image_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def _get_product_info_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®äº§å“IDè·å–å®Œæ•´çš„äº§å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_indexed_product_ids(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT p.product_url
                FROM products p
                JOIN product_images pi ON p.id = pi.product_id
            ''')
            return [row['product_url'] for row in cursor.fetchall()]

    def get_product_images(self, product_id: int) -> List[Dict]:
        """è·å–å•†å“çš„æ‰€æœ‰å›¾ç‰‡åŠå…¶ç‰¹å¾å‘é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, image_path, image_index, features
                    FROM product_images
                    WHERE product_id = ?
                    ORDER BY image_index
                ''', (product_id,))

                images = []
                for row in cursor.fetchall():
                    image_data = dict(row)
                    # ååºåˆ—åŒ–ç‰¹å¾å‘é‡
                    if image_data.get('features'):
                        import json
                        try:
                            features_list = json.loads(image_data['features'])
                            image_data['features'] = np.array(features_list, dtype='float32')
                        except Exception as e:
                            logger.warning(f"ååºåˆ—åŒ–ç‰¹å¾å‘é‡å¤±è´¥: {e}")
                            image_data['features'] = None
                    else:
                        image_data['features'] = None
                    images.append(image_data)

                return images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def delete_product_images(self, product_id: int) -> bool:
        """åˆ é™¤å•†å“çš„æ‰€æœ‰å›¾åƒå’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾åƒè®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_records = []
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ?", (product_id,))
                image_records = [{'id': row['id'], 'path': row['image_path']} for row in cursor.fetchall()]

            if image_records:
                # ä»FAISSä¸­åˆ é™¤å‘é‡
                try:
                    # ä¼˜å…ˆå°è¯•ç»å¯¹å¯¼å…¥
                    from vector_engine import get_vector_engine
                except ImportError:
                    try:
                        # å°è¯•ç›¸å¯¹å¯¼å…¥
                        from .vector_engine import get_vector_engine
                    except ImportError:
                        # å¦‚æœéƒ½å¤±è´¥ï¼Œè·³è¿‡FAISSæ“ä½œ
                        logger.warning("æ— æ³•å¯¼å…¥vector_engineï¼Œè·³è¿‡FAISSå‘é‡åˆ é™¤")
                        engine = None
                    else:
                        engine = get_vector_engine()
                else:
                    engine = get_vector_engine()

                # å¦‚æœæˆåŠŸè·å–åˆ°å¼•æ“ï¼Œåˆ é™¤å‘é‡
                if engine:
                    for record in image_records:
                        try:
                            engine.remove_vector_by_db_id(record['id'])
                        except Exception as e:
                            logger.warning(f"åˆ é™¤FAISSå‘é‡å¤±è´¥ {record['id']}: {e}")

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            for record in image_records:
                if record['path'] and os.path.exists(record['path']):
                    try:
                        os.remove(record['path'])
                        logger.info(f"å·²åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶: {record['path']}")
                    except Exception as e:
                        logger.warning(f"åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ?", (product_id,))
                cursor.execute("DELETE FROM products WHERE id = ?", (product_id,))
                conn.commit()

            # ä¿å­˜FAISSç´¢å¼•
            if image_records and engine:
                try:
                    engine.save()
                    logger.info("FAISSç´¢å¼•å·²ä¿å­˜")
                except Exception as e:
                    logger.warning(f"ä¿å­˜FAISSç´¢å¼•å¤±è´¥: {e}")

            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å•†å“å›¾åƒå¤±è´¥: {e}")
            return False

    def delete_image_record(self, image_id: int) -> bool:
        """æ ¹æ®å›¾ç‰‡IDåˆ é™¤å›¾ç‰‡è®°å½•ï¼ˆç”¨äºå›æ»šæ“ä½œï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE id = ?", (image_id,))
                deleted = cursor.rowcount > 0
                if deleted:
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡è®°å½•: id={image_id}")
                return deleted
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾ç‰‡è®°å½•å¤±è´¥: {e}")
            return False

    def delete_image_vector(self, product_id: int, image_index: int) -> bool:
        """åˆ é™¤ç‰¹å®šçš„å›¾åƒå‘é‡å’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å›¾åƒçš„è®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_path = None
            image_id = None
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))
                row = cursor.fetchone()
                if row:
                    image_id = row['id']
                    image_path = row['image_path']

            if not image_id:
                logger.warning(f"å›¾ç‰‡ä¸å­˜åœ¨: product_id={product_id}, image_index={image_index}")
                return False

            # ä»FAISSä¸­åˆ é™¤å‘é‡å¹¶é‡å»ºç´¢å¼•
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            success = engine.remove_vector_by_db_id(image_id)
            if not success:
                logger.error(f"FAISSåˆ é™¤å‘é‡å¤±è´¥: db_id={image_id}")
                return False

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            if image_path and os.path.exists(image_path):
                try:
                    os.remove(image_path)
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡æ–‡ä»¶: {image_path}")
                except Exception as e:
                    logger.warning(f"åˆ é™¤å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤è®°å½•
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))

               
                conn.commit()

            logger.info(f"å›¾ç‰‡åˆ é™¤æˆåŠŸ: product_id={product_id}, image_index={image_index}")
            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾åƒå‘é‡å¤±è´¥: {e}")
            return False

    def get_product_by_url(self, product_url: str) -> Optional[Dict]:
        """æ ¹æ®å•†å“URLè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_product_by_item_id(self, item_id: str) -> Optional[Dict]:
        """æ ¹æ®å¾®åº—å•†å“IDè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE item_id = ?", (item_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_all_existing_item_ids(self) -> set:
        """è·å–æ•°æ®åº“ä¸­æ‰€æœ‰å·²å­˜åœ¨çš„å•†å“item_idï¼Œç”¨äºå¿«é€ŸæŸ¥é‡"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT item_id FROM products WHERE item_id IS NOT NULL")
            return {row[0] for row in cursor.fetchall()}

    def cleanup_unused_images(self, days_old: int = 30) -> int:
        """
        æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶
        åˆ é™¤é‚£äº›åœ¨æ•°æ®åº“ä¸­ä¸å­˜åœ¨è®°å½•çš„å›¾ç‰‡æ–‡ä»¶ï¼Œæˆ–è€…åˆ é™¤è¶…è¿‡æŒ‡å®šå¤©æ•°çš„æ—§å›¾ç‰‡

        Args:
            days_old: åˆ é™¤å¤šå°‘å¤©å‰çš„å›¾ç‰‡ï¼ˆé»˜è®¤30å¤©ï¼‰

        Returns:
            åˆ é™¤çš„æ–‡ä»¶æ•°é‡
        """
        try:
            import os
            import time

            # è·å–æ‰€æœ‰æ•°æ®åº“ä¸­å­˜åœ¨çš„å›¾ç‰‡è·¯å¾„
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT image_path FROM product_images")
                db_image_paths = set(row['image_path'] for row in cursor.fetchall())

            # è·å–data/imagesç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
            images_dir = os.path.join('data', 'images')
            if not os.path.exists(images_dir):
                return 0

            deleted_count = 0
            cutoff_time = time.time() - (days_old * 24 * 60 * 60)

            for filename in os.listdir(images_dir):
                filepath = os.path.join(images_dir, filename)

                # åªå¤„ç†jpgæ–‡ä»¶
                if not filename.endswith('.jpg'):
                    continue

                # æ£€æŸ¥æ˜¯å¦åœ¨æ•°æ®åº“ä¸­å­˜åœ¨
                if filepath not in db_image_paths:
                    try:
                        os.remove(filepath)
                        logger.info(f"æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶: {filepath}")
                        deleted_count += 1
                    except Exception as e:
                        logger.warning(f"åˆ é™¤æ–‡ä»¶å¤±è´¥ {filepath}: {e}")
                # æˆ–è€…æ£€æŸ¥æ˜¯å¦å¤ªæ—§ï¼ˆå³ä½¿åœ¨æ•°æ®åº“ä¸­ï¼‰
                elif os.path.getmtime(filepath) < cutoff_time:
                    # è¿™é‡Œå¯ä»¥é€‰æ‹©æ˜¯å¦åˆ é™¤æ—§æ–‡ä»¶
                    # æš‚æ—¶ä¿ç•™ï¼Œé¿å…è¯¯åˆ 
                    pass

            if deleted_count > 0:
                logger.info(f"å›¾ç‰‡æ¸…ç†å®Œæˆï¼Œå…±åˆ é™¤ {deleted_count} ä¸ªæœªä½¿ç”¨çš„æ–‡ä»¶")

            return deleted_count

        except Exception as e:
            logger.error(f"å›¾ç‰‡æ¸…ç†å¤±è´¥: {e}")
            return 0

    def get_product_id_by_url(self, product_url: str) -> Optional[int]:
        """æ ¹æ®å•†å“URLè·å–å•†å“å†…éƒ¨ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return row['id'] if row else None

    def get_total_indexed_images(self) -> int:
        """è·å–å·²ç´¢å¼•çš„æ€»å›¾ç‰‡æ•°é‡"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            return engine.count()
        except Exception as e:
            logger.error(f"è·å–ç´¢å¼•å›¾ç‰‡æ•°é‡å¤±è´¥: {e}")
            return 0

    def get_indexed_product_urls(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT DISTINCT p.product_url
                    FROM products p
                    JOIN product_images pi ON p.id = pi.product_id
                ''')
                return [row['product_url'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–å·²ç´¢å¼•å•†å“URLå¤±è´¥: {e}")
            return []

    def add_search_history(self, query_image_path: str, matched_product_id: int,
                          matched_image_index: int, similarity: float, threshold: float) -> bool:
        """æ·»åŠ æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO search_history
                    (query_image_path, matched_product_id, matched_image_index, similarity, threshold)
                    VALUES (?, ?, ?, ?, ?)
                ''', (query_image_path, matched_product_id, matched_image_index, similarity, threshold))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def get_search_history(self, limit: int = 50, offset: int = 0) -> Dict:
        """è·å–æœç´¢å†å²è®°å½•ï¼ˆæ”¯æŒåˆ†é¡µï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–æ€»æ•°
                cursor.execute('SELECT COUNT(*) FROM search_history')
                total = cursor.fetchone()[0]

                # è·å–åˆ†é¡µæ•°æ®
                cursor.execute('''
                    SELECT
                        sh.id,
                        sh.query_image_path,
                        sh.matched_product_id,
                        sh.matched_image_index,
                        sh.similarity,
                        sh.threshold,
                        sh.search_time,
                        p.title,
                        p.english_title,
                        p.product_url as weidian_url,
                        p.cnfans_url,
                        p.acbuy_url,
                        p.ruleEnabled,
                        pi.image_path as matched_image_path
                    FROM search_history sh
                    LEFT JOIN products p ON sh.matched_product_id = p.id
                    LEFT JOIN product_images pi ON sh.matched_product_id = pi.product_id AND sh.matched_image_index = pi.image_index
                    ORDER BY sh.search_time DESC
                    LIMIT ? OFFSET ?
                ''', (limit, offset))
                rows = cursor.fetchall()
                history = []
                for row in rows:
                    history.append({
                        'id': row['id'],
                        'query_image_path': row['query_image_path'],
                        'matched_product_id': row['matched_product_id'],
                        'matched_image_index': row['matched_image_index'],
                        'similarity': row['similarity'],
                        'threshold': row['threshold'],
                        'search_time': row['search_time'],
                        'title': row['title'],
                        'english_title': row['english_title'],
                        'weidian_url': row['weidian_url'],
                        'cnfans_url': row['cnfans_url'],
                        'acbuy_url': row['acbuy_url'],
                        'ruleEnabled': row['ruleEnabled'],
                        'matched_image_path': row['matched_image_path']
                    })

                return {
                    'history': history,
                    'total': total,
                    'limit': limit,
                    'offset': offset,
                    'has_more': offset + limit < total
                }
        except Exception as e:
            logger.error(f"è·å–æœç´¢å†å²å¤±è´¥: {e}")
            return []

    def delete_search_history(self, history_id: int) -> bool:
        """åˆ é™¤æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history WHERE id = ?', (history_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def clear_search_history(self) -> bool:
        """æ¸…ç©ºæ‰€æœ‰æœç´¢å†å²"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history')
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ¸…ç©ºæœç´¢å†å²å¤±è´¥: {e}")
            return False

    # ===== ç”¨æˆ·æƒé™ç®¡ç†æ–¹æ³• =====

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """ç”¨æˆ·è®¤è¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, role, is_active, created_at
                    FROM users
                    WHERE username = ? AND is_active = 1
                ''', (username,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    stored_hash = user_dict.get('password_hash')

                    # éªŒè¯å¯†ç 
                    authenticated = False

                    if stored_hash:
                        # é¦–å…ˆå°è¯•Werkzeugå“ˆå¸ŒéªŒè¯ï¼ˆæ–°ç”¨æˆ·ï¼‰
                        from werkzeug.security import check_password_hash
                        if check_password_hash(stored_hash, password):
                            authenticated = True
                        # å¦‚æœå¤±è´¥ï¼Œå°è¯•æ—§çš„å“ˆå¸Œæ–¹å¼ï¼ˆå…¼å®¹æ—§ç”¨æˆ·ï¼‰
                        elif stored_hash == f"hashed_{password}":
                            authenticated = True

                    if authenticated:
                        # è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º
                        user_dict['shops'] = self.get_user_shops(user_dict['id'])
                        return user_dict
                return None
        except Exception as e:
            logger.error(f"ç”¨æˆ·è®¤è¯å¤±è´¥: {e}")
            return None

    def create_user(self, username: str, password_hash: str, role: str = 'user') -> bool:
        """åˆ›å»ºæ–°ç”¨æˆ·ï¼ˆpassword_hash ç”±ä¸Šå±‚ç”Ÿæˆï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute('''
                    INSERT INTO users (username, password_hash, role, is_active)
                    VALUES (?, ?, ?, 1)
                ''', (username, password_hash, role))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            logger.warning(f"ç”¨æˆ·åå·²å­˜åœ¨: {username}")
            return False
        except Exception as e:
            logger.error(f"åˆ›å»ºç”¨æˆ·å¤±è´¥: {e}")
            return False

    def get_all_users(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    ORDER BY created_at DESC
                ''')
                users = []
                for row in cursor.fetchall():
                    user = dict(row)
                    user['shops'] = self.get_user_shops(user['id'])
                    users.append(user)
                return users
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_user_shops(self, user_id: int) -> List[str]:
        """è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT shop_id FROM user_shop_permissions
                    WHERE user_id = ?
                ''', (user_id,))
                return [row['shop_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return []

    def update_user_shops(self, user_id: int, shop_ids: List[str]) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„åº—é“ºæƒé™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # å…ˆåˆ é™¤æ—§çš„æƒé™
                cursor.execute('DELETE FROM user_shop_permissions WHERE user_id = ?', (user_id,))

                # æ·»åŠ æ–°çš„æƒé™
                for shop_id in shop_ids:
                    cursor.execute('''
                        INSERT INTO user_shop_permissions (user_id, shop_id)
                        VALUES (?, ?)
                    ''', (user_id, shop_id))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return False

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    WHERE id = ?
                ''', (user_id,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    user_dict['shops'] = self.get_user_shops(user_id)
                    return user_dict
                return None
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_discord_account_user(self, account_id: int, user_id: Optional[int]) -> bool:
        """æ›´æ–°Discordè´¦å·å…³è”çš„ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET user_id = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°Discordè´¦å·ç”¨æˆ·å…³è”å¤±è´¥: {e}")
            return False

    def get_discord_accounts_by_user(self, user_id: Optional[int]) -> List[Dict]:
        """è·å–ç”¨æˆ·å…³è”çš„Discordè´¦å·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id is None:
                    # ç®¡ç†å‘˜æŸ¥è¯¢æ‰€æœ‰è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                    FROM discord_accounts
                    ORDER BY created_at DESC
                    ''')
                else:
                    # æ™®é€šç”¨æˆ·æŸ¥è¯¢è‡ªå·±çš„è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                        FROM discord_accounts
                        WHERE user_id = ?
                        ORDER BY created_at DESC
                    ''', (user_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·Discordè´¦å·å¤±è´¥: {e}")
            return []

    def update_product_title(self, product_id: int, title: str) -> bool:
        """æ›´æ–°å•†å“æ ‡é¢˜"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE products
                    SET title = ?, updated_at = datetime('now')
                    WHERE id = ?
                ''', (title, product_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return False

    def update_product(self, product_id: int, updates: Dict) -> bool:
        """æ›´æ–°å•†å“ä¿¡æ¯ï¼ˆé€šç”¨æ–¹æ³•ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºåŠ¨æ€æ›´æ–°è¯­å¥
                set_parts = []
                params = []
                allowed_fields = [
                    'title', 'english_title', 'ruleEnabled',
                    'custom_reply_text', 'custom_reply_images', 'custom_image_urls',
                    'image_source', 'uploaded_reply_images'
                ]

                for field in allowed_fields:
                    if field in updates:
                        set_parts.append(f'{field} = ?')
                        if (field == 'custom_reply_images' or field == 'custom_image_urls') and isinstance(updates[field], list):
                            # å°†å›¾ç‰‡ç´¢å¼•æˆ–URLæ•°ç»„è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                            params.append(json.dumps(updates[field]))
                        else:
                            params.append(updates[field])

                if not set_parts:
                    return False

                set_parts.append('updated_at = datetime(\'now\')')

                query = f'''
                    UPDATE products
                    SET {', '.join(set_parts)}
                    WHERE id = ?
                '''
                params.append(product_id)

                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“å¤±è´¥: {e}")
            return False

    def get_product_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM products WHERE id = ?', (product_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            logger.error(f"è·å–å•†å“å¤±è´¥: {e}")
            return None

    def delete_user(self, user_id: int) -> bool:
        """åˆ é™¤ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # é¦–å…ˆåˆ é™¤ç”¨æˆ·çš„æ‰€æœ‰ç›¸å…³æ•°æ®
                # åˆ é™¤ç”¨æˆ·çš„ç½‘ç«™è´¦å·ç»‘å®š
                cursor.execute('DELETE FROM website_account_bindings WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·çš„Discordè´¦å·
                cursor.execute('DELETE FROM discord_accounts WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·çš„è®¾ç½®
                cursor.execute('DELETE FROM user_settings WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·
                cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç”¨æˆ·å¤±è´¥: {e}")
            return False

    def update_account_status(self, account_id: int, status: str) -> bool:
        """æ›´æ–°Discordè´¦å·çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET status = ?, last_active = datetime('now')
                    WHERE id = ?
                ''', (status, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}")
            return False

    def get_website_configs(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç½‘ç«™é…ç½®åŠå…¶é¢‘é“ç»‘å®šï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œé¿å…N+1æŸ¥è¯¢ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ä½¿ç”¨LEFT JOINä¸€æ¬¡æ€§è·å–æ‰€æœ‰ç½‘ç«™å’Œå…¶é¢‘é“ç»‘å®š
                cursor.execute('''
                    SELECT
                        wc.id, wc.name, wc.display_name, wc.url_template,
                        wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at,
                        GROUP_CONCAT(wcb.channel_id) as channels
                    FROM website_configs wc
                    LEFT JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                    GROUP BY wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at
                    ORDER BY wc.created_at
                ''')

                configs = []
                for row in cursor.fetchall():
                    config = dict(row)
                    # å°†channelså­—ç¬¦ä¸²è§£æä¸ºæ•°ç»„
                    if config.get('channels'):
                        config['channels'] = config['channels'].split(',') if config['channels'] else []
                    else:
                        config['channels'] = []
                    configs.append(config)

                return configs
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return []

    def add_website_config(self, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str = 'blue', rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """æ·»åŠ ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO website_configs (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def update_website_config(self, config_id: int, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str, rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET name = ?, display_name = ?, url_template = ?, id_pattern = ?, badge_color = ?, rotation_interval = ?, rotation_enabled = ?, message_filters = ?
                    WHERE id = ?
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def delete_website_config(self, config_id: int) -> bool:
        """åˆ é™¤ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM website_configs WHERE id = ?', (config_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def get_website_channel_bindings(self, website_id: int, user_id: int = None) -> List[str]:
        """è·å–ç½‘ç«™ç»‘å®šçš„é¢‘é“åˆ—è¡¨ï¼ˆå¯é€‰æŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ? AND user_id = ?
                        ORDER BY created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ?
                        ORDER BY created_at
                    ''', (website_id,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return []

    def add_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO website_channel_bindings (website_id, channel_id, user_id)
                    VALUES (?, ?, ?)
                ''', (website_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šï¼ˆæŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ã€ä¿®å¤ã€‘å…¼å®¹å®Œæ•´URLå’Œé¢‘é“IDä¸¤ç§æ ¼å¼
                # å¦‚æœä¼ å…¥çš„æ˜¯é¢‘é“IDï¼Œä¹Ÿè¦åŒ¹é…æ•°æ®åº“ä¸­å¯èƒ½å­˜å‚¨çš„å®Œæ•´URL
                # æ„é€ ä¸¤ç§å¯èƒ½çš„åŒ¹é…æ¨¡å¼
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                    AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, channel_id, channel_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_channel_binding_admin(self, website_id: int, channel_id: str) -> bool:
        """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šï¼ˆç®¡ç†å‘˜æƒé™ï¼Œåˆ é™¤æ‰€æœ‰ç”¨æˆ·çš„ç»‘å®šï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ã€ä¿®å¤ã€‘å…¼å®¹å®Œæ•´URLå’Œé¢‘é“IDä¸¤ç§æ ¼å¼
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                ''', (website_id, channel_id, channel_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç®¡ç†å‘˜ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def get_website_config_by_channel(self, channel_id: str, user_id: int = None) -> Dict:
        """æ ¹æ®é¢‘é“IDè·å–ç»‘å®šçš„ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ? AND wcb.user_id = ?
                        LIMIT 1
                    ''', (str(channel_id), user_id))
                else:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ?
                        LIMIT 1
                    ''', (str(channel_id),))
                row = cursor.fetchone()
                if row:
                    return dict(row)
                return None
        except Exception as e:
            logger.error(f"æ ¹æ®é¢‘é“è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    def get_all_bound_channel_ids(self) -> set:
        """ã€æ–°å¢ã€‘é«˜æ•ˆè·å–æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDåˆ—è¡¨ï¼ˆç”¨äºBotç™½åå•ç¼“å­˜ï¼‰

        è¿”å›æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDé›†åˆï¼ŒåŒ…æ‹¬:
        1. website_channel_bindings è¡¨ä¸­çš„æ‰€æœ‰é¢‘é“
        2. ç³»ç»Ÿé…ç½®ä¸­çš„ CNFANS_CHANNEL_ID å’Œ ACBUY_CHANNEL_ID

        Returns:
            set: é¢‘é“IDå­—ç¬¦ä¸²é›†åˆï¼Œç”¨äºO(1)å¿«é€ŸæŸ¥æ‰¾
        """
        try:
            channel_ids = set()

            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 1. ä»ç»‘å®šè¡¨ä¸­è·å–æ‰€æœ‰é¢‘é“ID
                cursor.execute('SELECT DISTINCT channel_id FROM website_channel_bindings')
                rows = cursor.fetchall()
                for row in rows:
                    channel_id = row[0]
                    if channel_id:
                        # å…¼å®¹å®Œæ•´URLæ ¼å¼ï¼Œæå–é¢‘é“ID
                        if 'discord.com/channels/' in channel_id:
                            parts = channel_id.rstrip('/').split('/')
                            if len(parts) >= 1:
                                channel_id = parts[-1]
                        channel_ids.add(str(channel_id))

            # 2. æ·»åŠ ç³»ç»Ÿé…ç½®ä¸­çš„é¢‘é“IDï¼ˆå…¼å®¹æ—§é…ç½®ï¼‰
            try:
                from config import config
                if hasattr(config, 'CNFANS_CHANNEL_ID') and config.CNFANS_CHANNEL_ID:
                    channel_ids.add(str(config.CNFANS_CHANNEL_ID))
                if hasattr(config, 'ACBUY_CHANNEL_ID') and config.ACBUY_CHANNEL_ID:
                    channel_ids.add(str(config.ACBUY_CHANNEL_ID))
            except Exception as e:
                logger.debug(f"è¯»å–ç³»ç»Ÿé…ç½®é¢‘é“IDå¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}")

            logger.debug(f"è·å–åˆ° {len(channel_ids)} ä¸ªå·²ç»‘å®šçš„é¢‘é“ID")
            return channel_ids

        except Exception as e:
            logger.error(f"è·å–å·²ç»‘å®šé¢‘é“IDåˆ—è¡¨å¤±è´¥: {e}")
            return set()

    def generate_website_urls(self, weidian_id: str) -> List[Dict]:
        """æ ¹æ®å¾®åº—IDç”Ÿæˆæ‰€æœ‰ç½‘ç«™çš„URL"""
        try:
            website_configs = self.get_website_configs()
            urls = []

            for config in website_configs:
                try:
                    # æ›¿æ¢URLæ¨¡æ¿ä¸­çš„{id}å ä½ç¬¦
                    url = config['url_template'].replace('{id}', weidian_id)
                    urls.append({
                        'name': config['name'],
                        'display_name': config['display_name'],
                        'url': url,
                        'badge_color': config['badge_color'],
                        'channels': self.get_website_channel_bindings(config['id'])
                    })
                except Exception as e:
                    logger.warning(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥ {config['name']}: {e}")

            return urls
        except Exception as e:
            logger.error(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥: {e}")
            return []

    # ===== ç½‘ç«™è´¦å·ç»‘å®šæ–¹æ³• =====

    def add_website_account_binding(self, website_id: int, account_id: int, role: str, user_id: int) -> bool:
        """æ·»åŠ ç½‘ç«™è´¦å·ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO website_account_bindings
                    (website_id, account_id, role, user_id)
                    VALUES (?, ?, ?, ?)
                ''', (website_id, account_id, role, user_id))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_account_binding(self, website_id: int, account_id: int, user_id: int) -> bool:
        """ç§»é™¤ç½‘ç«™è´¦å·ç»‘å®šï¼ˆæŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM website_account_bindings
                    WHERE website_id = ? AND account_id = ? AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, account_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç§»é™¤ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return False

    def get_website_account_bindings(self, website_id: int, user_id: int = None) -> List[Dict]:
        """è·å–ç½‘ç«™çš„æ‰€æœ‰è´¦å·ç»‘å®šï¼ˆå¯é€‰æŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ? AND wab.user_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return []

    def get_account_website_bindings(self, account_id: int) -> List[Dict]:
        """è·å–è´¦å·çš„æ‰€æœ‰ç½‘ç«™ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT wab.id, wab.website_id, wab.role, wab.created_at,
                           wc.name, wc.display_name
                    FROM website_account_bindings wab
                    JOIN website_configs wc ON wab.website_id = wc.id
                    WHERE wab.account_id = ?
                    ORDER BY wab.created_at
                ''', (account_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–è´¦å·ç½‘ç«™ç»‘å®šå¤±è´¥: {e}")
            return []

    def get_website_senders(self, website_id: int) -> List[int]:
        """è·å–ç½‘ç«™çš„å‘é€è´¦å·IDåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('sender', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™å‘é€è´¦å·å¤±è´¥: {e}")
            return []

    def get_website_listeners(self, website_id: int) -> List[int]:
        """è·å–ç½‘ç«™çš„ç›‘å¬è´¦å·IDåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('listener', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™ç›‘å¬è´¦å·å¤±è´¥: {e}")
            return []

    def update_website_config_rotation(self, config_id: int, rotation_interval: int) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„è½®æ¢é—´éš”"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_interval = ?
                    WHERE id = ?
                ''', (rotation_interval, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™è½®æ¢é—´éš”å¤±è´¥: {e}")
            return False

    def update_website_config_rotation_enabled(self, config_id: int, rotation_enabled: int) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„è½®æ¢å¯ç”¨çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_enabled = ?
                    WHERE id = ?
                ''', (rotation_enabled, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®è½®æ¢å¯ç”¨çŠ¶æ€å¤±è´¥: {e}")
            return False

    def update_website_message_filters(self, config_id: int, message_filters: str) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„æ¶ˆæ¯è¿‡æ»¤æ¡ä»¶"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET message_filters = ?
                    WHERE id = ?
                ''', (message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤æ¡ä»¶å¤±è´¥: {e}")
            return False

    # ===== ç”¨æˆ·çº§åˆ«çš„ç½‘ç«™è®¾ç½®æ–¹æ³• =====

    def get_user_website_settings(self, user_id: int, website_id: int) -> Dict:
        """è·å–ç”¨æˆ·çš„ç½‘ç«™è®¾ç½®ï¼ˆè½®æ¢å’Œè¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT rotation_interval, rotation_enabled, message_filters
                    FROM user_website_settings
                    WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                row = cursor.fetchone()
                if row:
                    return {
                        'rotation_interval': row['rotation_interval'],
                        'rotation_enabled': row['rotation_enabled'],
                        'message_filters': row['message_filters']
                    }
                # è¿”å›é»˜è®¤å€¼
                return {
                    'rotation_interval': 180,
                    'rotation_enabled': 1,
                    'message_filters': '[]'
                }
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·ç½‘ç«™è®¾ç½®å¤±è´¥: {e}")
            return {'rotation_interval': 180, 'rotation_enabled': 1, 'message_filters': '[]'}

    def update_user_website_rotation(self, user_id: int, website_id: int, rotation_interval: int = None, rotation_enabled: int = None) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„ç½‘ç«™è½®æ¢è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # å…ˆæ£€æŸ¥æ˜¯å¦å­˜åœ¨è®°å½•
                cursor.execute('''
                    SELECT id FROM user_website_settings WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                exists = cursor.fetchone()

                if exists:
                    # æ›´æ–°ç°æœ‰è®°å½•
                    updates = []
                    params = []
                    if rotation_interval is not None:
                        updates.append('rotation_interval = ?')
                        params.append(rotation_interval)
                    if rotation_enabled is not None:
                        updates.append('rotation_enabled = ?')
                        params.append(rotation_enabled)
                    if updates:
                        updates.append('updated_at = CURRENT_TIMESTAMP')
                        params.extend([user_id, website_id])
                        cursor.execute(f'''
                            UPDATE user_website_settings
                            SET {', '.join(updates)}
                            WHERE user_id = ? AND website_id = ?
                        ''', params)
                else:
                    # æ’å…¥æ–°è®°å½•
                    cursor.execute('''
                        INSERT INTO user_website_settings (user_id, website_id, rotation_interval, rotation_enabled)
                        VALUES (?, ?, ?, ?)
                    ''', (user_id, website_id, rotation_interval or 180, rotation_enabled if rotation_enabled is not None else 1))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·ç½‘ç«™è½®æ¢è®¾ç½®å¤±è´¥: {e}")
            return False

    def update_user_website_filters(self, user_id: int, website_id: int, message_filters: str) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # ä½¿ç”¨ INSERT OR REPLACE
                cursor.execute('''
                    INSERT INTO user_website_settings (user_id, website_id, message_filters)
                    VALUES (?, ?, ?)
                    ON CONFLICT(user_id, website_id) DO UPDATE SET
                        message_filters = excluded.message_filters,
                        updated_at = CURRENT_TIMESTAMP
                ''', (user_id, website_id, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤å¤±è´¥: {e}")
            return False

    def get_system_stats(self) -> Dict:
        """è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–åº—é“ºæ•°é‡ï¼ˆä»shopsè¡¨ç»Ÿè®¡ï¼‰
                cursor.execute("SELECT COUNT(*) FROM shops")
                shop_count = cursor.fetchone()[0] or 0

                # è·å–å•†å“æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM products")
                product_count = cursor.fetchone()[0] or 0

                # è·å–å›¾ç‰‡æ•°é‡ï¼ˆåªç»Ÿè®¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡ï¼‰
                cursor.execute("""
                    SELECT COUNT(*) FROM product_images
                    WHERE product_id IN (SELECT id FROM products)
                """)
                image_count = cursor.fetchone()[0] or 0

                # è·å–ç”¨æˆ·æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
                user_count = cursor.fetchone()[0] or 0

                return {
                    'shop_count': shop_count,
                    'product_count': product_count,
                    'image_count': image_count,
                    'user_count': user_count
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {e}")
            return {'shop_count': 0, 'product_count': 0, 'image_count': 0, 'user_count': 0}

    def cleanup_orphaned_images(self) -> int:
        """æ¸…ç†å­¤ç«‹çš„å›¾ç‰‡è®°å½•ï¼ˆæ²¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # åˆ é™¤æ²¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡è®°å½•
                cursor.execute("""
                    DELETE FROM product_images
                    WHERE product_id NOT IN (SELECT id FROM products)
                """)
                deleted_count = cursor.rowcount
                conn.commit()
                if deleted_count > 0:
                    logger.info(f"æ¸…ç†äº† {deleted_count} æ¡å­¤ç«‹çš„å›¾ç‰‡è®°å½•")
                return deleted_count
        except Exception as e:
            logger.error(f"æ¸…ç†å­¤ç«‹å›¾ç‰‡è®°å½•å¤±è´¥: {e}")
            return 0

    def get_active_announcements(self) -> List[Dict]:
        """è·å–æ´»è·ƒçš„ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, title, content, created_at, updated_at
                    FROM system_announcements
                    WHERE is_active = 1
                    ORDER BY updated_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return []

    def create_announcement(self, title: str, content: str) -> bool:
        """åˆ›å»ºç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO system_announcements (title, content)
                    VALUES (?, ?)
                ''', (title, content))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"åˆ›å»ºç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def update_announcement(self, announcement_id: int, title: str, content: str, is_active: bool) -> bool:
        """æ›´æ–°ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE system_announcements
                    SET title = ?, content = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (title, content, is_active, announcement_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def delete_announcement(self, announcement_id: int) -> bool:
        """åˆ é™¤ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM system_announcements WHERE id = ?', (announcement_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def get_message_filters(self) -> List[Dict]:
        """è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, filter_type, filter_value, is_active, created_at
                    FROM message_filters
                    WHERE is_active = 1
                    ORDER BY created_at
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return []

    def add_message_filter(self, filter_type: str, filter_value: str) -> bool:
        """æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO message_filters (filter_type, filter_value)
                    VALUES (?, ?)
                ''', (filter_type, filter_value))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def update_message_filter(self, filter_id: int, filter_type: str, filter_value: str, is_active: bool) -> bool:
        """æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE message_filters
                    SET filter_type = ?, filter_value = ?, is_active = ?
                    WHERE id = ?
                ''', (filter_type, filter_value, is_active, filter_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def delete_message_filter(self, filter_id: int) -> bool:
        """åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM message_filters WHERE id = ?', (filter_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def get_custom_replies(self) -> List[Dict]:
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, reply_type, content, image_url, is_active, priority, created_at
                    FROM custom_replies
                    WHERE is_active = 1
                    ORDER BY priority DESC, created_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return []

    def add_custom_reply(self, reply_type: str, content: str = None, image_url: str = None, priority: int = 0) -> bool:
        """æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO custom_replies (reply_type, content, image_url, priority)
                    VALUES (?, ?, ?, ?)
                ''', (reply_type, content, image_url, priority))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def update_custom_reply(self, reply_id: int, reply_type: str, content: str = None, image_url: str = None, priority: int = 0, is_active: bool = True) -> bool:
        """æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE custom_replies
                    SET reply_type = ?, content = ?, image_url = ?, priority = ?, is_active = ?
                    WHERE id = ?
                ''', (reply_type, content, image_url, priority, is_active, reply_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def delete_custom_reply(self, reply_id: int) -> bool:
        """åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM custom_replies WHERE id = ?', (reply_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def get_products_by_user_shops(self, user_shops: List[str], limit: int = None, offset: int = 0) -> Dict:
        """æ ¹æ®ç”¨æˆ·åº—é“ºæƒé™è·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor = conn.cursor()

                if user_shops is None:
                    # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°æ‰€æœ‰å•†å“ï¼ˆä¸é™åˆ¶åº—é“ºï¼‰- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
                    if limit is None or limit <= 0:
                        # ä¸€æ¬¡æ€§è·å–æ‰€æœ‰å•†å“å’Œå¯¹åº”çš„å›¾ç‰‡ç´¢å¼•
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                        '''
                        cursor.execute(query)
                        rows = cursor.fetchall()

                        # è·å–æ€»æ•°
                        cursor.execute('SELECT COUNT(*) FROM products')
                        total = cursor.fetchone()[0]
                    else:
                        # åˆ†é¡µæŸ¥è¯¢ - ä½¿ç”¨å­æŸ¥è¯¢ä¼˜åŒ–æ€§èƒ½
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                            LIMIT ? OFFSET ?
                        '''
                        cursor.execute(query, [limit, offset])
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    cursor.execute('SELECT COUNT(*) FROM products')
                    total = cursor.fetchone()[0]

                    products = []
                    for row in rows:
                        prod = dict(row)
                        # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                        if prod.get('image_indices'):
                            image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                            prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                        else:
                            prod['images'] = []

                        # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                        prod['weidianUrl'] = prod.get('product_url')
                        prod['englishTitle'] = prod.get('english_title') or ''
                        prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                        prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                        prod['createdAt'] = prod.get('created_at')
                        prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                        prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'

                        # æå–å¾®åº—ID
                        try:
                            import re
                            m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                            prod['weidianId'] = m.group(1) if m else ''
                        except:
                            prod['weidianId'] = ''

                        products.append(prod)

                    return {'products': products, 'total': total}

                elif not user_shops:
                    # å¦‚æœç”¨æˆ·æ²¡æœ‰åº—é“ºæƒé™ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # ç¡®ä¿user_shopsæ˜¯listç±»å‹
                if not isinstance(user_shops, list):
                    user_shops = []

                # æ ¹æ®shop_idæ‰¾åˆ°å¯¹åº”çš„shop_name
                shop_names = []
                for shop_id in user_shops:
                    cursor.execute("SELECT name FROM shops WHERE shop_id = ?", (shop_id,))
                    shop_row = cursor.fetchone()
                    if shop_row:
                        shop_names.append(shop_row[0])

                if not shop_names:
                    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åº—é“ºåç§°ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # æ„å»ºINæŸ¥è¯¢ - ä¼˜åŒ–æ€§èƒ½
                placeholders = ','.join('?' * len(shop_names))
                if limit is None or limit <= 0:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                    '''
                    cursor.execute(query, shop_names)
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                    cursor.execute(count_query, shop_names)
                    total = cursor.fetchone()[0]
                else:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                        LIMIT ? OFFSET ?
                    '''
                    cursor.execute(query, shop_names + [limit, offset])
                rows = cursor.fetchall()

                # è·å–æ€»æ•°
                count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                cursor.execute(count_query, shop_names)
                total = cursor.fetchone()[0]

                products = []
                for row in rows:
                    prod = dict(row)
                    # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                    if prod.get('image_indices'):
                        image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                        prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                    else:
                        prod['images'] = []

                    # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                    prod['weidianUrl'] = prod.get('product_url')
                    prod['englishTitle'] = prod.get('english_title') or ''
                    prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                    prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                    prod['createdAt'] = prod.get('created_at')
                    prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                    prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'
                    prod['customReplyText'] = prod.get('custom_reply_text') or ''
                    # è§£æè‡ªå®šä¹‰å›å¤å›¾ç‰‡ç´¢å¼•
                    try:
                        custom_reply_images = prod.get('custom_reply_images')
                        if custom_reply_images:
                            prod['selectedImageIndexes'] = json.loads(custom_reply_images)
                        else:
                            prod['selectedImageIndexes'] = []
                    except:
                        prod['selectedImageIndexes'] = []

                    # ä¿®å¤ï¼šè§£ææœ¬åœ°ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡ (uploaded_reply_images)
                    # å‰ç«¯ç»„ä»¶ ScraperView éœ€è¦ uploadedImages å­—æ®µ (URLåˆ—è¡¨) æ¥æ˜¾ç¤º"å·²ä¿å­˜å›¾ç‰‡"
                    try:
                        if prod.get('uploaded_reply_images'):
                            import json
                            filenames = json.loads(prod['uploaded_reply_images'])
                            prod['uploadedImages'] = [f"/api/custom_reply_image/{prod['id']}/{fn}" for fn in filenames]
                        else:
                            prod['uploadedImages'] = []
                    except:
                        prod['uploadedImages'] = []

                    # æå–å¾®åº—ID
                    try:
                        import re
                        m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                        prod['weidianId'] = m.group(1) if m else ''
                    except:
                        prod['weidianId'] = ''

                    products.append(prod)

                return {'products': products, 'total': total}

        except Exception as e:
            print(f"DEBUG: Exception in get_products_by_user_shops: {type(e).__name__}: {e}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            logger.error("è·å–ç”¨æˆ·å•†å“å¤±è´¥: %s", str(e))
            return {'products': [], 'total': 0}

    def get_global_reply_config(self) -> Dict[str, float]:
        """è·å–å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT min_delay, max_delay FROM global_reply_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {'min_delay': row[0], 'max_delay': row[1]}
                return {'min_delay': 3.0, 'max_delay': 8.0}  # é»˜è®¤å€¼
        except Exception as e:
            logger.error(f"è·å–å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return {'min_delay': 3.0, 'max_delay': 8.0}

    def update_global_reply_config(self, min_delay: float, max_delay: float) -> bool:
        """æ›´æ–°å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE global_reply_config
                    SET min_delay = ?, max_delay = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''', (min_delay, max_delay))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return False

    def get_system_config(self) -> Dict[str, any]:
        """è·å–ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads FROM system_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_channel_id': row[0] or '',
                        'download_threads': row[1] or 4,
                        'feature_extract_threads': row[2] or 4,
                        'discord_similarity_threshold': row[3] or 0.6,
                        'cnfans_channel_id': row[4] or '',
                        'acbuy_channel_id': row[5] or '',
                        'scrape_threads': row[6] or 2
                    }
                # å¦‚æœæ²¡æœ‰é…ç½®è®°å½•ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads)
                    VALUES (1, '', 4, 4, 0.6, '', '', 2)
                ''')
                conn.commit()
                return {
                    'discord_channel_id': '',
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'cnfans_channel_id': '',
                    'acbuy_channel_id': '',
                    'scrape_threads': 2
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return {
                'discord_channel_id': '',
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'cnfans_channel_id': '',
                'acbuy_channel_id': '',
                'scrape_threads': 2
            }

    def get_user_settings(self, user_id: int) -> Dict[str, any]:
        """è·å–ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT download_threads, feature_extract_threads, discord_similarity_threshold,
                           global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                           keyword_reply_enabled, image_reply_enabled
                    FROM user_settings WHERE user_id = ?
                ''', (user_id,))
                row = cursor.fetchone()
                if row:
                    return {
                        'download_threads': row[0] or 4,
                        'feature_extract_threads': row[1] or 4,
                        'discord_similarity_threshold': row[2] or 0.6,
                        'global_reply_min_delay': row[3] or 3.0,
                        'global_reply_max_delay': row[4] or 8.0,
                        'user_blacklist': row[5] or '',
                        'keyword_filters': row[6] or '',
                        'keyword_reply_enabled': row[7] if row[7] is not None else 1,
                        'image_reply_enabled': row[8] if row[8] is not None else 1,
                    }
                # å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®ï¼Œè¿”å›é»˜è®¤å€¼
                return {
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'global_reply_min_delay': 3.0,
                    'global_reply_max_delay': 8.0,
                    'user_blacklist': '',
                    'keyword_filters': '',
                    'keyword_reply_enabled': 1,
                    'image_reply_enabled': 1,
                }
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return {
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'global_reply_min_delay': 3.0,
                'global_reply_max_delay': 8.0,
                'user_blacklist': '',
                'keyword_filters': '',
                'keyword_reply_enabled': 1,
                'image_reply_enabled': 1,
            }

    def update_user_settings(self, user_id: int, download_threads: int = None,
                           feature_extract_threads: int = None, discord_similarity_threshold: float = None,
                           global_reply_min_delay: float = None, global_reply_max_delay: float = None,
                           user_blacklist: str = None, keyword_filters: str = None,
                           keyword_reply_enabled: int = None, image_reply_enabled: int = None) -> bool:
        """æ›´æ–°ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰è®¾ç½®
                cursor.execute('SELECT id FROM user_settings WHERE user_id = ?', (user_id,))
                existing = cursor.fetchone()

                if existing:
                    # æ›´æ–°ç°æœ‰è®¾ç½®
                    update_fields = []
                    params = []

                    if download_threads is not None:
                        update_fields.append('download_threads = ?')
                        params.append(download_threads)

                    if feature_extract_threads is not None:
                        update_fields.append('feature_extract_threads = ?')
                        params.append(feature_extract_threads)

                    if discord_similarity_threshold is not None:
                        update_fields.append('discord_similarity_threshold = ?')
                        params.append(discord_similarity_threshold)

                    if global_reply_min_delay is not None:
                        update_fields.append('global_reply_min_delay = ?')
                        params.append(global_reply_min_delay)

                    if global_reply_max_delay is not None:
                        update_fields.append('global_reply_max_delay = ?')
                        params.append(global_reply_max_delay)

                    if user_blacklist is not None:
                        update_fields.append('user_blacklist = ?')
                        params.append(user_blacklist)

                    if keyword_filters is not None:
                        update_fields.append('keyword_filters = ?')
                        params.append(keyword_filters)

                    if keyword_reply_enabled is not None:
                        update_fields.append('keyword_reply_enabled = ?')
                        params.append(keyword_reply_enabled)

                    if image_reply_enabled is not None:
                        update_fields.append('image_reply_enabled = ?')
                        params.append(image_reply_enabled)

                    if update_fields:
                        update_fields.append('updated_at = CURRENT_TIMESTAMP')
                        sql = f'UPDATE user_settings SET {", ".join(update_fields)} WHERE user_id = ?'
                        params.append(user_id)
                        cursor.execute(sql, params)
                else:
                    # æ’å…¥æ–°è®¾ç½®
                    cursor.execute('''
                        INSERT INTO user_settings
                        (user_id, download_threads, feature_extract_threads, discord_similarity_threshold,
                         global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                         keyword_reply_enabled, image_reply_enabled)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        user_id,
                        download_threads or 4,
                        feature_extract_threads or 4,
                        discord_similarity_threshold or 0.6,
                        global_reply_min_delay or 3.0,
                        global_reply_max_delay or 8.0,
                        user_blacklist or '',
                        keyword_filters or '',
                        keyword_reply_enabled if keyword_reply_enabled is not None else 1,
                        image_reply_enabled if image_reply_enabled is not None else 1
                    ))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return False

    def update_system_config(self, discord_channel_id: str = None, discord_similarity_threshold: float = None,
                           cnfans_channel_id: str = None, acbuy_channel_id: str = None) -> bool:
        """æ›´æ–°ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # é¦–å…ˆç¡®ä¿é…ç½®è®°å½•å­˜åœ¨
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')

                # æ„å»ºæ›´æ–°è¯­å¥
                update_fields = []
                params = []

                if discord_channel_id is not None:
                    update_fields.append('discord_channel_id = ?')
                    params.append(discord_channel_id)

                if discord_similarity_threshold is not None:
                    update_fields.append('discord_similarity_threshold = ?')
                    params.append(discord_similarity_threshold)

                if cnfans_channel_id is not None:
                    update_fields.append('cnfans_channel_id = ?')
                    params.append(cnfans_channel_id)

                if acbuy_channel_id is not None:
                    update_fields.append('acbuy_channel_id = ?')
                    params.append(acbuy_channel_id)

                if update_fields:
                    update_fields.append('updated_at = CURRENT_TIMESTAMP')
                    sql = f'UPDATE system_config SET {", ".join(update_fields)} WHERE id = 1'
                    cursor.execute(sql, params)
                    conn.commit()
                    return True
                return False
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return False

    # ===== åº—é“ºç®¡ç†æ–¹æ³• =====

    def add_shop(self, shop_id: str, name: str) -> bool:
        """æ·»åŠ æ–°åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥åº—é“ºæ˜¯å¦å·²å­˜åœ¨
                cursor.execute('SELECT id FROM shops WHERE shop_id = ?', (shop_id,))
                if cursor.fetchone():
                    logger.warning(f"åº—é“º {shop_id} å·²å­˜åœ¨")
                    return False

                cursor.execute('''
                    INSERT INTO shops (shop_id, name, product_count)
                    VALUES (?, ?, 0)
                ''', (shop_id, name))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ åº—é“ºå¤±è´¥: {e}")
            return False

    def get_all_shops(self) -> List[Dict]:
        """è·å–æ‰€æœ‰åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops ORDER BY created_at DESC')
                rows = cursor.fetchall()

                shops = []
                for row in rows:
                    shops.append({
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    })
                return shops
        except Exception as e:
            logger.error(f"è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_shop_by_id(self, shop_id: str) -> Optional[Dict]:
        """æ ¹æ®shop_idè·å–åº—é“ºä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops WHERE shop_id = ?', (shop_id,))
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    }
                return None
        except Exception as e:
            logger.error(f"è·å–åº—é“ºä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_shop_product_count(self, shop_id: str, product_count: int) -> bool:
        """æ›´æ–°åº—é“ºçš„å•†å“æ•°é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE shops
                    SET product_count = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE shop_id = ?
                ''', (product_count, shop_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°åº—é“ºå•†å“æ•°é‡å¤±è´¥: {e}")
            return False

    def delete_shop(self, shop_id: str) -> bool:
        """åˆ é™¤åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM shops WHERE shop_id = ?', (shop_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤åº—é“ºå¤±è´¥: {e}")
            return False

    # ========== æŠ“å–çŠ¶æ€ç®¡ç†æ–¹æ³• ==========

    def get_scrape_status(self) -> Dict:
        """è·å–æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM scrape_status WHERE id = 1')
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'is_scraping': bool(row[1]),
                        'stop_signal': bool(row[2]),
                        'current_shop_id': row[3],
                        'total': row[4] or 0,
                        'processed': row[5] or 0,
                        'success': row[6] or 0,
                        'progress': row[7] or 0.0,
                        'message': row[8] or 'ç­‰å¾…å¼€å§‹...',
                        'completed': bool(row[9]),
                        'thread_id': row[10],
                        'updated_at': row[11]
                    }
                else:
                    # å¦‚æœæ²¡æœ‰è®°å½•ï¼Œåˆ›å»ºé»˜è®¤è®°å½•
                    return self.reset_scrape_status()

        except Exception as e:
            logger.error(f"è·å–æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'è·å–çŠ¶æ€å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

    def update_scrape_status(self, **kwargs) -> bool:
        """æ›´æ–°æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºæ›´æ–°è¯­å¥
                fields = []
                values = []
                for key, value in kwargs.items():
                    if key in ['is_scraping', 'stop_signal', 'completed']:
                        fields.append(f'{key} = ?')
                        values.append(1 if value else 0)
                    elif key in ['total', 'processed', 'success']:
                        fields.append(f'{key} = ?')
                        values.append(int(value) if value is not None else 0)
                    elif key == 'progress':
                        fields.append(f'{key} = ?')
                        values.append(float(value) if value is not None else 0.0)
                    elif key in ['current_shop_id', 'message', 'thread_id']:
                        fields.append(f'{key} = ?')
                        values.append(str(value) if value is not None else None)

                if fields:
                    fields.append('updated_at = CURRENT_TIMESTAMP')
                    query = f'UPDATE scrape_status SET {", ".join(fields)} WHERE id = 1'
                    cursor.execute(query, values)
                    conn.commit()
                    return cursor.rowcount > 0

                return False

        except Exception as e:
            logger.error(f"æ›´æ–°æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return False

    def reset_scrape_status(self) -> Dict:
        """é‡ç½®æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scrape_status SET
                        is_scraping = 0,
                        stop_signal = 0,
                        current_shop_id = NULL,
                        total = 0,
                        processed = 0,
                        success = 0,
                        progress = 0,
                        message = 'ç­‰å¾…å¼€å§‹...',
                        completed = 0,
                        thread_id = NULL,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''')
                conn.commit()

                return {
                    'is_scraping': False,
                    'stop_signal': False,
                    'current_shop_id': None,
                    'total': 0,
                    'processed': 0,
                    'success': 0,
                    'progress': 0.0,
                    'message': 'ç­‰å¾…å¼€å§‹...',
                    'completed': False,
                    'thread_id': None,
                    'updated_at': None
                }

        except Exception as e:
            logger.error(f"é‡ç½®æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'é‡ç½®å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

# å…¨å±€æ•°æ®åº“å®ä¾‹
db = Database()


# ===== è´¦å·ç®¡ç†æ–¹æ³•æ‰©å±• =====

def get_all_accounts() -> List[Dict]:
    """è·å–æ‰€æœ‰Discordè´¦å·"""
    return db.get_discord_accounts_by_user(None)


def add_account(token: str, username: str = '') -> int:
    """æ·»åŠ æ–°çš„Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO discord_accounts (token, username, status)
                VALUES (?, ?, 'offline')
            ''', (token, username or f'è´¦å·_{token[:8]}'))
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        logger.error(f"æ·»åŠ Discordè´¦å·å¤±è´¥: {e}")
        raise e


def get_account_by_id(account_id: int) -> Optional[Dict]:
    """æ ¹æ®IDè·å–Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, username, token, status, last_active, created_at FROM discord_accounts WHERE id = ?',
                (account_id,)
            )
            row = cursor.fetchone()
            return dict(row) if row else None
    except Exception as e:
        logger.error(f"è·å–è´¦å·å¤±è´¥: {e}")
        return None


def delete_account(account_id: int) -> bool:
    """åˆ é™¤Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM discord_accounts WHERE id = ?', (account_id,))
            conn.commit()
            return cursor.rowcount > 0
    except Exception as e:
        logger.error(f"åˆ é™¤è´¦å·å¤±è´¥: {e}")
        return False


def get_products_by_shop(shop_name: str) -> List[Dict]:
    """æ ¹æ®åº—é“ºåè·å–å•†å“åˆ—è¡¨"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, product_url, title, cnfans_url, acbuy_url, shop_name FROM products WHERE shop_name = ?',
                (shop_name,)
            )
            return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        logger.error(f"è·å–å•†å“åˆ—è¡¨å¤±è´¥: {e}")
        return []


# ä¸º Database ç±»æ·»åŠ æ–¹æ³•åˆ«å
Database.get_all_accounts = lambda self: self.get_discord_accounts_by_user(None)
Database.add_account = lambda self, token, username='': add_account(token, username)
Database.get_account_by_id = lambda self, account_id: get_account_by_id(account_id)
Database.delete_account = lambda self, account_id: delete_account(account_id)
Database.get_products_by_shop = lambda self, shop_name: get_products_by_shop(shop_name)

===== backend/license_manager.py =====
import datetime as dt
import hashlib
import json
import os
import platform
import uuid
from typing import Any, Dict, Optional, Tuple

import requests

from config import config

LICENSE_FILE = os.path.join(os.path.dirname(__file__), 'data', 'license.json')


def generate_hwid() -> str:
    """ç”Ÿæˆç¨³å®šçš„ç¡¬ä»¶æ ‡è¯†ï¼Œç”¨äºè®¸å¯è¯ç»‘å®šã€‚"""
    try:
        mac = ':'.join(
            ['{:02x}'.format((uuid.getnode() >> i) & 0xff) for i in range(0, 48, 8)]
        )[0:17]
        system_info = f"{platform.machine()}-{platform.system()}-{platform.node()}-{mac}"
        return hashlib.sha256(system_info.encode()).hexdigest()[:32].upper()
    except Exception:
        return uuid.uuid4().hex[:32].upper()


def _ensure_data_dir() -> None:
    os.makedirs(os.path.dirname(LICENSE_FILE), exist_ok=True)


def load_license() -> Optional[Dict[str, Any]]:
    try:
        with open(LICENSE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return None
    except Exception:
        return None


def save_license(data: Dict[str, Any]) -> bool:
    try:
        _ensure_data_dir()
        with open(LICENSE_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=True, indent=2)
        return True
    except Exception:
        return False


def mask_license_key(key: Optional[str]) -> str:
    if not key:
        return ''
    if len(key) <= 8:
        return f"{key[:2]}{'*' * max(len(key) - 4, 0)}{key[-2:]}"
    return f"{key[:4]}{'*' * 4}{key[-4:]}"


def _parse_datetime(value: Optional[str]) -> Optional[dt.datetime]:
    if not value:
        return None
    try:
        return dt.datetime.fromisoformat(value)
    except ValueError:
        return None


def validate_local_license() -> Tuple[bool, Dict[str, Any]]:
    data = load_license()
    if not data:
        return False, {'reason': 'missing', 'message': 'æœªæ‰¾åˆ°è®¸å¯è¯ï¼Œè¯·å…ˆæ¿€æ´»'}

    saved_hwid = data.get('hwid')
    current_hwid = generate_hwid()
    if saved_hwid != current_hwid:
        return False, {'reason': 'hwid_mismatch', 'message': 'è®¸å¯è¯ä¸å½“å‰è®¾å¤‡ä¸åŒ¹é…'}

    days = data.get('days')
    activated_at = _parse_datetime(data.get('activated_at'))
    if days is None or activated_at is None:
        return False, {'reason': 'invalid', 'message': 'è®¸å¯è¯ä¿¡æ¯ä¸å®Œæ•´'}

    if int(days) != -1:
        expires_at = activated_at + dt.timedelta(days=int(days))
        if dt.datetime.utcnow() > expires_at:
            return False, {'reason': 'expired', 'message': 'è®¸å¯è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°æ¿€æ´»'}
        expires_at_str = expires_at.isoformat()
    else:
        expires_at_str = None

    return True, {
        'license_key': mask_license_key(data.get('license_key')),
        'days': int(days),
        'activated_at': activated_at.isoformat(),
        'expires_at': expires_at_str
    }


def activate_license(license_key: str) -> Tuple[bool, Dict[str, Any]]:
    normalized_key = license_key.strip().upper()
    if config.LICENSE_ALLOW_TEST_KEYS:
        allowed = {key.upper() for key in config.LICENSE_TEST_KEYS}
        if normalized_key in allowed:
            license_data = {
                'license_key': license_key,
                'hwid': generate_hwid(),
                'days': -1,
                'activated_at': dt.datetime.utcnow().isoformat()
            }
            if not save_license(license_data):
                return False, {'message': 'ä¿å­˜è®¸å¯è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç£ç›˜æƒé™'}
            return True, {'message': 'æœ¬åœ°æµ‹è¯•å¯†é’¥æ¿€æ´»æˆåŠŸ', 'days': -1}

    hwid = generate_hwid()
    try:
        response = requests.post(
            f"{config.LICENSE_SERVER_URL}/api/activate",
            json={'key': license_key, 'hwid': hwid},
            timeout=10
        )
    except requests.exceptions.Timeout:
        return False, {'message': 'è¿æ¥æœåŠ¡å™¨è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ'}
    except requests.exceptions.ConnectionError:
        return False, {'message': 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ'}
    except Exception as exc:
        return False, {'message': f'æ¿€æ´»å¤±è´¥: {exc}'}

    if response.status_code == 200:
        try:
            data = response.json()
        except ValueError:
            return False, {'message': 'æœåŠ¡å™¨è¿”å›æ— æ•ˆæ•°æ®'}

        if data.get('status') == 'success':
            days = data.get('days', -1)
            license_data = {
                'license_key': license_key,
                'hwid': hwid,
                'days': int(days),
                'activated_at': dt.datetime.utcnow().isoformat()
            }
            if not save_license(license_data):
                return False, {'message': 'ä¿å­˜è®¸å¯è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç£ç›˜æƒé™'}
            return True, {
                'message': data.get('msg', 'æ¿€æ´»æˆåŠŸ'),
                'days': int(days)
            }

        return False, {'message': data.get('detail', 'æ¿€æ´»å¤±è´¥')}

    if response.status_code == 403:
        return False, {'message': 'è¯¥å¯†é’¥å·²è¢«å…¶ä»–è®¾å¤‡æ¿€æ´»ï¼Œæ— æ³•é‡å¤ä½¿ç”¨'}
    if response.status_code == 404:
        return False, {'message': 'å¯†é’¥ä¸å­˜åœ¨æˆ–å·²å¤±æ•ˆ'}

    return False, {'message': f'æœåŠ¡å™¨é”™è¯¯: {response.status_code}'}

===== backend/weidian_scraper.py =====
import requests
import re
import json
import time
import logging
from urllib.parse import urlparse, parse_qs, quote
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class WeidianScraper:
    """å¾®åº—å•†å“ä¿¡æ¯çˆ¬è™« - ä½¿ç”¨å®˜æ–¹API"""

    def __init__(self):
        self.session = requests.Session()

        # [æ–°å¢] ä¼˜åŒ–è¿æ¥æ± ï¼Œé˜²æ­¢å¤šçº¿ç¨‹æŠ“å–æ—¶è¿æ¥æ•°ä¸å¤Ÿ
        from requests.adapters import HTTPAdapter
        # è®¾ç½®è¿æ¥æ± å¤§å°ä¸º 50ï¼Œé‡è¯•æ¬¡æ•° 3
        adapter = HTTPAdapter(pool_connections=50, pool_maxsize=50, max_retries=3)
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)

        # ä¿®å¤ï¼šæ›´æ–° Headersï¼Œå®Œå…¨åŒ¹é…ä½ çš„ CURL è¯·æ±‚
        self.session.headers.update({
            'accept': 'application/json, */*',  # æ³¨æ„ï¼šcurlä¸­æ˜¯ application/json, / ä½†å®é™…åº”è¯¥æ˜¯ /*
            'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'origin': 'https://weidian.com',
            'priority': 'u=1, i',
            'referer': 'https://weidian.com/',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-site',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
        })

        # ä¿®å¤ï¼šæ›´æ–° Cookies
        self.session.cookies.update({
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '6',
            '__spider__sessionid': 'e0e858ac8efb20a2'
        })

    def extract_item_id(self, url: str) -> Optional[str]:
        """ä»å¾®åº—URLä¸­æå–å•†å“ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # å°è¯•ä»è·¯å¾„ä¸­æå–
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # å°è¯•å…¶ä»–æ ¼å¼
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"æå–å•†å“IDå¤±è´¥: {e}")
            return None

    def scrape_product_info(self, url: str) -> Optional[Dict]:
        """
        æŠ“å–å¾®åº—å•†å“ä¿¡æ¯ - ä½¿ç”¨å®˜æ–¹API
        è¿”å›åŒ…å«æ ‡é¢˜ã€æè¿°ã€å›¾ç‰‡ç­‰ä¿¡æ¯çš„å­—å…¸
        """
        try:
            item_id = self.extract_item_id(url)
            if not item_id:
                logger.error(f"æ— æ³•ä»URLæå–å•†å“ID: {url}")
                return None

            logger.info(f"å¼€å§‹æŠ“å–å•†å“: {item_id}")

            # è·å–åº—é“ºä¿¡æ¯
            shop_name = self._get_shop_name(url)
            if shop_name == "æœªçŸ¥åº—é“º":
                logger.info("åº—é“ºåç§°è·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°
                        shop_name_pattern = r'"shopName"[^:]*:[^"]*"([^"]+)"'
                        match = re.search(shop_name_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            shop_name = match.group(1).strip()
                            logger.info(f"âœ… ä»JavaScriptæ•°æ®è·å–åˆ°åº—é“ºåç§°: {shop_name}")
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢æå–åº—é“ºåç§°å¤±è´¥: {e}")

            # ä½¿ç”¨å®˜æ–¹APIè·å–å•†å“ä¿¡æ¯
            product_info = self._scrape_by_api(item_id, url, shop_name)
            if product_info:
                logger.info(f"âœ… å•†å“ä¿¡æ¯æŠ“å–æˆåŠŸ: {product_info.get('title', 'Unknown')}")
                return product_info

            # å¦‚æœAPIå¤±è´¥ï¼Œè¿”å›None
            logger.error("APIæŠ“å–å¤±è´¥ï¼Œæ²¡æœ‰å¤‡ç”¨æ–¹æ³•")
            return None

        except Exception as e:
            logger.error(f"å•†å“ä¿¡æ¯æŠ“å–å¤±è´¥: {e}")
            return None

    def _scrape_by_api(self, item_id: str, url: str, shop_name: str = '') -> Optional[Dict]:
        """ä½¿ç”¨å¾®åº—å®˜æ–¹APIæŠ“å–å•†å“ä¿¡æ¯"""
        try:
            # è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯
            title_info = self._get_item_title_and_sku(item_id)
            title = title_info.get('title', '') if title_info else ''

            # å¦‚æœAPIè·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
            if not title:
                logger.info("APIè·å–æ ‡é¢˜å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
                        title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                        match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            title = match.group(1).strip()
                            logger.info(f"âœ… ä»é¡µé¢HTMLè·å–åˆ°å•†å“æ ‡é¢˜: {title}")
                        else:
                            title = f'å¾®åº—å•†å“ {item_id}'
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢HTMLæå–æ ‡é¢˜å¤±è´¥: {e}")
                    title = f'å¾®åº—å•†å“ {item_id}'
            else:
                title = title

            # è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ï¼ˆå³ä½¿æ ‡é¢˜è·å–å¤±è´¥ä¹Ÿè¦å°è¯•è·å–å›¾ç‰‡ï¼‰
            image_info = self._get_item_images(item_id)
            images = image_info if image_info else []

            # å¦‚æœæ—¢æ²¡æœ‰æ ‡é¢˜ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œè¿”å›None
            if not title and not images:
                logger.error("æ— æ³•è·å–å•†å“æ ‡é¢˜å’Œå›¾ç‰‡ä¿¡æ¯")
                return None

            # æ„å»ºå•†å“ä¿¡æ¯
            product_info = {
                'id': item_id,
                'weidian_url': url,
                'cnfans_url': f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN",
                'acbuy_url': f"https://www.acbuy.com/product?url=https%253A%252F%252Fweidian.com%252Fitem.html%253FitemID%253D{item_id}%2526spider_token%253D43fe&id={item_id}&source=WD",
                'images': images,
                'title': title,
                'english_title': self._generate_english_title(title),
                'description': f"å¾®åº—å•†å“ID: {item_id}",
                'shop_name': shop_name
            }

            return product_info

        except Exception as e:
            logger.error(f"APIæŠ“å–å¤±è´¥: {e}")
            return None

    def _get_item_title_and_sku(self, item_id: str) -> Optional[Dict]:
        """è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯"""
        try:
            # æ„é€ API URL - ä½¿ç”¨æ›´æ–°çš„æ ¼å¼
            param = json.dumps({"itemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getItemSkuInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.info(f"è°ƒç”¨SKU API: {api_url}")  # ä¿®æ”¹æ—¥å¿—çº§åˆ«ä¸º INFO ä»¥ä¾¿è°ƒè¯•

            # ä½¿ç”¨ä¸å‰ç«¯ fetch å®Œå…¨ä¸€è‡´çš„ headers
            headers = {
                "accept": "application/json, */*",
                "accept-language": "en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"macOS"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "referrer": "https://weidian.com/",
                "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
            }

            # ä¸å¸¦ cookies å‘é€è¯·æ±‚ (æœ‰æ—¶å€™ cookies ä¼šå¯¼è‡´æ ¡éªŒå¤±è´¥)
            response = requests.get(api_url, headers=headers, timeout=15)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"æ ‡é¢˜APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                title = result.get('itemTitle', '')
                if title:
                    return {'title': title, 'sku_info': result}

            # APIè°ƒç”¨å¤±è´¥ï¼Œè®°å½•è­¦å‘Šä½†ä¸å°è¯•HTML fallback

            return None

        except Exception as e:
            logger.error(f"è·å–å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return None

    def _get_item_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ - åŒæ—¶è°ƒç”¨ä¸¤ä¸ªAPIå¹¶å»é‡"""
        try:
            all_images = []

            # 1. è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)
            detail_images = self._get_detail_images(item_id)
            all_images.extend(detail_images)

            # 2. è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API)
            sku_images = self._get_sku_images(item_id)
            all_images.extend(sku_images)

            # 3. ç®€å•URLå»é‡
            unique_images = []
            seen_urls = set()
            for img_url in all_images:
                if img_url and img_url not in seen_urls:
                    unique_images.append(img_url)
                    seen_urls.add(img_url)

            logger.info(f"âœ… å•†å“ {item_id} å›¾ç‰‡è·å–å®Œæˆ: å…± {len(unique_images)} å¼  (è¯¦æƒ…:{len(detail_images)}, SKU:{len(sku_images)})")
            if len(unique_images) > 0:
                logger.info(f"ğŸ“¸ å›¾ç‰‡URLæ ·ä¾‹: {unique_images[:3]}")
            return unique_images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_detail_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)"""
        try:
            # æ„é€ API URL
            param = json.dumps({"vItemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getDetailDesc/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.debug(f"è°ƒç”¨è¯¦æƒ…å›¾ç‰‡API: {api_url}")

            # ä½¿ç”¨æ›´ç¨³å®šçš„è¯·æ±‚å¤´ï¼Œæ¨¡æ‹Ÿæµè§ˆå™¨è¡Œä¸º
            import requests
            headers = {
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'origin': 'https://weidian.com',
                'priority': 'u=1, i',
                'referer': 'https://weidian.com/',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-site',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            # è®¾ç½®cookies
            cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }

            response = requests.get(api_url, timeout=15, proxies={'http': None, 'https': None}, headers=headers, cookies=cookies)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"è¯¦æƒ…å›¾ç‰‡APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            images = []
            if data.get('status', {}).get('code') == 0:
                item_detail = data.get('result', {}).get('item_detail', {})
                desc_content = item_detail.get('desc_content', [])

                for item in desc_content:
                    if item.get('type') == 2 and item.get('url'):
                        images.append(item['url'])

            return images

        except Exception as e:
            logger.error(f"è·å–è¯¦æƒ…å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_sku_images(self, item_id: str) -> List[str]:
        """è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API + attrListè§£æ)"""
        try:
            logger.info(f"å¼€å§‹è·å–SKUå›¾ç‰‡ï¼Œå•†å“ID: {item_id}")
            title_info = self._get_item_title_and_sku(item_id)
            if not title_info or 'sku_info' not in title_info:
                logger.warning(f"æ— æ³•è·å–SKUä¿¡æ¯ï¼Œè·³è¿‡å›¾ç‰‡æå–: {item_id}")
                return []

            result = title_info['sku_info']
            images = []
            seen_urls = set()

            # 1. å°è¯•ä» attrList ä¸­æå– (è¿™æ˜¯ä½ æä¾›çš„JSONä¸­çš„ç»“æ„)
            attr_list = result.get('attrList', [])
            if attr_list:
                logger.info(f"è§£æ attrListï¼Œå…± {len(attr_list)} ç»„å±æ€§")
                for attr in attr_list:
                    attr_values = attr.get('attrValues', [])
                    for val in attr_values:
                        img_url = val.get('img')
                        if img_url:
                            # ä¿®å¤ URL æ ¼å¼
                            if img_url.startswith('//'):
                                img_url = 'https:' + img_url

                            if img_url not in seen_urls:
                                images.append(img_url)
                                seen_urls.add(img_url)

            # 2. å°è¯•ä» skuInfos ä¸­æå– (ä½œä¸ºè¡¥å……)
            sku_infos = result.get('skuInfos', [])
            if sku_infos:
                logger.info(f"è§£æ skuInfosï¼Œå…± {len(sku_infos)} ä¸ªSKU")
                for sku in sku_infos:
                    # æ³¨æ„ï¼šskuInfo å¯¹è±¡å¯èƒ½åµŒå¥—
                    info = sku.get('skuInfo', {})
                    img_url = info.get('img')
                    if img_url:
                        if img_url.startswith('//'):
                            img_url = 'https:' + img_url
                        if img_url not in seen_urls:
                            images.append(img_url)
                            seen_urls.add(img_url)

            logger.info(f"ä»SKUå±æ€§ä¸­æˆåŠŸæå– {len(images)} å¼ å›¾ç‰‡")
            return images
        except Exception as e:
            logger.error(f"è·å–SKUå›¾ç‰‡å¤±è´¥: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return []


    def _generate_english_title(self, chinese_title: str) -> str:
        """æ ¹æ®ä¸­æ–‡æ ‡é¢˜ç”Ÿæˆè‹±æ–‡æ ‡é¢˜ - ä½¿ç”¨å…è´¹ç¿»è¯‘API"""
        if not chinese_title or len(chinese_title.strip()) == 0:
            return ""
        # ä¼˜å…ˆä½¿ç”¨ Google å…è´¹æ¥å£ï¼Œå¤±è´¥å†å›é€€åˆ°ç™¾åº¦ï¼Œå†å›é€€åˆ°ç®€å•æ˜ å°„
        try:
            return self._translate_with_google(chinese_title)
        except Exception as e:
            logger.debug(f"Google ç¿»è¯‘å¤±è´¥: {e}")
        try:
            res = self._translate_with_baidu(chinese_title)
            if res:
                return res
        except Exception as e:
            logger.debug(f"ç™¾åº¦ç¿»è¯‘å¤±è´¥: {e}")
        # æœ€åå¤‡ç”¨ï¼šç®€å•æ˜ å°„
        return self._simple_chinese_to_english(chinese_title)

    def _translate_with_baidu(self, text: str) -> str:
        """ä½¿ç”¨ç™¾åº¦ç¿»è¯‘API"""
        try:
            # ç™¾åº¦ç¿»è¯‘å…è´¹API
            url = "https://fanyi.baidu.com/transapi"

            params = {
                'from': 'zh',
                'to': 'en',
                'query': text[:200]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            data = response.json()
            # å°è¯•å¤šç§å¯èƒ½çš„è¿”å›ç»“æ„ï¼Œé¿å…ç›´æ¥æŠ›å‡ºå¼‚å¸¸
            translated = ""
            if isinstance(data, dict):
                try:
                    translated = data.get('data', {}).get('result', [{}])[0].get('dst', '') or ''
                except Exception:
                    translated = ''
                if not translated:
                    if 'trans_result' in data:
                        try:
                            translated = data.get('trans_result', [{}])[0].get('dst', '') or ''
                        except Exception:
                            translated = ''
            if translated:
                return translated.strip()
            logger.debug("ç™¾åº¦ç¿»è¯‘è¿”å›ç©ºç»“æœ")
            return ""
        except Exception as e:
            logger.warning(f"ç™¾åº¦ç¿»è¯‘APIè°ƒç”¨å¼‚å¸¸: {e}")
            return ""

    def _translate_with_google(self, text: str) -> str:
        """ä½¿ç”¨Google Translate APIçš„å…è´¹ç‰ˆæœ¬"""
        try:
            # ä½¿ç”¨Google Translateçš„å…è´¹API
            url = "https://translate.googleapis.com/translate_a/single"

            params = {
                'client': 'gtx',
                'sl': 'zh-CN',
                'tl': 'en',
                'dt': 't',
                'q': text[:500]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # Googleè¿”å›çš„æ˜¯JSONæ•°ç»„
            data = response.json()
            if data and len(data) > 0 and len(data[0]) > 0:
                translated = data[0][0][0]
                if translated:
                    return translated.strip()

            raise Exception("Googleç¿»è¯‘è¿”å›ç©ºç»“æœ")

        except Exception as e:
            logger.error(f"Googleç¿»è¯‘APIè°ƒç”¨å¤±è´¥: {e}")
            raise e

    def _simple_chinese_to_english(self, text: str) -> str:
        """ç®€å•çš„ä¸­è‹±æ˜ å°„ - æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ"""
        # ç®€å•çš„å•†å“å…³é”®è¯æ˜ å°„
        mappings = {
            'é‹': 'shoes',
            'è¿åŠ¨é‹': 'sports shoes',
            'è¢œå­': 'socks',
            'é‹å­': 'shoes',
            'è¡£æœ': 'clothes',
            'ä¸Šè¡£': 'top',
            'è£¤å­': 'pants',
            'åŒ…': 'bag',
            'åŒ…åŒ…': 'bag',
            'æ‰‹æœº': 'phone',
            'ç”µè„‘': 'computer',
            'è€³æœº': 'headphones',
            'æ‰‹è¡¨': 'watch',
            'çœ¼é•œ': 'glasses',
            'å¸½å­': 'hat',
            'ä¹¦': 'book',
            'ç©å…·': 'toy',
            'æ¸¸æˆ': 'game'
        }

        result = text
        for cn, en in mappings.items():
            result = result.replace(cn, en)

        # å¦‚æœæœ‰æ˜æ˜¾çš„å˜åŒ–ï¼Œè¿”å›ç¿»è¯‘ç»“æœï¼Œå¦åˆ™è¿”å›ç©º
        if result != text:
            return result.strip()
        else:
            return ""


    def download_images(self, image_urls: List[str], save_dir: str, item_id: str) -> List[str]:
        """å¤šçº¿ç¨‹ä¸‹è½½å•†å“å›¾ç‰‡åˆ°æœ¬åœ°"""
        import os
        import concurrent.futures
        import threading

        saved_paths = []
        os.makedirs(save_dir, exist_ok=True)

        # ç§»é™¤å›¾ç‰‡æ•°é‡é™åˆ¶ï¼ŒæŠ“å–æ‰€æœ‰å¯ç”¨çš„å›¾ç‰‡
        # SKUå›¾ç‰‡é€šå¸¸æ’åœ¨è¯¦æƒ…å›¾ä¹‹åï¼Œç°åœ¨å¯ä»¥è·å–æ‰€æœ‰å›¾ç‰‡
        logger.info(f"å‡†å¤‡ä¸‹è½½ {len(image_urls)} å¼ å›¾ç‰‡ï¼ˆæ— æ•°é‡é™åˆ¶ï¼‰")

        def download_single_image(args):
            """ä¸‹è½½å•å¼ å›¾ç‰‡çš„å‡½æ•°"""
            i, img_url = args
            try:
                # ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºç‹¬ç«‹çš„session
                thread_session = requests.Session()
                thread_session.headers.update(self.session.headers)
                thread_session.cookies.update(self.session.cookies)

                response = thread_session.get(img_url, timeout=10, proxies={'http': None, 'https': None})
                response.raise_for_status()

                # ä¿å­˜å›¾ç‰‡
                img_path = os.path.join(save_dir, f"{item_id}_{i}.jpg")
                with open(img_path, 'wb') as f:
                    f.write(response.content)

                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸ: {img_path}")
                return img_path

            except Exception as e:
                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ {img_url}: {e}")
                return None

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘ä¸‹è½½å›¾ç‰‡
        try:
            from config import config
        except ImportError:
            from .config import config
        max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))  # ä½¿ç”¨é…ç½®çš„ä¸‹è½½çº¿ç¨‹æ•°

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æäº¤æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
            future_to_image = {
                executor.submit(download_single_image, (i, img_url)): (i, img_url)
                for i, img_url in enumerate(image_urls)
            }

            # æ”¶é›†ç»“æœ
            for future in concurrent.futures.as_completed(future_to_image):
                result = future.result()
                if result:
                    saved_paths.append(result)

        # æŒ‰ç´¢å¼•æ’åºç»“æœ
        saved_paths.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

        return saved_paths

    def _get_shop_name(self, url: str) -> str:
        """ä»å•†å“é¡µé¢è·å–åº—é“ºåç§°"""
        try:
            logger.debug(f"å¼€å§‹è·å–åº—é“ºåç§°: {url}")

            # ä½¿ç”¨ä¸“é—¨çš„HTMLè¯·æ±‚headersï¼ˆä¸åŒäºAPIè¯·æ±‚çš„headersï¼‰
            html_headers = {
                'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'cache-control': 'max-age=0',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'document',
                'sec-fetch-mode': 'navigate',
                'sec-fetch-site': 'none',
                'sec-fetch-user': '?1',
                'upgrade-insecure-requests': '1',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            html_cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                '__spider__sessionid': '4cb270eb969f316c'
            }

            # è¯·æ±‚å•†å“é¡µé¢ï¼ˆä½¿ç”¨HTMLä¸“ç”¨headersï¼‰
            response = requests.get(url, headers=html_headers, cookies=html_cookies, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # è§£ç HTMLå®ä½“ï¼ˆ&#34; -> " ç­‰ï¼‰
            html_content = response.text
            html_content = html_content.replace('&#34;', '"').replace('&#39;', "'").replace('&quot;', '"')

            # é¦–å…ˆå°è¯•æœ€ç²¾ç¡®çš„åŒ¹é…ï¼šemæ ‡ç­¾ä¸­çš„shop-name-strç±»ï¼ˆæ ¹æ®ç”¨æˆ·æä¾›çš„HTMLç»“æ„ï¼‰
            shop_name_pattern1 = r'<em[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</em>'
            match = re.search(shop_name_pattern1, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (em shop-name-str): {shop_name}")
                return shop_name

            # ç„¶åå°è¯•æ›´å®½æ³›çš„åŒ¹é…ï¼ŒæŸ¥æ‰¾åŒ…å«shop-name-strç±»çš„ä»»ä½•å…ƒç´ 
            shop_name_pattern2 = r'<[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</[^>]*>'
            match = re.search(shop_name_pattern2, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (é€šç”¨shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•åŒ¹é…class="shop-name-str"çš„å…ƒç´ ï¼ˆä¸é™å®šæ ‡ç­¾ç±»å‹ï¼‰
            shop_name_pattern3 = r'class="shop-name-str"[^>]*>([^<]+)</'
            match = re.search(shop_name_pattern3, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°ï¼ˆå¤šç§æ ¼å¼ï¼‰
            # æ ¼å¼1: "shopName":"Aiseo"
            shop_name_pattern4 = r'"shopName"\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern4, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScript): {shop_name}")
                return shop_name

            # æ ¼å¼2: \"shopName\":\"Aiseo\" (åœ¨HTMLä¸­è¢«è½¬ä¹‰)
            shop_name_pattern5 = r'\\"shopName\\"\s*:\s*\\"([^\\"]+)\\"'
            match = re.search(shop_name_pattern5, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptè½¬ä¹‰): {shop_name}")
                return shop_name

            # æ ¼å¼3: shopName:"Aiseo" (æ— å¼•å·)
            shop_name_pattern6 = r'shopName\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern6, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptæ— å¼•å·): {shop_name}")
                return shop_name

            logger.warning("æœªæ‰¾åˆ°åº—é“ºåç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°")
            return "æœªçŸ¥åº—é“º"

        except Exception as e:
            logger.error(f"è·å–åº—é“ºåç§°å¤±è´¥: {e}")
            return "æœªçŸ¥åº—é“º"

    def close(self):
        """å…³é—­èµ„æº - å ä½æ–¹æ³•"""
        pass

# å…¨å±€çˆ¬è™«å®ä¾‹
_scraper = None

def get_weidian_scraper() -> WeidianScraper:
    """è·å–å¾®åº—çˆ¬è™«å®ä¾‹"""
    global _scraper
    if _scraper is None:
        _scraper = WeidianScraper()
    return _scraper

===== src-tauri/src/main.rs =====
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use tauri::api::process::{Command, CommandEvent};
use std::sync::Mutex;
use tauri::Manager;

struct BackendState {
    child: Option<tauri::api::process::CommandChild>,
}

fn main() {
    tauri::Builder::default()
        .manage(Mutex::new(BackendState { child: None }))
        .setup(|app| {
            // å¯åŠ¨ Python åç«¯ sidecar
            let (mut rx, child) = Command::new_sidecar("backend")
                .expect("failed to create sidecar command")
                .spawn()
                .expect("failed to spawn sidecar");

            // ä¿å­˜å­è¿›ç¨‹å¼•ç”¨
            let state = app.state::<Mutex<BackendState>>();
            state.lock().unwrap().child = Some(child);

            // ç›‘å¬åç«¯è¾“å‡º
            tauri::async_runtime::spawn(async move {
                while let Some(event) = rx.recv().await {
                    match event {
                        CommandEvent::Stdout(line) => {
                            println!("[Backend] {}", line);
                        }
                        CommandEvent::Stderr(line) => {
                            eprintln!("[Backend Error] {}", line);
                        }
                        _ => {}
                    }
                }
            });

            Ok(())
        })
        .on_window_event(|event| {
            if let tauri::WindowEvent::CloseRequested { .. } = event.event() {
                // å…³é—­çª—å£æ—¶åœæ­¢åç«¯
                let child = {
                    let state = event.window().state::<Mutex<BackendState>>();
                    let mut guard = state.lock().unwrap();
                    guard.child.take()
                };
                if let Some(child) = child {
                    let _ = child.kill();
                }
            }
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

===== src/App.tsx =====
import { useEffect, useState, type ReactNode } from 'react'
import { BrowserRouter, Routes, Route, NavLink } from 'react-router-dom'
import { Toaster } from 'sonner'
import { Users, Store, Send } from 'lucide-react'

import AccountsPage from './pages/AccountsPage'
import ShopsPage from './pages/ShopsPage'
import AutoSenderPage from './pages/AutoSenderPage'
import LicenseGate from './components/LicenseGate'

const API_BASE = 'http://127.0.0.1:5001/api'

function App() {
  const [licenseLoading, setLicenseLoading] = useState(true)
  const [licenseActive, setLicenseActive] = useState(false)

  const refreshLicenseStatus = async () => {
    setLicenseLoading(true)
    try {
      const res = await fetch(`${API_BASE}/license/status`)
      const data = await res.json()
      if (data.success && data.activated) {
        setLicenseActive(true)
      } else {
        setLicenseActive(false)
      }
    } catch (error) {
      setLicenseActive(false)
    } finally {
      setLicenseLoading(false)
    }
  }

  useEffect(() => {
    refreshLicenseStatus()
  }, [])

  let content: ReactNode
  if (licenseLoading) {
    content = (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-gray-500">æ­£åœ¨éªŒè¯è®¸å¯è¯...</div>
      </div>
    )
  } else if (!licenseActive) {
    content = <LicenseGate onActivated={refreshLicenseStatus} />
  } else {
    content = (
      <BrowserRouter>
        <div className="flex min-h-screen bg-gray-50">
          {/* ä¾§è¾¹æ  */}
          <nav className="w-64 bg-white border-r border-gray-200 p-4">
            <div className="mb-8">
              <h1 className="text-xl font-bold text-gray-800">Discord è¥é”€</h1>
              <p className="text-sm text-gray-500">è‡ªåŠ¨å‘é€ç³»ç»Ÿ</p>
            </div>

            <ul className="space-y-2">
              <li>
                <NavLink
                  to="/"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Send size={20} />
                  <span>è‡ªåŠ¨å‘é€</span>
                </NavLink>
              </li>
              <li>
                <NavLink
                  to="/accounts"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Users size={20} />
                  <span>è´¦å·ç®¡ç†</span>
                </NavLink>
              </li>
              <li>
                <NavLink
                  to="/shops"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Store size={20} />
                  <span>åº—é“ºç®¡ç†</span>
                </NavLink>
              </li>
            </ul>
          </nav>

          {/* ä¸»å†…å®¹åŒº */}
          <main className="flex-1 p-6 overflow-auto">
            <Routes>
              <Route path="/" element={<AutoSenderPage />} />
              <Route path="/accounts" element={<AccountsPage />} />
              <Route path="/shops" element={<ShopsPage />} />
            </Routes>
          </main>
        </div>
      </BrowserRouter>
    )
  }

  return (
    <>
      {content}
      <Toaster position="top-right" richColors />
    </>
  )
}

export default App

===== src/components/LicenseGate.tsx =====
import { useState } from 'react'

const API_BASE = 'http://127.0.0.1:5001/api'

interface LicenseGateProps {
  onActivated: () => Promise<void>
}

export default function LicenseGate({ onActivated }: LicenseGateProps) {
  const [licenseKey, setLicenseKey] = useState('')
  const [submitting, setSubmitting] = useState(false)

  const handleActivate = async () => {
    const trimmedKey = licenseKey.trim()
    if (!trimmedKey) {
      return
    }

    setSubmitting(true)
    try {
      const res = await fetch(`${API_BASE}/license/activate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ key: trimmedKey })
      })
      const data = await res.json()
      if (data.success) {
        await onActivated()
      }
    } catch (err) {
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-6">
      <div className="w-full max-w-md bg-white border rounded-xl p-6 space-y-4">
        <div>
          <h1 className="text-xl font-bold text-gray-900">è½¯ä»¶æ¿€æ´»</h1>
          <p className="text-sm text-gray-500">è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥ä»¥ç»§ç»­ä½¿ç”¨ã€‚</p>
        </div>

        <div className="space-y-2">
          <label className="block text-sm font-medium text-gray-700">è®¸å¯è¯å¯†é’¥</label>
          <input
            type="text"
            value={licenseKey}
            onChange={(e) => setLicenseKey(e.target.value)}
            placeholder="è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥"
            className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
        </div>

        <button
          onClick={handleActivate}
          disabled={submitting}
          className="w-full px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {submitting ? 'æ¿€æ´»ä¸­...' : 'æ¿€æ´»'}
        </button>
      </div>
    </div>
  )
}

===== src/main.tsx =====
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

===== src/pages/AccountsPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Plus, Trash2, Power, PowerOff, RefreshCw } from 'lucide-react'

interface Account {
  id: number
  username: string
  token: string
  status: string
  is_online: boolean
  last_active: string | null
  created_at: string
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function AccountsPage() {
  const [accounts, setAccounts] = useState<Account[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddModal, setShowAddModal] = useState(false)
  const [newToken, setNewToken] = useState('')
  const [newUsername, setNewUsername] = useState('')

  const fetchAccounts = async () => {
    try {
      const res = await fetch(`${API_BASE}/accounts`)
      const data = await res.json()
      if (data.success) {
        setAccounts(data.accounts || [])
      }
    } catch (error) {
      toast.error('è·å–è´¦å·åˆ—è¡¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchAccounts()
    // å®šæœŸåˆ·æ–°çŠ¶æ€
    const interval = setInterval(fetchAccounts, 5000)
    return () => clearInterval(interval)
  }, [])

  const handleAddAccount = async () => {
    if (!newToken.trim()) {
      toast.error('è¯·è¾“å…¥ Token')
      return
    }

    try {
      const res = await fetch(`${API_BASE}/accounts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: newToken, username: newUsername })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('è´¦å·æ·»åŠ æˆåŠŸ')
        setNewToken('')
        setNewUsername('')
        setShowAddModal(false)
        fetchAccounts()
      } else {
        toast.error(data.error || 'æ·»åŠ å¤±è´¥')
      }
    } catch (error) {
      toast.error('æ·»åŠ è´¦å·å¤±è´¥')
    }
  }

  const handleDeleteAccount = async (id: number) => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè´¦å·å—ï¼Ÿ')) return

    try {
      const res = await fetch(`${API_BASE}/accounts/${id}`, { method: 'DELETE' })
      const data = await res.json()
      if (data.success) {
        toast.success('è´¦å·å·²åˆ é™¤')
        fetchAccounts()
      } else {
        toast.error(data.error || 'åˆ é™¤å¤±è´¥')
      }
    } catch (error) {
      toast.error('åˆ é™¤è´¦å·å¤±è´¥')
    }
  }

  const handleToggleAccount = async (id: number, isOnline: boolean) => {
    const action = isOnline ? 'stop' : 'start'
    try {
      const res = await fetch(`${API_BASE}/accounts/${id}/${action}`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success(isOnline ? 'è´¦å·å·²åœæ­¢' : 'è´¦å·å¯åŠ¨ä¸­...')
        setTimeout(fetchAccounts, 1000)
      } else {
        toast.error(data.error || 'æ“ä½œå¤±è´¥')
      }
    } catch (error) {
      toast.error('æ“ä½œå¤±è´¥')
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">è´¦å·ç®¡ç†</h2>
          <p className="text-gray-500">ç®¡ç†ä½ çš„ Discord è´¦å·ï¼Œé€šè¿‡ Token ç™»å½•</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={fetchAccounts}
            className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
          >
            <RefreshCw size={18} />
            åˆ·æ–°
          </button>
          <button
            onClick={() => setShowAddModal(true)}
            className="flex items-center gap-2 px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
          >
            <Plus size={18} />
            æ·»åŠ è´¦å·
          </button>
        </div>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-500">åŠ è½½ä¸­...</div>
      ) : accounts.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg border">
          <p className="text-gray-500">æš‚æ— è´¦å·ï¼Œè¯·æ·»åŠ  Discord è´¦å·</p>
        </div>
      ) : (
        <div className="bg-white rounded-lg border overflow-hidden">
          <table className="w-full">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">ç”¨æˆ·å</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">çŠ¶æ€</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">Token</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">æœ€åæ´»è·ƒ</th>
                <th className="px-6 py-3 text-right text-sm font-medium text-gray-500">æ“ä½œ</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {accounts.map((account) => (
                <tr key={account.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4 text-sm font-medium text-gray-900">
                    {account.username || `è´¦å· ${account.id}`}
                  </td>
                  <td className="px-6 py-4">
                    <span
                      className={`inline-flex items-center px-2 py-1 text-xs rounded-full ${
                        account.is_online
                          ? 'bg-green-100 text-green-700'
                          : 'bg-gray-100 text-gray-600'
                      }`}
                    >
                      {account.is_online ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                    </span>
                  </td>
                  <td className="px-6 py-4 text-sm text-gray-500 font-mono">
                    {account.token?.substring(0, 20)}...
                  </td>
                  <td className="px-6 py-4 text-sm text-gray-500">
                    {account.last_active || '-'}
                  </td>
                  <td className="px-6 py-4 text-right space-x-2">
                    <button
                      onClick={() => handleToggleAccount(account.id, account.is_online)}
                      className={`p-2 rounded-lg ${
                        account.is_online
                          ? 'text-red-600 hover:bg-red-50'
                          : 'text-green-600 hover:bg-green-50'
                      }`}
                      title={account.is_online ? 'åœæ­¢' : 'å¯åŠ¨'}
                    >
                      {account.is_online ? <PowerOff size={18} /> : <Power size={18} />}
                    </button>
                    <button
                      onClick={() => handleDeleteAccount(account.id)}
                      className="p-2 text-red-600 rounded-lg hover:bg-red-50"
                      title="åˆ é™¤"
                    >
                      <Trash2 size={18} />
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* æ·»åŠ è´¦å·å¼¹çª— */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-bold mb-4">æ·»åŠ  Discord è´¦å·</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  ç”¨æˆ·å (å¯é€‰)
                </label>
                <input
                  type="text"
                  value={newUsername}
                  onChange={(e) => setNewUsername(e.target.value)}
                  placeholder="ç”¨äºè¯†åˆ«è´¦å·"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Token <span className="text-red-500">*</span>
                </label>
                <input
                  type="password"
                  value={newToken}
                  onChange={(e) => setNewToken(e.target.value)}
                  placeholder="Discord è´¦å· Token"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
                <p className="mt-1 text-xs text-gray-500">
                  Token ç”¨äºç™»å½• Discord è´¦å·ï¼Œè¯·å¦¥å–„ä¿ç®¡
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2 mt-6">
              <button
                onClick={() => setShowAddModal(false)}
                className="px-4 py-2 text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200"
              >
                å–æ¶ˆ
              </button>
              <button
                onClick={handleAddAccount}
                className="px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
              >
                æ·»åŠ 
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

===== src/pages/AutoSenderPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Play, Square, RefreshCw, CheckCircle, Circle } from 'lucide-react'

interface Shop {
  id: number
  shop_id: string
  name: string
  product_count: number
}

interface Account {
  id: number
  username: string
  is_online: boolean
}

interface TaskStatus {
  is_running: boolean
  shop_id: number | null
  channel_id: string | null
  total_products: number
  sent_count: number
  current_product: string | null
  current_account: string | null
  started_at: string | null
  last_sent_at: string | null
  error: string | null
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function AutoSenderPage() {
  const [shops, setShops] = useState<Shop[]>([])
  const [accounts, setAccounts] = useState<Account[]>([])
  const [status, setStatus] = useState<TaskStatus | null>(null)

  // è¡¨å•çŠ¶æ€
  const [selectedShop, setSelectedShop] = useState('')
  const [targetChannel, setTargetChannel] = useState('')
  const [selectedAccounts, setSelectedAccounts] = useState<number[]>([])
  const [interval, setInterval] = useState('60')
  const [loading, setLoading] = useState(false)

  // è·å–åº—é“ºå’Œè´¦å·æ•°æ®
  const fetchData = async () => {
    try {
      const [shopsRes, accountsRes, statusRes] = await Promise.all([
        fetch(`${API_BASE}/shops`),
        fetch(`${API_BASE}/accounts`),
        fetch(`${API_BASE}/sender/status`)
      ])

      const shopsData = await shopsRes.json()
      const accountsData = await accountsRes.json()
      const statusData = await statusRes.json()

      if (shopsData.success) {
        setShops(shopsData.shops || [])
      }
      if (accountsData.success) {
        // åªæ˜¾ç¤ºåœ¨çº¿è´¦å·
        const onlineAccounts = (accountsData.accounts || []).filter(
          (a: Account) => a.is_online
        )
        setAccounts(onlineAccounts)
      }
      if (statusData.success) {
        setStatus(statusData.status)
      }
    } catch (error) {
      console.error('è·å–æ•°æ®å¤±è´¥:', error)
    }
  }

  useEffect(() => {
    fetchData()
    // å®šæœŸåˆ·æ–°çŠ¶æ€
    const interval = setInterval(fetchData, 3000)
    return () => clearInterval(interval)
  }, [])

  const toggleAccount = (id: number) => {
    setSelectedAccounts((prev) =>
      prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]
    )
  }

  const handleStart = async () => {
    if (!selectedShop) {
      toast.error('è¯·é€‰æ‹©åº—é“º')
      return
    }
    if (!targetChannel) {
      toast.error('è¯·è¾“å…¥ç›®æ ‡é¢‘é“ ID')
      return
    }
    if (selectedAccounts.length === 0) {
      toast.error('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªè´¦å·')
      return
    }

    setLoading(true)
    try {
      const res = await fetch(`${API_BASE}/sender/start`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopId: selectedShop,
          channelId: targetChannel,
          accountIds: selectedAccounts,
          interval: parseInt(interval)
        })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('è‡ªåŠ¨å‘é€å·²å¯åŠ¨')
        fetchData()
      } else {
        toast.error(data.error || 'å¯åŠ¨å¤±è´¥')
      }
    } catch (error) {
      toast.error('å¯åŠ¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  const handleStop = async () => {
    setLoading(true)
    try {
      const res = await fetch(`${API_BASE}/sender/stop`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success('å·²åœæ­¢å‘é€')
        fetchData()
      } else {
        toast.error(data.error || 'åœæ­¢å¤±è´¥')
      }
    } catch (error) {
      toast.error('åœæ­¢å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  const isRunning = status?.is_running || false

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">è‡ªåŠ¨å‘é€æ§åˆ¶å°</h2>
          <p className="text-gray-500">é…ç½®å¹¶å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡</p>
        </div>
        <button
          onClick={fetchData}
          className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
        >
          <RefreshCw size={18} />
          åˆ·æ–°
        </button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* å·¦ä¾§ï¼šé…ç½®åŒº */}
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">ä»»åŠ¡é…ç½®</h3>

          <div className="space-y-4">
            {/* é€‰æ‹©åº—é“º */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                é€‰æ‹©åº—é“º (æ•°æ®æº)
              </label>
              <select
                value={selectedShop}
                onChange={(e) => setSelectedShop(e.target.value)}
                disabled={isRunning}
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              >
                <option value="">é€‰æ‹©è¦å‘é€çš„åº—é“º</option>
                {shops.map((shop) => (
                  <option key={shop.id} value={shop.id}>
                    {shop.name} ({shop.product_count || 0} ä¸ªå•†å“)
                  </option>
                ))}
              </select>
            </div>

            {/* ç›®æ ‡é¢‘é“ */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                ç›®æ ‡ Discord é¢‘é“ ID
              </label>
              <input
                type="text"
                value={targetChannel}
                onChange={(e) => setTargetChannel(e.target.value)}
                disabled={isRunning}
                placeholder="ä¾‹å¦‚: 123456789012345678"
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              />
            </div>

            {/* å‘é€é¢‘ç‡ */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                å‘é€é—´éš” (ç§’)
              </label>
              <input
                type="number"
                value={interval}
                onChange={(e) => setInterval(e.target.value)}
                disabled={isRunning}
                min="10"
                max="3600"
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              />
              <p className="mt-1 text-xs text-gray-500">å»ºè®®è®¾ç½® 60 ç§’ä»¥ä¸Šï¼Œé¿å…è§¦å‘é™åˆ¶</p>
            </div>

            {/* æ“ä½œæŒ‰é’® */}
            <div className="pt-4 flex gap-4">
              <button
                onClick={handleStart}
                disabled={isRunning || loading}
                className="flex-1 flex items-center justify-center gap-2 px-4 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Play size={18} />
                å¯åŠ¨ä»»åŠ¡
              </button>
              <button
                onClick={handleStop}
                disabled={!isRunning || loading}
                className="flex-1 flex items-center justify-center gap-2 px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Square size={18} />
                åœæ­¢ä»»åŠ¡
              </button>
            </div>
          </div>
        </div>

        {/* å³ä¾§ï¼šè´¦å·é€‰æ‹©åŒº */}
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">è´¦å·è½®æ¢æ± </h3>

          {accounts.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              æš‚æ— åœ¨çº¿è´¦å·ï¼Œè¯·åœ¨è´¦å·ç®¡ç†é¡µå¯åŠ¨è´¦å·
            </div>
          ) : (
            <div className="space-y-2 max-h-[300px] overflow-y-auto">
              {accounts.map((account) => (
                <div
                  key={account.id}
                  onClick={() => !isRunning && toggleAccount(account.id)}
                  className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors ${
                    selectedAccounts.includes(account.id)
                      ? 'bg-blue-50 border-blue-200 border'
                      : 'bg-gray-50 hover:bg-gray-100'
                  } ${isRunning ? 'opacity-50 cursor-not-allowed' : ''}`}
                >
                  {selectedAccounts.includes(account.id) ? (
                    <CheckCircle size={20} className="text-blue-600" />
                  ) : (
                    <Circle size={20} className="text-gray-400" />
                  )}
                  <div className="flex-1">
                    <span className="font-medium text-gray-800">
                      {account.username || `è´¦å· ${account.id}`}
                    </span>
                    <span className="ml-2 text-xs text-green-600">åœ¨çº¿</span>
                  </div>
                </div>
              ))}
            </div>
          )}

          <p className="mt-4 text-xs text-gray-500">
            ç³»ç»Ÿå°†æŒ‰ç…§å‹¾é€‰é¡ºåºï¼Œæ¯éš” {interval} ç§’åˆ‡æ¢ä¸‹ä¸€ä¸ªè´¦å·å‘é€ä¸€æ¡é“¾æ¥
          </p>
        </div>
      </div>

      {/* ä»»åŠ¡çŠ¶æ€ */}
      {status && (
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">ä»»åŠ¡çŠ¶æ€</h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div>
              <p className="text-sm text-gray-500">çŠ¶æ€</p>
              <p className={`font-medium ${isRunning ? 'text-green-600' : 'text-gray-600'}`}>
                {isRunning ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">è¿›åº¦</p>
              <p className="font-medium text-gray-800">
                {status.sent_count} / {status.total_products}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">å½“å‰å•†å“</p>
              <p className="font-medium text-gray-800 truncate">
                {status.current_product || '-'}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">å½“å‰è´¦å·</p>
              <p className="font-medium text-gray-800">{status.current_account || '-'}</p>
            </div>
          </div>
          {status.error && (
            <div className="mt-4 p-3 bg-red-50 text-red-600 rounded-lg text-sm">
              {status.error}
            </div>
          )}
        </div>
      )}
    </div>
  )
}

===== src/pages/ShopsPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Plus, Trash2, Download, RefreshCw } from 'lucide-react'

interface Shop {
  id: number
  shop_id: string
  name: string
  product_count: number
  created_at: string
  updated_at: string
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function ShopsPage() {
  const [shops, setShops] = useState<Shop[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddModal, setShowAddModal] = useState(false)
  const [newShopId, setNewShopId] = useState('')
  const [newShopName, setNewShopName] = useState('')

  const fetchShops = async () => {
    try {
      const res = await fetch(`${API_BASE}/shops`)
      const data = await res.json()
      if (data.success) {
        setShops(data.shops || [])
      }
    } catch (error) {
      toast.error('è·å–åº—é“ºåˆ—è¡¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchShops()
  }, [])

  const handleAddShop = async () => {
    if (!newShopId.trim()) {
      toast.error('è¯·è¾“å…¥åº—é“º ID')
      return
    }

    try {
      const res = await fetch(`${API_BASE}/shops`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shop_id: newShopId, name: newShopName })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('åº—é“ºæ·»åŠ æˆåŠŸ')
        setNewShopId('')
        setNewShopName('')
        setShowAddModal(false)
        fetchShops()
      } else {
        toast.error(data.error || 'æ·»åŠ å¤±è´¥')
      }
    } catch (error) {
      toast.error('æ·»åŠ åº—é“ºå¤±è´¥')
    }
  }

  const handleDeleteShop = async (id: number) => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåº—é“ºå—ï¼Ÿ')) return

    try {
      const res = await fetch(`${API_BASE}/shops/${id}`, { method: 'DELETE' })
      const data = await res.json()
      if (data.success) {
        toast.success('åº—é“ºå·²åˆ é™¤')
        fetchShops()
      } else {
        toast.error(data.error || 'åˆ é™¤å¤±è´¥')
      }
    } catch (error) {
      toast.error('åˆ é™¤åº—é“ºå¤±è´¥')
    }
  }

  const handleScrapeShop = async (id: number) => {
    try {
      const res = await fetch(`${API_BASE}/shops/${id}/scrape`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success('æŠ“å–ä»»åŠ¡å·²å¯åŠ¨')
      } else {
        toast.error(data.error || 'å¯åŠ¨æŠ“å–å¤±è´¥')
      }
    } catch (error) {
      toast.error('å¯åŠ¨æŠ“å–å¤±è´¥')
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">åº—é“ºç®¡ç†</h2>
          <p className="text-gray-500">ç®¡ç†ä½ çš„å¾®åº—åº—é“ºï¼ŒæŠ“å–å•†å“æ•°æ®</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={fetchShops}
            className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
          >
            <RefreshCw size={18} />
            åˆ·æ–°
          </button>
          <button
            onClick={() => setShowAddModal(true)}
            className="flex items-center gap-2 px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
          >
            <Plus size={18} />
            æ·»åŠ åº—é“º
          </button>
        </div>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-500">åŠ è½½ä¸­...</div>
      ) : shops.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg border">
          <p className="text-gray-500">æš‚æ— åº—é“ºï¼Œè¯·æ·»åŠ å¾®åº—åº—é“º</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {shops.map((shop) => (
            <div key={shop.id} className="bg-white rounded-lg border p-4">
              <div className="flex items-start justify-between">
                <div>
                  <h3 className="font-bold text-gray-800">{shop.name}</h3>
                  <p className="text-sm text-gray-500">ID: {shop.shop_id}</p>
                </div>
                <div className="flex gap-1">
                  <button
                    onClick={() => handleScrapeShop(shop.id)}
                    className="p-2 text-blue-600 rounded-lg hover:bg-blue-50"
                    title="æŠ“å–å•†å“"
                  >
                    <Download size={18} />
                  </button>
                  <button
                    onClick={() => handleDeleteShop(shop.id)}
                    className="p-2 text-red-600 rounded-lg hover:bg-red-50"
                    title="åˆ é™¤"
                  >
                    <Trash2 size={18} />
                  </button>
                </div>
              </div>
              <div className="mt-4 pt-4 border-t flex justify-between text-sm">
                <span className="text-gray-500">å•†å“æ•°é‡</span>
                <span className="font-medium text-gray-800">{shop.product_count || 0}</span>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* æ·»åŠ åº—é“ºå¼¹çª— */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-bold mb-4">æ·»åŠ å¾®åº—åº—é“º</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  åº—é“ºåç§° (å¯é€‰)
                </label>
                <input
                  type="text"
                  value={newShopName}
                  onChange={(e) => setNewShopName(e.target.value)}
                  placeholder="ç”¨äºè¯†åˆ«åº—é“º"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  åº—é“º ID <span className="text-red-500">*</span>
                </label>
                <input
                  type="text"
                  value={newShopId}
                  onChange={(e) => setNewShopId(e.target.value)}
                  placeholder="ä¾‹å¦‚: 1713062461"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
                <p className="mt-1 text-xs text-gray-500">
                  å¾®åº—åº—é“º IDï¼Œå¯ä»åº—é“º URL ä¸­è·å–
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2 mt-6">
              <button
                onClick={() => setShowAddModal(false)}
                className="px-4 py-2 text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200"
              >
                å–æ¶ˆ
              </button>
              <button
                onClick={handleAddShop}
                className="px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
              >
                æ·»åŠ 
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

===== backend/app.py =====
"""
Flask API åº”ç”¨ - Discord è‡ªåŠ¨è¥é”€æœºå™¨äººç³»ç»Ÿ

æä¾› REST API æ¥å£ï¼š
- è´¦å·ç®¡ç† (CRUD + å¯åŠ¨/åœæ­¢)
- åº—é“ºç®¡ç† (CRUD + æŠ“å–)
- è‡ªåŠ¨å‘é€ä»»åŠ¡æ§åˆ¶
"""
import asyncio
import threading
import logging
from flask import Flask, request, jsonify
from flask_cors import CORS

from config import config
from database import Database
from bot import DiscordBotClient, bot_clients
from auto_sender import (
    start_sending_task,
    stop_sending_task,
    get_task_status
)
from weidian_scraper import WeidianScraper, save_cookie_string
from license_manager import activate_license, validate_local_license

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# åˆå§‹åŒ– Flask åº”ç”¨
app = Flask(__name__)
CORS(app)

# åˆå§‹åŒ–æ•°æ®åº“
db = Database()

# Discord bot äº‹ä»¶å¾ªç¯ï¼ˆåœ¨å•ç‹¬çº¿ç¨‹ä¸­è¿è¡Œï¼‰
bot_loop: asyncio.AbstractEventLoop = None
bot_thread: threading.Thread = None


# ============== è®¸å¯è¯ API ==============

@app.route('/api/license/status', methods=['GET'])
def get_license_status():
    """è·å–æœ¬åœ°è®¸å¯è¯çŠ¶æ€"""
    try:
        activated, payload = validate_local_license()
        if activated:
            return jsonify({'success': True, 'activated': True, 'license': payload})
        return jsonify({'success': True, 'activated': False, 'error': payload})
    except Exception as e:
        logger.error(f"è·å–è®¸å¯è¯çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/license/activate', methods=['POST'])
def activate_license_api():
    """æ¿€æ´»è®¸å¯è¯"""
    try:
        data = request.get_json() or {}
        license_key = data.get('key', '').strip()
        if not license_key:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥'}), 400

        success, result = activate_license(license_key)
        if success:
            return jsonify({'success': True, **result})
        return jsonify({'success': False, 'error': result.get('message', 'æ¿€æ´»å¤±è´¥')}), 400
    except Exception as e:
        logger.error(f"æ¿€æ´»è®¸å¯è¯å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== æ—¥å¿— API ==============

@app.route('/api/logs/add', methods=['POST'])
def add_log():
    """æ¥æ”¶å®¢æˆ·ç«¯æ—¥å¿—"""
    try:
        data = request.get_json() or {}
        message = data.get('message', '')
        module = data.get('module', '')
        func = data.get('func', '')
        level = data.get('level', 'INFO')
        logger.info("BOT_LOG [%s] %s %s %s", level, module, func, message)
        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"æ¥æ”¶æ—¥å¿—å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== è´¦å·ç®¡ç† API ==============

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """è·å–æ‰€æœ‰ Discord è´¦å·"""
    try:
        accounts = db.get_all_accounts()
        # æ·»åŠ åœ¨çº¿çŠ¶æ€
        online_ids = {c.account_id for c in bot_clients if c.is_ready() and not c.is_closed()}
        for acc in accounts:
            acc['is_online'] = acc['id'] in online_ids
        return jsonify({'success': True, 'accounts': accounts})
    except Exception as e:
        logger.error(f"è·å–è´¦å·åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts', methods=['POST'])
def add_account():
    """æ·»åŠ æ–°è´¦å· (é€šè¿‡ token)"""
    try:
        data = request.get_json()
        token = data.get('token', '').strip()
        username = data.get('username', '').strip()

        if not token:
            return jsonify({'success': False, 'error': 'Token ä¸èƒ½ä¸ºç©º'}), 400

        account_id = db.add_account(token=token, username=username)
        return jsonify({'success': True, 'account_id': account_id, 'message': 'è´¦å·æ·»åŠ æˆåŠŸ'})
    except Exception as e:
        logger.error(f"æ·»åŠ è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>', methods=['DELETE'])
def delete_account(account_id):
    """åˆ é™¤è´¦å·"""
    try:
        # å…ˆåœæ­¢è¯¥è´¦å·çš„è¿æ¥
        for client in bot_clients:
            if client.account_id == account_id:
                asyncio.run_coroutine_threadsafe(client.close(), bot_loop)
                bot_clients.remove(client)
                break

        db.delete_account(account_id)
        return jsonify({'success': True, 'message': 'è´¦å·å·²åˆ é™¤'})
    except Exception as e:
        logger.error(f"åˆ é™¤è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>/start', methods=['POST'])
def start_account(account_id):
    """å¯åŠ¨è´¦å·è¿æ¥"""
    try:
        account = db.get_account_by_id(account_id)
        if not account:
            return jsonify({'success': False, 'error': 'è´¦å·ä¸å­˜åœ¨'}), 404

        # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨çº¿
        for client in bot_clients:
            if client.account_id == account_id and client.is_ready():
                return jsonify({'success': False, 'error': 'è´¦å·å·²åœ¨çº¿'}), 400

        # åˆ›å»ºæ–°çš„å®¢æˆ·ç«¯å¹¶å¯åŠ¨
        client = DiscordBotClient(account_id=account_id)
        token = account['token']

        async def start_bot():
            try:
                await client.start(token, reconnect=True)
            except Exception as e:
                logger.error(f"è´¦å· {account_id} å¯åŠ¨å¤±è´¥: {e}")

        asyncio.run_coroutine_threadsafe(start_bot(), bot_loop)
        bot_clients.append(client)

        db.update_account_status(account_id, 'online')
        return jsonify({'success': True, 'message': 'è´¦å·å¯åŠ¨ä¸­...'})
    except Exception as e:
        logger.error(f"å¯åŠ¨è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/accounts/<int:account_id>/stop', methods=['POST'])
def stop_account(account_id):
    """åœæ­¢è´¦å·è¿æ¥"""
    try:
        for client in bot_clients:
            if client.account_id == account_id:
                asyncio.run_coroutine_threadsafe(client.close(), bot_loop)
                bot_clients.remove(client)
                db.update_account_status(account_id, 'offline')
                return jsonify({'success': True, 'message': 'è´¦å·å·²åœæ­¢'})

        return jsonify({'success': False, 'error': 'è´¦å·æœªåœ¨çº¿'}), 400
    except Exception as e:
        logger.error(f"åœæ­¢è´¦å·å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== åº—é“ºç®¡ç† API ==============

@app.route('/api/shops', methods=['GET'])
def get_shops():
    """è·å–æ‰€æœ‰åº—é“º"""
    try:
        shops = db.get_all_shops()
        return jsonify({'success': True, 'shops': shops})
    except Exception as e:
        logger.error(f"è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops', methods=['POST'])
def add_shop():
    """æ·»åŠ æ–°åº—é“º"""
    try:
        data = request.get_json()
        shop_id = data.get('shop_id', '').strip()
        name = data.get('name', '').strip()

        if not shop_id:
            return jsonify({'success': False, 'error': 'åº—é“ºIDä¸èƒ½ä¸ºç©º'}), 400

        result_id = db.add_shop(shop_id=shop_id, name=name or f"åº—é“º{shop_id}")
        return jsonify({'success': True, 'id': result_id, 'message': 'åº—é“ºæ·»åŠ æˆåŠŸ'})
    except Exception as e:
        logger.error(f"æ·»åŠ åº—é“ºå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>', methods=['DELETE'])
def delete_shop(shop_id):
    """åˆ é™¤åº—é“º"""
    try:
        db.delete_shop(shop_id)
        return jsonify({'success': True, 'message': 'åº—é“ºå·²åˆ é™¤'})
    except Exception as e:
        logger.error(f"åˆ é™¤åº—é“ºå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>/scrape', methods=['POST'])
def scrape_shop(shop_id):
    """æŠ“å–åº—é“ºå•†å“"""
    try:
        shop = db.get_shop_by_id(shop_id)
        if not shop:
            return jsonify({'success': False, 'error': 'åº—é“ºä¸å­˜åœ¨'}), 404

        # å¯åŠ¨æŠ“å–ä»»åŠ¡ï¼ˆåœ¨åå°çº¿ç¨‹ï¼‰
        def scrape_task():
            try:
                scraper = WeidianScraper()
                # è¿™é‡Œéœ€è¦å®ç° scrape_shop_products æ–¹æ³•
                # products = scraper.scrape_shop_products(shop['shop_id'])
                # for product in products:
                #     db.insert_product(product)
                logger.info(f"åº—é“º {shop['name']} æŠ“å–å®Œæˆ")
            except Exception as e:
                logger.error(f"æŠ“å–åº—é“ºå¤±è´¥: {e}")

        thread = threading.Thread(target=scrape_task, daemon=True)
        thread.start()

        return jsonify({'success': True, 'message': 'æŠ“å–ä»»åŠ¡å·²å¯åŠ¨'})
    except Exception as e:
        logger.error(f"å¯åŠ¨æŠ“å–å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/shops/<int:shop_id>/products', methods=['GET'])
def get_shop_products(shop_id):
    """è·å–åº—é“ºçš„æ‰€æœ‰å•†å“"""
    try:
        shop = db.get_shop_by_id(shop_id)
        if not shop:
            return jsonify({'success': False, 'error': 'åº—é“ºä¸å­˜åœ¨'}), 404

        products = db.get_products_by_shop(shop['name'])
        return jsonify({'success': True, 'products': products})
    except Exception as e:
        logger.error(f"è·å–å•†å“åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== è‡ªåŠ¨å‘é€ä»»åŠ¡ API ==============

@app.route('/api/sender/start', methods=['POST'])
def start_sender():
    """å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡"""
    try:
        data = request.get_json()
        shop_id = data.get('shopId')
        channel_id = data.get('channelId')
        account_ids = data.get('accountIds', [])
        interval = data.get('interval', config.DEFAULT_SEND_INTERVAL)

        # å‚æ•°éªŒè¯
        if not shop_id:
            return jsonify({'success': False, 'error': 'è¯·é€‰æ‹©åº—é“º'}), 400
        if not channel_id:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç›®æ ‡é¢‘é“ID'}), 400
        if not account_ids:
            return jsonify({'success': False, 'error': 'è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªè´¦å·'}), 400

        # éªŒè¯é—´éš”èŒƒå›´
        interval = max(config.MIN_SEND_INTERVAL, min(interval, config.MAX_SEND_INTERVAL))

        result = start_sending_task(
            shop_id=int(shop_id),
            channel_id=str(channel_id),
            account_ids=[int(id) for id in account_ids],
            interval=int(interval),
            db=db,
            bot_clients=bot_clients,
            bot_loop=bot_loop
        )

        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        logger.error(f"å¯åŠ¨å‘é€ä»»åŠ¡å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/sender/stop', methods=['POST'])
def stop_sender():
    """åœæ­¢è‡ªåŠ¨å‘é€ä»»åŠ¡"""
    try:
        result = stop_sending_task()
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        logger.error(f"åœæ­¢å‘é€ä»»åŠ¡å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/sender/status', methods=['GET'])
def sender_status():
    """è·å–å‘é€ä»»åŠ¡çŠ¶æ€"""
    try:
        status = get_task_status()
        return jsonify({'success': True, 'status': status})
    except Exception as e:
        logger.error(f"è·å–ä»»åŠ¡çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============== ç³»ç»Ÿ API ==============

@app.route('/api/health', methods=['GET'])
def health_check():
    """å¥åº·æ£€æŸ¥"""
    return jsonify({
        'success': True,
        'status': 'running',
        'bot_count': len(bot_clients),
        'online_bots': len([c for c in bot_clients if c.is_ready()])
    })


# ============== è®¾ç½® API ==============

@app.route('/api/settings/cookies', methods=['POST'])
def update_weidian_cookies():
    """æ›´æ–°å¾®åº— Cookies"""
    try:
        data = request.get_json() or {}
        cookie_string = data.get('cookies', '').strip()
        if not cookie_string:
            return jsonify({'success': False, 'error': 'Cookies ä¸èƒ½ä¸ºç©º'}), 400
        if save_cookie_string(cookie_string):
            return jsonify({'success': True, 'message': 'Cookies å·²æ›´æ–°'})
        return jsonify({'success': False, 'error': 'ä¿å­˜Cookieså¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°Cookieså¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ============== Bot çº¿ç¨‹ç®¡ç† ==============

def run_bot_loop():
    """åœ¨å•ç‹¬çº¿ç¨‹ä¸­è¿è¡Œ Discord bot äº‹ä»¶å¾ªç¯"""
    global bot_loop
    bot_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(bot_loop)
    logger.info("Discord bot äº‹ä»¶å¾ªç¯å·²å¯åŠ¨")
    bot_loop.run_forever()


def start_bot_thread():
    """å¯åŠ¨ bot çº¿ç¨‹"""
    global bot_thread
    bot_thread = threading.Thread(target=run_bot_loop, daemon=True)
    bot_thread.start()
    logger.info("Bot çº¿ç¨‹å·²å¯åŠ¨")


# ============== ä¸»å…¥å£ ==============

if __name__ == '__main__':
    import signal
    import sys
    import time

    def shutdown_handler(signum, frame):
        """å¤„ç†å…³é—­ä¿¡å·ï¼Œæ¸…ç†èµ„æº"""
        logger.info("æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æœåŠ¡...")
        try:
            stop_sending_task()
        except Exception:
            pass

        if bot_loop and bot_loop.is_running():
            async def close_bots():
                for client in list(bot_clients):
                    try:
                        await client.close()
                    except Exception:
                        continue

            future = asyncio.run_coroutine_threadsafe(close_bots(), bot_loop)
            try:
                future.result(timeout=5)
            except Exception:
                pass
            try:
                bot_loop.call_soon_threadsafe(bot_loop.stop)
            except Exception:
                pass

        sys.exit(0)

    signal.signal(signal.SIGINT, shutdown_handler)
    signal.signal(signal.SIGTERM, shutdown_handler)

    # å¯åŠ¨ bot äº‹ä»¶å¾ªç¯çº¿ç¨‹
    start_bot_thread()

    # ç­‰å¾…äº‹ä»¶å¾ªç¯å¯åŠ¨
    time.sleep(1)

    logger.info(f"å¯åŠ¨ Flask æœåŠ¡: {config.FLASK_HOST}:{config.FLASK_PORT}")
    app.run(
        host=config.FLASK_HOST,
        port=config.FLASK_PORT,
        debug=False,
        use_reloader=False,
        threaded=True
    )

===== backend/auto_sender.py =====
"""
è‡ªåŠ¨å‘é€ä»»åŠ¡è°ƒåº¦æ¨¡å— - Discord å•†å“é“¾æ¥è‡ªåŠ¨å‘é€

å®ç°åŠŸèƒ½ï¼š
1. ä»æ•°æ®åº“è¯»å–æŒ‡å®šåº—é“ºçš„æ‰€æœ‰å•†å“
2. è·å–ç”¨æˆ·é€‰æ‹©çš„å¤šä¸ª Discord è´¦å·
3. è½®è¯¢ç®—æ³•ï¼šæ¯å‘ä¸€æ¡ï¼Œæ¢ä¸€ä¸ªè´¦å· (Round Robin)
4. é¢‘ç‡æ§åˆ¶ï¼šå‘é€åç­‰å¾…æŒ‡å®šç§’æ•°
5. æ”¯æŒéšæ—¶ä¸­æ–­ä»»åŠ¡
"""
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

# å…¨å±€å˜é‡æ§åˆ¶ä»»åŠ¡çŠ¶æ€
current_task: Optional[asyncio.Task] = None
stop_sender_event = asyncio.Event()
task_status = {
    'is_running': False,
    'shop_id': None,
    'channel_id': None,
    'total_products': 0,
    'sent_count': 0,
    'current_product': None,
    'current_account': None,
    'started_at': None,
    'last_sent_at': None,
    'error': None
}


def get_task_status() -> Dict:
    """è·å–å½“å‰ä»»åŠ¡çŠ¶æ€"""
    return task_status.copy()


def reset_task_status():
    """é‡ç½®ä»»åŠ¡çŠ¶æ€"""
    global task_status
    task_status = {
        'is_running': False,
        'shop_id': None,
        'channel_id': None,
        'total_products': 0,
        'sent_count': 0,
        'current_product': None,
        'current_account': None,
        'started_at': None,
        'last_sent_at': None,
        'error': None
    }


async def auto_send_loop(
    shop_id: int,
    target_channel_id: str,
    selected_account_ids: List[int],
    interval: int,
    db,
    bot_clients: List
):
    """
    è‡ªåŠ¨å‘é€å¾ªç¯ä»»åŠ¡

    :param shop_id: é€‰ä¸­çš„åº—é“ºIDï¼ˆç”¨äºä»æ•°æ®åº“æå•†å“ï¼‰
    :param target_channel_id: ç›®æ ‡ Discord é¢‘é“ ID
    :param selected_account_ids: ç”¨æˆ·å‹¾é€‰çš„ Account ID åˆ—è¡¨ [1, 2, 5]
    :param interval: å‘é€é—´éš”ï¼ˆç§’ï¼‰
    :param db: æ•°æ®åº“å®ä¾‹
    :param bot_clients: æœºå™¨äººå®¢æˆ·ç«¯åˆ—è¡¨
    """
    global task_status

    logger.info(f"å¯åŠ¨è‡ªåŠ¨å‘é€: åº—é“º{shop_id} -> é¢‘é“{target_channel_id}ï¼Œé—´éš”{interval}s")

    task_status['is_running'] = True
    task_status['shop_id'] = shop_id
    task_status['channel_id'] = target_channel_id
    task_status['started_at'] = datetime.now().isoformat()
    task_status['error'] = None

    try:
        # 1. è·å–è¯¥åº—é“ºæ‰€æœ‰å•†å“é“¾æ¥
        shop_info = db.get_shop_by_id(shop_id)
        if not shop_info:
            task_status['error'] = f"åº—é“º {shop_id} ä¸å­˜åœ¨"
            logger.error(task_status['error'])
            return

        shop_name = shop_info.get('name', '')

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, product_url, title, cnfans_url FROM products WHERE shop_name = ?",
                (shop_name,)
            )
            products = [dict(row) for row in cursor.fetchall()]

        if not products:
            task_status['error'] = f"åº—é“º '{shop_name}' æ²¡æœ‰å•†å“æ•°æ®ï¼Œè¯·å…ˆæ‰§è¡ŒæŠ“å–"
            logger.warning(task_status['error'])
            return

        task_status['total_products'] = len(products)
        logger.info(f"å¾…å‘é€å•†å“æ•°: {len(products)}")

        # 2. ç­›é€‰å‡ºå¯ç”¨çš„åœ¨çº¿ Bot å®¢æˆ·ç«¯
        active_bots = [
            client for client in bot_clients
            if hasattr(client, 'account_id')
            and client.account_id in selected_account_ids
            and client.is_ready()
            and not client.is_closed()
        ]

        if not active_bots:
            task_status['error'] = "æ²¡æœ‰é€‰ä¸­çš„è´¦å·åœ¨çº¿ï¼Œè¯·å…ˆå¯åŠ¨è´¦å·"
            logger.error(task_status['error'])
            return

        logger.info(f"å¯ç”¨è´¦å·æ•°: {len(active_bots)}")

        product_idx = 0
        bot_idx = 0

        # 3. å¾ªç¯å‘é€
        while not stop_sender_event.is_set():
            if product_idx >= len(products):
                logger.info("æ‰€æœ‰å•†å“å·²å‘é€å®Œæ¯•ï¼Œä»»åŠ¡ç»“æŸ")
                break

            # è·å–å½“å‰è¦å‘çš„å•†å“
            product = products[product_idx]
            link_to_send = product.get('cnfans_url') or product.get('product_url', '')
            title = product.get('title', 'æœªçŸ¥å•†å“')
            message_content = f"{title}\n{link_to_send}"

            # è·å–å½“å‰è½®æ¢çš„è´¦å· (Round Robin)
            current_bot = active_bots[bot_idx % len(active_bots)]

            task_status['current_product'] = title[:50]
            task_status['current_account'] = getattr(current_bot, 'user', None)
            if task_status['current_account']:
                task_status['current_account'] = str(task_status['current_account'])

            try:
                channel = current_bot.get_channel(int(target_channel_id))
                if channel:
                    await channel.send(message_content)
                    task_status['sent_count'] += 1
                    task_status['last_sent_at'] = datetime.now().isoformat()
                    logger.info(
                        f"âœ… è´¦å· {current_bot.user.name if current_bot.user else 'Unknown'} "
                        f"å‘é€æˆåŠŸ ({task_status['sent_count']}/{task_status['total_products']}): {title[:30]}..."
                    )
                else:
                    logger.error(
                        f"è´¦å· {current_bot.user.name if current_bot.user else 'Unknown'} "
                        f"æ‰¾ä¸åˆ°é¢‘é“ {target_channel_id}"
                    )
            except Exception as e:
                logger.error(f"å‘é€å¤±è´¥: {e}")
                # ç»§ç»­ä¸‹ä¸€æ¡ï¼Œä¸ä¸­æ–­ä»»åŠ¡

            # ç´¢å¼•é€’å¢
            product_idx += 1
            bot_idx += 1

            # ç­‰å¾…é—´éš”ï¼ˆæ”¯æŒéšæ—¶ä¸­æ–­ï¼‰
            try:
                await asyncio.wait_for(
                    stop_sender_event.wait(),
                    timeout=float(interval)
                )
                # å¦‚æœ wait è¿”å›äº†ï¼Œè¯´æ˜ event è¢« set äº†ï¼Œæ”¶åˆ°åœæ­¢ä¿¡å·
                logger.info("æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œä»»åŠ¡ä¸­æ–­")
                break
            except asyncio.TimeoutError:
                # è¶…æ—¶æ„å‘³ç€æ—¶é—´åˆ°äº†ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯
                continue

    except asyncio.CancelledError:
        logger.info("ä»»åŠ¡è¢«å–æ¶ˆ")
    except Exception as e:
        task_status['error'] = str(e)
        logger.error(f"è‡ªåŠ¨å‘é€ä»»åŠ¡å¼‚å¸¸: {e}")
    finally:
        task_status['is_running'] = False
        logger.info("è‡ªåŠ¨å‘é€ä»»åŠ¡ç»“æŸ")


def start_sending_task(
    shop_id: int,
    channel_id: str,
    account_ids: List[int],
    interval: int,
    db,
    bot_clients: List,
    bot_loop: asyncio.AbstractEventLoop
) -> Dict:
    """
    å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡ï¼ˆä» Flask çº¿ç¨‹è°ƒç”¨ï¼‰

    :param shop_id: åº—é“º ID
    :param channel_id: ç›®æ ‡é¢‘é“ ID
    :param account_ids: è´¦å· ID åˆ—è¡¨
    :param interval: å‘é€é—´éš”ï¼ˆç§’ï¼‰
    :param db: æ•°æ®åº“å®ä¾‹
    :param bot_clients: æœºå™¨äººå®¢æˆ·ç«¯åˆ—è¡¨
    :param bot_loop: Discord bot çš„äº‹ä»¶å¾ªç¯
    :return: æ“ä½œç»“æœ
    """
    global current_task, stop_sender_event

    if task_status['is_running']:
        return {'success': False, 'error': 'å·²æœ‰ä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œè¯·å…ˆåœæ­¢'}

    # é‡ç½®åœæ­¢äº‹ä»¶
    stop_sender_event.clear()
    reset_task_status()

    # åœ¨ bot çš„äº‹ä»¶å¾ªç¯ä¸­åˆ›å»ºä»»åŠ¡
    try:
        future = asyncio.run_coroutine_threadsafe(
            auto_send_loop(
                shop_id=shop_id,
                target_channel_id=channel_id,
                selected_account_ids=account_ids,
                interval=interval,
                db=db,
                bot_clients=bot_clients
            ),
            bot_loop
        )
        logger.info("è‡ªåŠ¨å‘é€ä»»åŠ¡å·²æäº¤åˆ°äº‹ä»¶å¾ªç¯")
        return {'success': True, 'message': 'è‡ªåŠ¨å‘é€ä»»åŠ¡å·²å¯åŠ¨'}
    except Exception as e:
        logger.error(f"å¯åŠ¨ä»»åŠ¡å¤±è´¥: {e}")
        return {'success': False, 'error': str(e)}


def stop_sending_task() -> Dict:
    """
    åœæ­¢è‡ªåŠ¨å‘é€ä»»åŠ¡

    :return: æ“ä½œç»“æœ
    """
    global stop_sender_event

    if not task_status['is_running']:
        return {'success': False, 'error': 'å½“å‰æ²¡æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡'}

    stop_sender_event.set()
    logger.info("å·²å‘é€åœæ­¢ä¿¡å·")
    return {'success': True, 'message': 'ä»»åŠ¡åœæ­¢æŒ‡ä»¤å·²å‘é€'}

===== backend/bot.py =====
import discord
import aiohttp
import logging
import time
import asyncio
import random
import os
import json
import io
import sqlite3
from datetime import datetime
try:
    from config import config
except ImportError:
    from .config import config

# å…¨å±€å˜é‡ç”¨äºå¤šè´¦å·æœºå™¨äººç®¡ç†
bot_clients = []
bot_tasks = []

# å…¨å±€å†·å´ç®¡ç†å™¨ï¼š(account_id, channel_id) -> timestamp (ä¸Šæ¬¡å‘é€æ—¶é—´)
account_last_sent = {}

# ã€æ–°å¢ã€‘AIå¹¶å‘é™åˆ¶ï¼šæœ€å¤šåŒæ—¶2ä¸ªAIæ¨ç†ä»»åŠ¡ï¼Œé˜²æ­¢CPUé¥±å’Œå¯¼è‡´Flaské˜»å¡
ai_concurrency_limit = asyncio.Semaphore(2)


def get_all_cooldowns():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„å†·å´çŠ¶æ€ï¼ˆä¾› API æŸ¥è¯¢ï¼‰"""
    current_time = time.time()
    cooldowns = []

    snapshot = account_last_sent.copy()

    for key, last_sent in snapshot.items():
        try:
            acc_id, ch_id = key
            time_passed = current_time - last_sent

            if time_passed < 86400:
                cooldowns.append({
                    'account_id': int(acc_id),
                    'channel_id': str(ch_id),
                    'last_sent': last_sent,
                    'time_passed': time_passed
                })
        except Exception:
            continue

    return cooldowns

def is_account_on_cooldown(account_id, channel_id, interval):
    """æ£€æŸ¥è´¦å·åœ¨æŒ‡å®šé¢‘é“æ˜¯å¦åœ¨å†·å´ä¸­"""
    key = (int(account_id), str(channel_id))

    last = account_last_sent.get(key, 0)
    time_passed = time.time() - last
    is_cooldown = time_passed < interval

    if is_cooldown:
        logger.info(f"â„ï¸ [å†·å´ä¸­] è´¦å·ID:{account_id} é¢‘é“:{channel_id} | å‰©ä½™: {interval - time_passed:.1f}ç§’")

    return is_cooldown

def set_account_cooldown(account_id, channel_id):
    """è®¾ç½®è´¦å·åœ¨æŒ‡å®šé¢‘é“çš„å†·å´æ—¶é—´"""
    key = (int(account_id), str(channel_id))
    account_last_sent[key] = time.time()
    logger.info(f"ğŸ”¥ [è®¾ç½®å†·å´] è´¦å·ID:{account_id} é¢‘é“:{channel_id} | Key: {key}")

def cleanup_expired_cooldowns():
    """æ¸…ç†è¿‡æœŸçš„å†·å´çŠ¶æ€"""
    current_time = time.time()
    expired_keys = []
    for key, last_sent in account_last_sent.items():
        # å¦‚æœå†·å´æ—¶é—´è¶…è¿‡24å°æ—¶ï¼Œæ¸…ç†æ‰ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
        if current_time - last_sent > 86400:  # 24å°æ—¶
            expired_keys.append(key)

    for key in expired_keys:
        del account_last_sent[key]
        logger.debug(f"æ¸…ç†è¿‡æœŸå†·å´: {key}")

    if expired_keys:
        logger.info(f"æ¸…ç†äº† {len(expired_keys)} ä¸ªè¿‡æœŸçš„å†·å´çŠ¶æ€")

def mark_message_as_processed(message_id):
    """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å¤„ç†ï¼ˆåŸå­æ“ä½œï¼‰"""
    try:
        from database import db
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO processed_messages (message_id) VALUES (?)", (str(message_id),))
            conn.commit()
        return True  # æŠ¢é”æˆåŠŸ
    except sqlite3.IntegrityError:
        return False  # å·²ç»è¢«å…¶ä»–BotæŠ¢é”

def get_response_url_for_channel(product, channel_id, user_id=None):
    """æ ¹æ®é¢‘é“IDå’Œç½‘ç«™é…ç½®å†³å®šå‘é€å“ªä¸ªé“¾æ¥"""
    import re
    try:
        from database import db
    except ImportError:
        from .database import db

    channel_id_str = str(channel_id)

    # 1. é¦–å…ˆå°è¯•æ ¹æ®é¢‘é“ç»‘å®šè·å–ç½‘ç«™é…ç½®
    website_config = db.get_website_config_by_channel(channel_id_str, user_id)

    if website_config and website_config.get('url_template'):
        # ä»å•†å“URLä¸­æå–å¾®åº—ID
        weidian_url = product.get('weidianUrl') or product.get('product_url') or ''
        weidian_id = None

        # å°è¯•ä»URLä¸­æå–itemID
        match = re.search(r'itemID=(\d+)', weidian_url)
        if match:
            weidian_id = match.group(1)
        else:
            # å°è¯•ä»weidianIdå­—æ®µè·å–
            weidian_id = product.get('weidianId')

        if weidian_id:
            # ä½¿ç”¨URLæ¨¡æ¿ç”Ÿæˆé“¾æ¥
            url = website_config['url_template'].replace('{id}', weidian_id)
            logger.info(f"ä½¿ç”¨ç½‘ç«™é…ç½® '{website_config['name']}' çš„URLæ¨¡æ¿ç”Ÿæˆé“¾æ¥: {url[:50]}...")
            return url

    # 2. å›é€€åˆ°æ—§çš„ç¡¬ç¼–ç é€»è¾‘ï¼ˆå…¼å®¹æ€§ï¼‰
    if config.CNFANS_CHANNEL_ID and channel_id_str == config.CNFANS_CHANNEL_ID:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        elif product.get('acbuyUrl'):
            return product['acbuyUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    elif config.ACBUY_CHANNEL_ID and channel_id_str == config.ACBUY_CHANNEL_ID:
        if product.get('acbuyUrl'):
            return product['acbuyUrl']
        elif product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    # 3. é»˜è®¤å‘é€CNFansé“¾æ¥
    else:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

class HTTPLogHandler(logging.Handler):
    """é€šè¿‡HTTPå‘é€æ—¥å¿—åˆ°Flaskåº”ç”¨"""
    def __init__(self):
        super().__init__()
        self.pending_logs = []
        self.is_sending = False

    def emit(self, record):
        try:
            if record.name.startswith('werkzeug'):
                return
            if record.module == 'app' and record.funcName == 'add_log':
                return
            message = record.getMessage()
            if message.startswith('BOT_LOG'):
                return
            # åªå‘é€æˆ‘ä»¬å…³å¿ƒçš„æ—¥å¿—çº§åˆ«
            if record.levelno >= logging.INFO:
                log_data = {
                    'timestamp': datetime.now().isoformat(),
                    'level': record.levelname,
                    'message': message,
                    'module': record.module,
                    'func': record.funcName
                }

                # æ·»åŠ åˆ°å¾…å‘é€é˜Ÿåˆ—
                self.pending_logs.append(log_data)

                # å¦‚æœæ²¡æœ‰æ­£åœ¨å‘é€ï¼Œå¯åŠ¨å‘é€ä»»åŠ¡
                if not self.is_sending:
                    # åœ¨æœºå™¨äººçš„äº‹ä»¶å¾ªç¯ä¸­åˆ›å»ºä»»åŠ¡
                    try:
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            loop.create_task(self.send_pending_logs())
                        else:
                            # å¦‚æœå¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥å‘é€ï¼ˆåŒæ­¥æ–¹å¼ï¼‰
                            self.send_sync(log_data)
                    except RuntimeError:
                        # æ²¡æœ‰äº‹ä»¶å¾ªç¯ï¼Œç›´æ¥åŒæ­¥å‘é€
                        self.send_sync(log_data)

        except Exception as e:
            print(f"HTTPæ—¥å¿—å¤„ç†å™¨é”™è¯¯: {e}")

    def send_sync(self, log_data):
        """åŒæ­¥å‘é€æ—¥å¿—ï¼ˆä½œä¸ºfallbackï¼‰"""
        try:
            import requests
            # ã€ä¿®å¤ã€‘å¼ºåˆ¶ä½¿ç”¨ 127.0.0.1ï¼Œå› ä¸ºè¿™æ˜¯è¿›ç¨‹é—´é€šä¿¡ï¼Œä¸åº”èµ°å…¬ç½‘
            local_api_url = 'http://127.0.0.1:5001/api'
            response = requests.post(f'{local_api_url}/logs/add',
                                   json=log_data, timeout=2, proxies={'http': None, 'https': None, 'all': None})
            if response.status_code != 200:
                print(f"åŒæ­¥å‘é€æ—¥å¿—å¤±è´¥: {response.status_code}")
        except Exception as e:
            # è¿™é‡Œçš„ print å¯èƒ½ä¼šè¢«é‡å®šå‘ï¼Œä½†è‡³å°‘ä¸ä¼šæŠ›å‡º ConnectionRefusedError ç‚¸æ–­æµç¨‹
            pass

    async def send_pending_logs(self):
        """å¼‚æ­¥å‘é€å¾…å¤„ç†çš„æ—¥å¿—"""
        if self.is_sending:
            return

        self.is_sending = True

        # ã€ä¿®å¤ã€‘å¼ºåˆ¶ä½¿ç”¨ 127.0.0.1
        local_api_url = 'http://127.0.0.1:5001/api'

        try:
            while self.pending_logs:
                log_data = self.pending_logs.pop(0)

                try:
                    async with aiohttp.ClientSession(trust_env=False) as session:
                        async with session.post(f'{local_api_url}/logs/add',
                                              json=log_data, timeout=aiohttp.ClientTimeout(total=2)) as resp:
                            if resp.status != 200:
                                print(f"å‘é€æ—¥å¿—å¤±è´¥: {resp.status}")
                except Exception as e:
                    # é˜Ÿåˆ—æ»¡äº†å°±ä¸¢å¼ƒï¼Œä¸è¦æ— é™å †ç§¯
                    if len(self.pending_logs) < 1000:
                        self.pending_logs.insert(0, log_data)
                    break

                # å°å»¶è¿Ÿé¿å…å‘é€å¤ªå¿«
                await asyncio.sleep(0.01) # åŠ å¿«å‘é€é€Ÿåº¦ï¼Œå‡å°‘ç§¯å‹

        finally:
            self.is_sending = False

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)

# æ·»åŠ HTTPæ—¥å¿—å¤„ç†å™¨
http_handler = HTTPLogHandler()
http_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(http_handler)

logger = logging.getLogger(__name__)

# ç¡®ä¿discordåº“ä¹Ÿä½¿ç”¨æˆ‘ä»¬çš„æ—¥å¿—é…ç½®
logging.getLogger('discord').setLevel(logging.INFO)

class DiscordBotClient(discord.Client):
    # ã€æ–°å¢ã€‘é¢‘é“ç™½åå•ç¼“å­˜ï¼ˆç±»çº§åˆ«å…±äº«ï¼Œæ‰€æœ‰Botå®ä¾‹å…±ç”¨ï¼‰
    _bound_channels_cache = set()  # å·²ç»‘å®šçš„é¢‘é“IDé›†åˆ
    _last_cache_update = 0  # ä¸Šæ¬¡ç¼“å­˜æ›´æ–°æ—¶é—´æˆ³
    _cache_ttl = 60  # ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰

    def __init__(self, account_id=None, user_id=None, user_shops=None, role='both'):
        # discord.py-self å¯èƒ½ä¸éœ€è¦ intentsï¼Œæˆ–è€…ä½¿ç”¨ä¸åŒçš„è¯­æ³•
        try:
            # å°è¯•ä½¿ç”¨æ ‡å‡†çš„ intents
            intents = discord.Intents.default()
            intents.message_content = True
            intents.messages = True
            intents.guilds = True
            super().__init__(intents=intents)
        except AttributeError:
            # å¦‚æœ Intents ä¸å­˜åœ¨ï¼Œç›´æ¥åˆå§‹åŒ–ï¼ˆdiscord.py-self å¯èƒ½ä¸éœ€è¦ï¼‰
            super().__init__()
        self.current_token = None
        self.running = False
        self.account_id = account_id
        self.user_id = user_id  # ç”¨æˆ·IDï¼Œç”¨äºè·å–ä¸ªæ€§åŒ–è®¾ç½®
        self.user_shops = user_shops  # ç”¨æˆ·ç®¡ç†çš„åº—é“ºåˆ—è¡¨
        self.role = role  # 'listener', 'sender', 'both' - è´¦å·è§’è‰²

    async def _refresh_channel_cache(self):
        """ã€æ–°å¢ã€‘åˆ·æ–°é¢‘é“ç™½åå•ç¼“å­˜ï¼ˆ60ç§’TTLï¼‰

        ä»æ•°æ®åº“è·å–æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDï¼Œæ›´æ–°ç±»çº§åˆ«ç¼“å­˜ã€‚
        ä½¿ç”¨TTLæœºåˆ¶é¿å…é¢‘ç¹æŸ¥è¯¢æ•°æ®åº“ã€‚
        """
        current_time = time.time()

        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
        if current_time - DiscordBotClient._last_cache_update < DiscordBotClient._cache_ttl:
            return  # ç¼“å­˜ä»ç„¶æœ‰æ•ˆï¼Œæ— éœ€åˆ·æ–°

        try:
            # åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢ï¼ˆé¿å…é˜»å¡äº‹ä»¶å¾ªç¯ï¼‰
            try:
                from database import db
            except ImportError:
                from .database import db

            channel_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_all_bound_channel_ids
            )

            # æ›´æ–°ç±»çº§åˆ«ç¼“å­˜
            DiscordBotClient._bound_channels_cache = channel_ids
            DiscordBotClient._last_cache_update = current_time

            logger.debug(f"âœ… é¢‘é“ç™½åå•ç¼“å­˜å·²åˆ·æ–°ï¼Œå…± {len(channel_ids)} ä¸ªé¢‘é“")

        except Exception as e:
            logger.error(f"âŒ åˆ·æ–°é¢‘é“ç™½åå•ç¼“å­˜å¤±è´¥: {e}")
            # å¤±è´¥æ—¶ä¸æ›´æ–°æ—¶é—´æˆ³ï¼Œä¸‹æ¬¡ä¼šé‡è¯•

    async def schedule_reply(self, message, product, custom_reply=None):
        """è°ƒåº¦å›å¤åˆ°åˆé€‚çš„å‘é€è´¦å· (å¢å¼ºç‰ˆï¼šå¸¦è¯¦ç»†çŠ¶æ€è¯Šæ–­)"""

        try:
            # æ¸…ç†è¿‡æœŸçš„å†·å´çŠ¶æ€
            cleanup_expired_cooldowns()

            try:
                from database import db
            except ImportError:
                from .database import db

            # è·å–ç”¨æˆ·è®¾ç½®ä»¥ç¡®å®šå»¶è¿Ÿæ—¶é—´
            user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
            min_delay = user_settings.get('global_reply_min_delay', 3.0)
            max_delay = user_settings.get('global_reply_max_delay', 8.0)

            # ç”Ÿæˆå›å¤å†…å®¹
            response_content = self._generate_reply_content(product, message.channel.id, custom_reply)

            # 1. å°è¯•è·å–ç½‘ç«™é…ç½®ï¼ˆå¿…é¡»ç»‘å®šï¼Œå¦åˆ™ä¸å›å¤ï¼‰
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            if not website_config:
                logger.info(f"é¢‘é“ {message.channel.id} æœªç»‘å®šç½‘ç«™é…ç½®ï¼Œè·³è¿‡å›å¤")
                return

            target_client = None

            # 2. è·å–æ•°æ®åº“é…ç½®çš„å‘é€è€… ID
            db_sender_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_senders, website_config['id']
            )

            if not db_sender_ids:
                logger.warning(
                    f"âŒ [é…ç½®é”™è¯¯] ç½‘ç«™é…ç½® '{website_config.get('name')}' æœªç»‘å®šä»»ä½•ã€å‘é€ã€‘è´¦å·ã€‚è¯·åœ¨ç½‘ç«™é…ç½®ä¸­ç»‘å®šè´¦å·ã€‚"
                )
                return

            # === è·å–å½“å‰çœŸæ­£åœ¨çº¿çš„æœºå™¨äººè´¦å· ID ===
            online_client_ids = [c.account_id for c in bot_clients if c.is_ready() and not c.is_closed()]

            # è°ƒè¯•ä¿¡æ¯ï¼šæ‰“å°å½“å‰çŠ¶æ€
            logger.info(f"é…ç½®è´¦å·ID: {db_sender_ids} | åœ¨çº¿è´¦å·ID: {online_client_ids}")

            # å–äº¤é›†ï¼šæ—¢åœ¨æ•°æ®åº“é…ç½®äº†ï¼Œåˆæ˜¯å½“å‰åœ¨çº¿çš„
            valid_senders = [uid for uid in db_sender_ids if uid in online_client_ids]

            if not valid_senders:
                logger.warning("âŒ [çŠ¶æ€é”™è¯¯] é…ç½®çš„å‘é€è´¦å·å‡ä¸åœ¨çº¿ã€‚è¯·æ£€æŸ¥ Discord è´¦å·è¿æ¥çŠ¶æ€ã€‚")
                return

            # 3. è½®æ¢/å†·å´é€»è¾‘ - ä½¿ç”¨ç”¨æˆ·çº§åˆ«è®¾ç½®
            # ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é…ç½®
            rotation_enabled = website_config.get('rotation_enabled', 1)
            rotation_interval = website_config.get('rotation_interval', 180)

            if self.user_id and website_config.get('id'):
                user_website_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_website_settings, self.user_id, website_config['id']
                )
                if user_website_settings:
                    rotation_enabled = user_website_settings.get('rotation_enabled', rotation_enabled)
                    rotation_interval = user_website_settings.get('rotation_interval', rotation_interval)
                    logger.info(f"ğŸ“‹ ä½¿ç”¨ç”¨æˆ·çº§åˆ«è®¾ç½®: rotation_interval={rotation_interval}ç§’, rotation_enabled={rotation_enabled}")

            available_senders = []

            if rotation_enabled:
                # ç­›é€‰éå†·å´çš„ï¼ˆæŒ‰é¢‘é“åŒºåˆ†å†·å´ï¼‰
                available_senders = [
                    uid for uid in valid_senders
                    if not is_account_on_cooldown(uid, message.channel.id, rotation_interval)
                ]

                # åªæœ‰ valid_senders æœ‰å€¼ä½† available_senders ä¸ºç©ºï¼Œæ‰æ˜¯çœŸæ­£çš„â€œå†·å´ä¸­â€
                if not available_senders:
                    logger.info(
                        f"â³ [å†·å´ä¸­] é¢‘é“ {message.channel.id} æ‰€æœ‰åœ¨çº¿è´¦å· ({len(valid_senders)}ä¸ª) "
                        f"å‡å¤„äº {rotation_interval}ç§’ å†·å´æœŸå†…ï¼Œè·³è¿‡å‘é€"
                    )
                    return

            else:
                available_senders = valid_senders

            # 4. é€‰ä¸­ä¸€ä¸ª ID
            if available_senders:
                selected_id = random.choice(available_senders)
                target_client = next((c for c in bot_clients if c.account_id == selected_id), None)
                logger.info(
                    f"âœ… æœ¬æ¬¡é€‰ä¸­å‘é€è´¦å·: {target_client.user.name if target_client else selected_id} (ID: {selected_id})"
                )
            else:
                logger.warning("âŒ é€»è¾‘å¼‚å¸¸ï¼šæœ‰ valid_senders ä½†æ— å¯ç”¨å‘é€è´¦å·")
                return

            # 5. æ‰§è¡Œå‘é€
            if target_client:
                try:
                    target_channel = target_client.get_channel(message.channel.id)

                    if target_channel:
                        async with target_channel.typing():
                            await asyncio.sleep(random.uniform(min_delay, max_delay))

                        # ã€å…³é”®ä¿®å¤ã€‘
                        # ä¸è¦ä½¿ç”¨ message.reply()ï¼Œå› ä¸º message ç»‘å®šçš„æ˜¯ç›‘å¬è€…(Listener)å®¢æˆ·ç«¯
                        # å¿…é¡»ç”¨ target_channel.send(..., reference=message) æ‰ä¼šä½¿ç”¨ target_client(Sender) çš„ token
                        try:
                            # === 1. æ”¶é›†æ‰€æœ‰è¦å‘é€çš„å›¾ç‰‡æ–‡ä»¶ ===
                            files = []

                            # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰æ¨¡å¼ï¼Œä¸”æœ‰å›¾ç‰‡
                            is_custom_mode = custom_reply and (
                                custom_reply.get('reply_type') == 'custom_only' or
                                custom_reply.get('reply_type') == 'text'
                            )

                            if is_custom_mode:
                                # è·å–å›¾ç‰‡ä¿¡æ¯
                                # æ³¨æ„ï¼šå¦‚æœæ˜¯ä» search_similar_text è¿”å›çš„ productï¼Œå­—æ®µåå¯èƒ½å·²ç»æ ¼å¼åŒ–
                                # éœ€è¦å…¼å®¹å¤„ç†

                                # 1. å°è¯•è·å–è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥
                                custom_urls = product.get('customImageUrls', []) or product.get('custom_image_urls', [])
                                if isinstance(custom_urls, str):
                                    try:
                                        custom_urls = json.loads(custom_urls)
                                    except:
                                        custom_urls = []

                                image_source = product.get('imageSource') or product.get('image_source') or 'product'

                                # æ”¶é›†å›¾ç‰‡æ–‡ä»¶ï¼ˆDiscordé™åˆ¶æœ€å¤š10ä¸ªæ–‡ä»¶ï¼‰
                                if image_source == 'custom' and custom_urls:
                                    for url in custom_urls[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                        if len(files) >= 10:
                                            break
                                        try:
                                            async with aiohttp.ClientSession() as session:
                                                async with session.get(url) as resp:
                                                    if resp.status == 200:
                                                        data = await resp.read()
                                                        filename = url.split('/')[-1] or 'image.jpg'
                                                        files.append(discord.File(io.BytesIO(data), filename))
                                        except Exception as e:
                                            logger.error(f"ä¸‹è½½è‡ªå®šä¹‰å›¾ç‰‡å¤±è´¥: {e}")

                                elif image_source == 'upload':
                                    # å¤„ç†ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡
                                    pid = product.get('id')

                                    # ä» uploaded_reply_images å­—æ®µè·å–ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶ååˆ—è¡¨
                                    uploaded_filenames = product.get('uploaded_reply_images', [])
                                    if isinstance(uploaded_filenames, str):
                                        try:
                                            uploaded_filenames = json.loads(uploaded_filenames)
                                        except:
                                            # å¦‚æœè§£æå¤±è´¥ï¼Œä¸”å®ƒæœ¬èº«å°±æ˜¯åˆ—è¡¨ï¼Œåˆ™ä¿æŒåŸæ ·ï¼Œå¦åˆ™ç½®ç©º
                                            uploaded_filenames = uploaded_filenames if isinstance(uploaded_filenames, list) else []

                                    if pid and uploaded_filenames:
                                        # ä½¿ç”¨æ–°çš„APIç«¯ç‚¹è·å–ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡
                                        for filename in uploaded_filenames[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/custom_reply_image/{pid}/{filename}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), filename))
                                            except Exception as e:
                                                logger.error(f"ä¸‹è½½ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡å¤±è´¥: {e}")

                                elif image_source == 'product':
                                    # å¤„ç†å•†å“å›¾é›†ä¸­çš„å›¾ç‰‡
                                    pid = product.get('id')
                                    indexes = product.get('selectedImageIndexes', []) or product.get('custom_reply_images', [])

                                    if isinstance(indexes, str):
                                        try:
                                            indexes = json.loads(indexes)
                                        except:
                                            indexes = []

                                    if pid and indexes:
                                        # ä½¿ç”¨åŸæœ‰çš„APIç«¯ç‚¹è·å–å•†å“å›¾é›†ä¸­çš„å›¾ç‰‡
                                        for idx in indexes[:10]:  # é™åˆ¶æœ€å¤š10å¼ 
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/image/{pid}/{idx}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), f"{pid}_{idx}.jpg"))
                                            except Exception as e:
                                                logger.error(f"ä¸‹è½½å•†å“å›¾ç‰‡å¤±è´¥: {e}")

                            # === 2. å‘é€æ–‡å­—å’Œæ‰€æœ‰å›¾ç‰‡ï¼ˆåˆå¹¶ä¸ºä¸€æ¡æ¶ˆæ¯ï¼‰ ===
                            if not response_content and not files:
                                logger.warning(
                                    f"âš ï¸ æ— å¯å‘é€å†…å®¹: å•†å“ID={product.get('id')}ï¼Œæœªç”Ÿæˆæ–‡å­—ä¸”æ— å›¾ç‰‡"
                                )
                                return

                            await target_channel.send(
                                content=response_content if response_content else None,
                                files=files if files else None,
                                reference=message,
                                mention_author=True
                            )

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"âœ… [å›å¤æˆåŠŸ] çœŸå®å‘é€è´¦å·: {target_client.user.name} (ID: {target_client.account_id}) | å•†å“ID: {product.get('id')} | å›¾ç‰‡æ•°é‡: {len(files)}"
                            )

                        except Exception as reply_error:
                            logger.warning(f"å›å¤å¤±è´¥ï¼Œå°è¯•ç›´æ¥å‘é€: {reply_error}")
                            if response_content:
                                await target_channel.send(response_content)

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"âœ… [å‘é€æˆåŠŸ] çœŸå®å‘é€è´¦å·: {target_client.user.name} | å•†å“ID: {product.get('id')}"
                            )

                    else:
                        logger.warning(
                            f"âŒ é€‰ä¸­çš„è´¦å· {target_client.user.name} æ— æ³•è®¿é—®é¢‘é“ {message.channel.id} (å¯èƒ½ä¸åœ¨è¯¥æœåŠ¡å™¨)"
                        )
                        return

                except Exception as e:
                    logger.error(f"âŒ å‘é€å¼‚å¸¸: {e}")

        except Exception as e:
            logger.error(f"âŒ ä¸¥é‡é”™è¯¯: {e}")

    def _generate_reply_content(self, product, channel_id, custom_reply=None):
        """ç”Ÿæˆå›å¤å†…å®¹"""
        if custom_reply:
            reply_type = custom_reply.get('reply_type')

            if reply_type == 'custom_only':
                # åªå‘é€è‡ªå®šä¹‰å†…å®¹ï¼Œä¸å‘é€é“¾æ¥
                return custom_reply.get('content', '')

            elif reply_type == 'text_and_link':
                # å‘é€æ–‡å­— + é“¾æ¥
                response = get_response_url_for_channel(product, channel_id, self.user_id)
                return f"{custom_reply.get('content', '')}\n{response}".strip()

            elif reply_type == 'text':
                # åªå‘é€æ–‡å­—
                return custom_reply.get('content', '')

        # é»˜è®¤è¡Œä¸ºï¼šå‘é€é“¾æ¥
        return get_response_url_for_channel(product, channel_id, self.user_id)

    def get_website_config_by_channel(self, channel_id):
        """æ ¹æ®é¢‘é“IDè·å–å¯¹åº”çš„ç½‘ç«™é…ç½®"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # æŸ¥è¯¢é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            configs = db.get_website_configs()
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"è·å–é¢‘é“ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    async def get_website_config_by_channel_async(self, channel_id):
        """å¼‚æ­¥ç‰ˆæœ¬ï¼šæ ¹æ®é¢‘é“IDè·å–å¯¹åº”çš„ç½‘ç«™é…ç½®"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # å¼‚æ­¥æŸ¥è¯¢é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            configs = await asyncio.get_event_loop().run_in_executor(None, db.get_website_configs)
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"å¼‚æ­¥è·å–é¢‘é“ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    def _should_filter_message(self, message):
        """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åº”è¯¥è¢«è¿‡æ»¤"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 1. æ£€æŸ¥å…¨å±€æ¶ˆæ¯è¿‡æ»¤è§„åˆ™
            filters = db.get_message_filters()
            message_content = message.content.lower()

            for filter_rule in filters:
                filter_value = filter_rule['filter_value'].lower()
                filter_type = filter_rule['filter_type']

                if filter_type == 'contains':
                    if filter_value in message_content:
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å« "{filter_value}"')
                        return True
                elif filter_type == 'starts_with':
                    if message_content.startswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" å¼€å¤´')
                        return True
                elif filter_type == 'ends_with':
                    if message_content.endswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" ç»“å°¾')
                        return True
                elif filter_type == 'regex':
                    import re
                    try:
                        if re.search(filter_value, message_content, re.IGNORECASE):
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ¹é…æ­£åˆ™ "{filter_value}"')
                            return True
                    except re.error:
                        logger.warning(f'æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: {filter_value}')
                elif filter_type == 'user_id':
                    # æ£€æŸ¥ç”¨æˆ·IDè¿‡æ»¤
                    filter_user_ids = [uid.strip() for uid in filter_value.split(',') if uid.strip()]
                    sender_id = str(message.author.id)
                    sender_name = str(message.author.name).lower()

                    for blocked_id in filter_user_ids:
                        blocked_id = blocked_id.strip()
                        if blocked_id == sender_id or blocked_id.lower() in sender_name:
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} (ID: {sender_id}) åœ¨è¿‡æ»¤åˆ—è¡¨ä¸­')
                            return True

            # 2. æ£€æŸ¥ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®çš„è¿‡æ»¤è§„åˆ™
            if self.user_id:
                user_settings = db.get_user_settings(self.user_id)
                if user_settings:
                    # æ£€æŸ¥ç”¨æˆ·é»‘åå•
                    user_blacklist = user_settings.get('user_blacklist', '')
                    if user_blacklist:
                        blacklist_users = [u.strip().lower() for u in user_blacklist.split(',') if u.strip()]
                        sender_name = str(message.author.name).lower()
                        sender_id = str(message.author.id).lower()

                        for blocked_user in blacklist_users:
                            blocked_user = blocked_user.lower()
                            if blocked_user in sender_name or blocked_user == sender_id:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} åœ¨é»‘åå•ä¸­')
                                return True

                    # æ£€æŸ¥å…³é”®è¯è¿‡æ»¤
                    keyword_filters = user_settings.get('keyword_filters', '')
                    if keyword_filters:
                        filter_keywords = [k.strip().lower() for k in keyword_filters.split(',') if k.strip()]

                        for keyword in filter_keywords:
                            if keyword in message_content:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å«å…³é”®è¯ "{keyword}"')
                                return True

        except Exception as e:
            logger.error(f'æ£€æŸ¥æ¶ˆæ¯è¿‡æ»¤å¤±è´¥: {e}')

        return False

    def _get_custom_reply(self):
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            replies = db.get_custom_replies()

            if replies:
                # è¿”å›ä¼˜å…ˆçº§æœ€é«˜çš„æ´»è·ƒå›å¤
                return replies[0]
        except Exception as e:
            logger.error(f'è·å–è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}')

        return None

    async def on_ready(self):
        logger.info(f'Discordæœºå™¨äººå·²ç™»å½•: {self.user} (ID: {self.user.id})')
        logger.info(f'æœºå™¨äººå·²å°±ç»ªï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯')
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            bound_channels = await asyncio.get_event_loop().run_in_executor(None, db.get_all_bound_channel_ids)
            if bound_channels:
                bound_list = sorted(bound_channels)
                preview = ", ".join(bound_list[:5])
                suffix = " ..." if len(bound_list) > 5 else ""
                logger.info(f'ç›‘å¬é¢‘é“: å·²ç»‘å®š {len(bound_list)} ä¸ª ({preview}{suffix})')
            else:
                logger.info('ç›‘å¬é¢‘é“: æœªç»‘å®šé¢‘é“')
        except Exception as e:
            logger.error(f'è·å–ç›‘å¬é¢‘é“å¤±è´¥: {e}')
        self.running = True

        # æ›´æ–°æ•°æ®åº“ä¸­çš„è´¦å·çŠ¶æ€ä¸ºåœ¨çº¿
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            if hasattr(self, 'account_id'):
                db.update_account_status(self.account_id, 'online')
                logger.info(f'è´¦å· {self.account_id} çŠ¶æ€å·²æ›´æ–°ä¸ºåœ¨çº¿')
        except Exception as e:
            logger.error(f'æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}')

    async def on_message(self, message):
        if not self.running:
            return

        # å¿½ç•¥è‡ªå·±çš„æ¶ˆæ¯
        if message.author == self.user:
            return

        # å¿½ç•¥æœºå™¨äººå’Œwebhookçš„æ¶ˆæ¯
        if message.author.bot or message.webhook_id:
            return

        # 1. å¿½ç•¥ @åˆ«äººçš„ä¿¡æ¯
        if message.mentions:
            return

        # 2. å¿½ç•¥å›å¤åˆ«äººçš„ä¿¡æ¯
        if message.reference is not None:
            return

        # 3. è§’è‰²è¿‡æ»¤ï¼šçº¯ sender è´¦å·å®Œå…¨ä¸å¤„ç†æ¶ˆæ¯
        if self.role == 'sender':
            return

        # =================================================================
        # ã€æ ¸å¿ƒä¿®å¤ã€‘å…ˆæ£€æŸ¥ï¼šè¿™æ¡æ¶ˆæ¯æ‰€åœ¨çš„é¢‘é“ï¼Œæ˜¯å¦å½’å½“å‰è´¦å·"ç›‘å¬"ï¼Ÿ
        # =================================================================
        try:
            # å¼‚æ­¥è·å–è¯¥é¢‘é“ç»‘å®šçš„ç½‘ç«™é…ç½®
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            # å¦‚æœè¿™ä¸ªé¢‘é“æ²¡æœ‰ç»‘å®šä»»ä½•é…ç½®ï¼Œç›´æ¥å¿½ç•¥
            if not website_config:
                # logger.debug(f"é¢‘é“ {message.channel.id} æœªç»‘å®šé…ç½®ï¼Œè´¦å· {self.account_id} å¿½ç•¥æ­¤æ¶ˆæ¯")
                return

            # è¿›ä¸€æ­¥æ£€æŸ¥ï¼šå½“å‰è´¦å·æ˜¯å¦æ˜¯è¯¥é…ç½®çš„åˆæ³•ç›‘å¬è€…ï¼Ÿ
            # è¿™æ˜¯ä¸€ä¸ªå…³é”®æ­¥éª¤ï¼Œé˜²æ­¢æœªç»‘å®šçš„è´¦å·å¤„ç†å·²ç»‘å®šé¢‘é“çš„æ¶ˆæ¯
            try:
                from database import db
            except ImportError:
                from .database import db

            # è·å–è¯¥ç½‘ç«™é…ç½®ç»‘å®šçš„æ‰€æœ‰ç›‘å¬è€…ID
            listener_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_listeners, website_config['id']
            )

            # å¦‚æœå½“å‰è´¦å·ä¸åœ¨ç›‘å¬åˆ—è¡¨ä¸­ï¼Œç›´æ¥å¿½ç•¥
            if self.account_id not in listener_ids:
                # logger.debug(f"è´¦å· {self.account_id} ä¸æ˜¯é¢‘é“ {message.channel.id} çš„ç›‘å¬è€…ï¼Œå¿½ç•¥")
                return

        except Exception as e:
            logger.error(f"æ£€æŸ¥é¢‘é“ç»‘å®šæƒé™å¤±è´¥: {e}")
            return

        # =================================================================
        # ã€æ ¸å¿ƒä¿®å¤ã€‘ç¡®è®¤æˆ‘æœ‰èµ„æ ¼å¤„ç†åï¼Œå†æŠ¢å…¨å±€é”
        # =================================================================
        try:
            if not mark_message_as_processed(message.id):
                logger.info(f"æ¶ˆæ¯ {message.id} å·²è¢«å…¶ä»–(åˆæ³•çš„)Botå¤„ç†ï¼Œè·³è¿‡")
                return
        except Exception as e:
            logger.error(f"æ¶ˆæ¯å»é‡æ£€æŸ¥å¤±è´¥: {e}")
            return

        # 4. è§¦å‘å†…å®¹è¿‡æ»¤è§„åˆ™
        if self._should_filter_message(message):
            return

        logger.info(f'ğŸ“¨ [æ¥æ”¶] è´¦å·:{self.user.name} | é¢‘é“:{message.channel.name} | å†…å®¹: "{message.content[:50]}..."')

        # è·å–ç”¨æˆ·è®¾ç½®
        keyword_reply_enabled = True
        image_reply_enabled = True
        if self.user_id:
            try:
                user_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_settings, self.user_id
                )
                keyword_reply_enabled = user_settings.get('keyword_reply_enabled', 1) == 1
                image_reply_enabled = user_settings.get('image_reply_enabled', 1) == 1
            except Exception as e:
                logger.error(f'è·å–ç”¨æˆ·å›å¤å¼€å…³è®¾ç½®å¤±è´¥: {e}')

        # å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘
        await self.handle_keyword_forward(message)

        # å¤„ç†å…³é”®è¯æœç´¢
        if keyword_reply_enabled:
            await self.handle_keyword_search(message)

        # å¤„ç†å›¾ç‰‡
        if image_reply_enabled and message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and attachment.content_type.startswith('image/'):
                    logger.info(f"ğŸ“· æ£€æµ‹åˆ°å›¾ç‰‡ï¼Œå¼€å§‹å¤„ç†: {attachment.filename}")
                    await self.handle_image(message, attachment)

    async def handle_image(self, message, attachment):
        try:
            # ã€å¢å¼ºç¨³å®šæ€§ã€‘å¢åŠ è¶…æ—¶æ—¶é—´ï¼Œæ·»åŠ ä»£ç†æ”¯æŒ
            timeout = aiohttp.ClientTimeout(total=30, connect=10)  # 30ç§’æ€»è¶…æ—¶ï¼Œ10ç§’è¿æ¥è¶…æ—¶
            image_data = None

            # ã€ä»£ç†é…ç½®ã€‘ä»ç¯å¢ƒå˜é‡è·å–ä»£ç†ï¼ˆæ”¯æŒå›½å†…ç½‘ç»œç¯å¢ƒï¼‰
            proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None

            # ã€ä¼ªè£…å¤´ã€‘æ·»åŠ  User-Agent é˜²æ­¢è¢« Discord CDN æ‹’ç»
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }

            # é‡è¯•æœ€å¤š3æ¬¡
            for attempt in range(3):
                try:
                    logger.info(f"ä¸‹è½½Discordå›¾ç‰‡ (å°è¯• {attempt + 1}/3): {attachment.filename}")
                    # ã€å…³é”®ä¿®å¤ã€‘trust_env=True å…è®¸ä½¿ç”¨ç³»ç»Ÿä»£ç†
                    async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                        async with session.get(attachment.url, proxy=proxy_url) as resp:
                            if resp.status == 200:
                                image_data = await resp.read()
                                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸï¼Œå¤§å°: {len(image_data)} bytes")
                                break
                            else:
                                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : {resp.status}")
                except aiohttp.ClientError as e:
                    logger.warning(f"å›¾ç‰‡ä¸‹è½½ç½‘ç»œé”™è¯¯ (å°è¯• {attempt + 1}/3): {e}")
                    if attempt < 2:  # ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•
                        await asyncio.sleep(2)  # ã€å¢å¼ºã€‘ç­‰å¾…2ç§’åé‡è¯•
                except Exception as e:
                    logger.error(f"å›¾ç‰‡ä¸‹è½½æœªçŸ¥é”™è¯¯ (å°è¯• {attempt + 1}/3): {e}")
                    break

            if image_data is None:
                logger.error("å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                return  # é™é»˜å¤±è´¥ï¼Œä¸å‘é€é”™è¯¯æ¶ˆæ¯

            # ã€æ–°å¢ã€‘AIå¹¶å‘é™åˆ¶ï¼šæœ€å¤šåŒæ—¶2ä¸ªAIæ¨ç†ä»»åŠ¡
            # ä½¿ç”¨Semaphoreæ§åˆ¶å¹¶å‘ï¼Œé˜²æ­¢CPUé¥±å’Œå¯¼è‡´Flaskä¸»çº¿ç¨‹é˜»å¡
            async with ai_concurrency_limit:
                logger.debug(f"ğŸ”’ è·å–AIå¹¶å‘é”ï¼Œå½“å‰ç­‰å¾…é˜Ÿåˆ—: {ai_concurrency_limit._value}")

                # è°ƒç”¨ DINOv2 æœåŠ¡è¯†åˆ«å›¾ç‰‡ï¼Œä¸ä½¿ç”¨åº—é“ºè¿‡æ»¤ï¼ˆæ‰€æœ‰ç”¨æˆ·éƒ½èƒ½è¯†åˆ«æ‰€æœ‰å•†å“ï¼‰
                result = await self.recognize_image(image_data, user_shops=None)

                logger.debug(f"ğŸ”“ é‡Šæ”¾AIå¹¶å‘é”")

            logger.info(f'å›¾ç‰‡è¯†åˆ«ç»“æœ: success={result.get("success") if result else False}, results_count={len(result.get("results", [])) if result else 0}')

            if result and result.get('success') and result.get('results'):
                # è·å–æœ€ä½³åŒ¹é…ç»“æœ
                best_match = result['results'][0]
                similarity = best_match.get('similarity', 0)

                # è·å–ç”¨æˆ·ä¸ªæ€§åŒ–ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                user_threshold = config.DISCORD_SIMILARITY_THRESHOLD  # é»˜è®¤å€¼
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # å¼‚æ­¥è·å–ç”¨æˆ·è®¾ç½®
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            user_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                logger.info(f'æœ€ä½³åŒ¹é…ç›¸ä¼¼åº¦: {similarity:.4f}, ç”¨æˆ·é˜ˆå€¼: {user_threshold:.4f}')

                # ä¸¥æ ¼æ‰§è¡Œç”¨æˆ·è®¾ç½®çš„é˜ˆå€¼
                if similarity >= user_threshold:
                    product = best_match.get('product', {})
                    logger.info(f'âœ… åŒ¹é…æˆåŠŸ! ç›¸ä¼¼åº¦: {similarity:.2f} | å•†å“: {product.get("id")} | é¢‘é“: {message.channel.name}')

                    # æ£€æŸ¥å•†å“æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨å›å¤è§„åˆ™
                    product_rule_enabled = product.get('ruleEnabled', True)

                    if product_rule_enabled:
                        # ä½¿ç”¨å…¨å±€è‡ªå®šä¹‰å›å¤
                        custom_reply = self._get_custom_reply()

                        # ä½¿ç”¨è°ƒåº¦æœºåˆ¶å›å¤ï¼Œè€Œä¸æ˜¯ç›´æ¥å›å¤
                        await self.schedule_reply(message, product, custom_reply)
                    else:
                        # å•†å“çº§è‡ªå®šä¹‰å›å¤
                        custom_text = product.get('custom_reply_text', '').strip()
                        custom_image_indexes = product.get('selectedImageIndexes', [])
                        custom_image_urls = product.get('customImageUrls', [])

                        # å‘é€è‡ªå®šä¹‰æ–‡æœ¬æ¶ˆæ¯
                        if custom_text:
                            await message.reply(custom_text)

                        # å‘é€å›¾ç‰‡ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼šæœ¬åœ°ä¸Šä¼  > è‡ªå®šä¹‰é“¾æ¥ > å•†å“å›¾ç‰‡ï¼‰
                        images_sent = False

                        # ä¼˜å…ˆæ£€æŸ¥å›¾ç‰‡æ¥æºç±»å‹
                        image_source = product.get('image_source', 'product')

                        if image_source == 'upload':
                            # å‘é€æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡
                            try:
                                from database import db
                                # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾ç‰‡ï¼ˆåŒ…æ‹¬ä¸Šä¼ çš„ï¼‰
                                product_images = db.get_product_images(product['id'])
                                if product_images:
                                    for img_data in product_images[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                        try:
                                            image_path = img_data.get('image_path')
                                            # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ„å»ºå®Œæ•´è·¯å¾„
                                            if image_path and not os.path.isabs(image_path):
                                                image_path = os.path.join(os.path.dirname(__file__), image_path)
                                            if image_path and os.path.exists(image_path):
                                                await message.reply(file=discord.File(image_path, os.path.basename(image_path)))
                                                images_sent = True
                                        except Exception as e:
                                            logger.error(f'å‘é€æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif image_source == 'custom' and custom_image_urls and len(custom_image_urls) > 0:
                            # å‘é€è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥
                            try:
                                # ã€ä»£ç†é…ç½®ã€‘ä»ç¯å¢ƒå˜é‡è·å–ä»£ç†
                                proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None
                                # ã€ä¼ªè£…å¤´ã€‘æ·»åŠ  User-Agent
                                headers = {
                                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                                }
                                timeout = aiohttp.ClientTimeout(total=30, connect=10)

                                for url in custom_image_urls[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                    try:
                                        # ã€å…³é”®ä¿®å¤ã€‘trust_env=True å…è®¸ä½¿ç”¨ç³»ç»Ÿä»£ç†
                                        async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                                            async with session.get(url.strip(), proxy=proxy_url) as resp:
                                                if resp.status == 200:
                                                    image_data = await resp.read()
                                                    # ä»URLæå–æ–‡ä»¶å
                                                    filename = url.split('/')[-1].split('?')[0] or f"image_{custom_image_urls.index(url)}.jpg"
                                                    if not filename.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
                                                        filename += '.jpg'
                                                    await message.reply(file=discord.File(io.BytesIO(image_data), filename))
                                                    images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€è‡ªå®šä¹‰å›¾ç‰‡å¤±è´¥ {url}: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†è‡ªå®šä¹‰å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif custom_image_indexes and len(custom_image_indexes) > 0:
                            # å‘é€é€‰ä¸­çš„å•†å“å›¾ç‰‡
                            try:
                                import aiofiles
                                from database import db

                                for image_index in custom_image_indexes:
                                    try:
                                        # è·å–å›¾ç‰‡è·¯å¾„
                                        image_path = db.get_product_image_path(product['id'], image_index)
                                        if image_path and os.path.exists(image_path):
                                            # å‘é€å›¾ç‰‡æ–‡ä»¶
                                            await message.reply(file=discord.File(image_path, f"image_{image_index}.jpg"))
                                            images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€å•†å“å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†å•†å“å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        # å¦‚æœæ—¢æ²¡æœ‰æ–‡æœ¬ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œåˆ™å‘é€é»˜è®¤é“¾æ¥
                        if not custom_text and not images_sent:
                            response = get_response_url_for_channel(product, message.channel.id, self.user_id)
                            await message.reply(response)

                    logger.info(f'å›¾ç‰‡è¯†åˆ«æˆåŠŸï¼Œç›¸ä¼¼åº¦: {similarity:.4f}')
                else:
                    # ç›¸ä¼¼åº¦ä½äºé˜ˆå€¼ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                    logger.info(f'å›¾ç‰‡è¯†åˆ«ç›¸ä¼¼åº¦ {similarity:.4f} ä½äºç”¨æˆ·é˜ˆå€¼ {user_threshold:.4f}ï¼Œä¸å›å¤')

        except Exception as e:
            logger.error(f'Error handling image: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def handle_keyword_forward(self, message):
        """å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘"""
        try:
            # æ£€æŸ¥æ¶ˆæ¯å†…å®¹æ˜¯å¦åŒ…å«å…³é”®è¯
            message_content = message.content.lower() if message.content else ""
            has_keyword = any(keyword.strip().lower() in message_content for keyword in config.FORWARD_KEYWORDS)

            if has_keyword and config.FORWARD_TARGET_CHANNEL_ID:
                # è·å–ç›®æ ‡é¢‘é“
                target_channel = self.get_channel(config.FORWARD_TARGET_CHANNEL_ID)
                if target_channel:
                    # æ„å»ºè½¬å‘æ¶ˆæ¯
                    forward_embed = discord.Embed(
                        title="ğŸ“¢ å•†å“ç›¸å…³æ¶ˆæ¯è½¬å‘",
                        description=f"**åŸå§‹æ¶ˆæ¯:** {message.content[:500]}{'...' if len(message.content) > 500 else ''}",
                        color=0x00ff00,
                        timestamp=message.created_at
                    )

                    forward_embed.add_field(
                        name="å‘é€è€…",
                        value=f"{message.author.name}#{message.author.discriminator}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æ¥æºé¢‘é“",
                        value=f"#{message.channel.name}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æœåŠ¡å™¨",
                        value=message.guild.name if message.guild else "DM",
                        inline=True
                    )

                    # å¦‚æœæœ‰é™„ä»¶ï¼Œæ·»åŠ åˆ°embedä¸­
                    if message.attachments:
                        attachment_urls = [att.url for att in message.attachments]
                        forward_embed.add_field(
                            name="é™„ä»¶",
                            value="\n".join(attachment_urls),
                            inline=False
                        )

                    forward_embed.set_footer(text=f"æ¶ˆæ¯ID: {message.id}")

                    await target_channel.send(embed=forward_embed)
                    logger.info(f"è½¬å‘äº†åŒ…å«å…³é”®è¯çš„æ¶ˆæ¯: {message.content[:100]}...")
                else:
                    logger.warning(f"æ‰¾ä¸åˆ°ç›®æ ‡é¢‘é“: {config.FORWARD_TARGET_CHANNEL_ID}")

        except Exception as e:
            logger.error(f'Error handling keyword forward: {e}')

    async def handle_keyword_search(self, message):
        """å¤„ç†å…³é”®è¯å•†å“æœç´¢"""
        try:
            # åªå¤„ç†çº¯æ–‡å­—æ¶ˆæ¯ï¼ˆä¸åŒ…å«å›¾ç‰‡çš„ï¼‰
            if not message.content or message.attachments:
                return

            search_query = message.content.strip()
            if not search_query:
                return

            # è¿‡æ»¤å¤ªçŸ­çš„æ¶ˆæ¯ï¼ˆè‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦ï¼‰
            if len(search_query) < 2:
                return

            # è¿‡æ»¤çº¯æ•°å­—æ¶ˆæ¯ï¼ˆå¦‚ "1", "2", "123"ï¼‰
            if search_query.isdigit():
                return

            # è¿‡æ»¤åªåŒ…å«æ•°å­—å’Œç©ºæ ¼çš„æ¶ˆæ¯ï¼ˆå¦‚ "1 2 3"ï¼‰
            if search_query.replace(' ', '').isdigit():
                return

            # è¿‡æ»¤å¸¸è§çš„æ— æ„ä¹‰çŸ­æ¶ˆæ¯
            meaningless_patterns = {'ok', 'no', 'yes', 'hi', 'hey', 'lol', 'lmao', 'wtf', 'omg', 'bruh'}
            if search_query.lower() in meaningless_patterns:
                return

            # è°ƒç”¨æœç´¢API
            result = await self.search_products_by_keyword(search_query)

            products = []
            if result and result.get('success') and result.get('products'):
                products = result['products'][:5]  # æœ€å¤šæ˜¾ç¤º5ä¸ªç»“æœ

            # åªåœ¨æ‰¾åˆ°å•†å“æ—¶å›å¤å’Œè®°å½•æ—¥å¿—
            if products:
                logger.info(f'å…³é”®è¯æœç´¢æˆåŠŸ: "{search_query}" -> æ‰¾åˆ° {len(products)} ä¸ªå•†å“')
                product = products[0]

                # æ£€æŸ¥é¢‘é“æ˜¯å¦ç»‘å®šäº†ç½‘ç«™é…ç½®ï¼ˆå¿…é¡»ç»‘å®šæ‰èƒ½å›å¤ï¼‰
                website_config = await self.get_website_config_by_channel_async(message.channel.id)
                if not website_config:
                    logger.info(f"é¢‘é“ {message.channel.id} æœªç»‘å®šç½‘ç«™é…ç½®ï¼Œè·³è¿‡å…³é”®è¯å›å¤")
                    return

                # === å…³é”®ä¿®å¤é€»è¾‘ ===
                # æ£€æŸ¥è§„åˆ™æ˜¯å¦å¯ç”¨ï¼ˆå…¼å®¹å­—ç¬¦ä¸²/æ•°å­—ï¼‰
                # æ³¨æ„ï¼šåç«¯APIè¿”å›çš„ autoReplyEnabled å³ ruleEnabled
                rule_enabled = product.get('autoReplyEnabled', True)
                if isinstance(rule_enabled, str):
                    rule_enabled = rule_enabled.strip().lower() not in {'0', 'false', 'no', 'off'}
                elif isinstance(rule_enabled, (int, float)):
                    rule_enabled = bool(rule_enabled)

                custom_reply = None

                # æ£€æŸ¥æ˜¯å¦é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡
                def _coerce_list(value):
                    if not value:
                        return []
                    if isinstance(value, str):
                        try:
                            parsed = json.loads(value)
                        except json.JSONDecodeError:
                            return []
                        return parsed if isinstance(parsed, list) else []
                    if isinstance(value, list):
                        return value
                    return []

                has_custom_images = False
                image_source = product.get('imageSource') or product.get('image_source')

                if image_source == 'upload':
                    uploaded_imgs = _coerce_list(product.get('uploaded_reply_images'))
                    product['uploaded_reply_images'] = uploaded_imgs
                    has_custom_images = bool(uploaded_imgs)
                elif image_source == 'custom':
                    custom_urls = _coerce_list(product.get('customImageUrls')) or _coerce_list(product.get('custom_image_urls'))
                    if custom_urls:
                        product['customImageUrls'] = custom_urls
                    has_custom_images = bool(custom_urls)
                elif image_source == 'product':
                    selected_indexes = _coerce_list(product.get('selectedImageIndexes')) or _coerce_list(product.get('custom_reply_images'))
                    if selected_indexes:
                        product['selectedImageIndexes'] = selected_indexes
                    has_custom_images = bool(selected_indexes)

                # å¦‚æœè§„åˆ™ç¦ç”¨äº†ï¼Œæˆ–è€…é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡ï¼Œéƒ½éœ€è¦åˆ›å»º custom_reply
                if not rule_enabled or has_custom_images:
                    # æ„é€  custom_reply å¯¹è±¡ä¾› schedule_reply ä½¿ç”¨
                    custom_text = (product.get('custom_reply_text') or '').strip()

                    # å³ä½¿æ²¡æœ‰æ–‡æœ¬ï¼Œåªè¦æ˜¯è¦å‘å›¾ç‰‡ï¼Œä¹Ÿéœ€è¦ä¼ é€’ custom_reply ä¿¡å·
                    # schedule_reply ä¼šè¿›ä¸€æ­¥å¤„ç†å›¾ç‰‡é€»è¾‘
                    custom_reply = {
                        'reply_type': 'text' if custom_text else 'custom_only', # custom_only è¡¨ç¤ºä¸å‘é»˜è®¤é“¾æ¥
                        'content': custom_text,
                        # ä¼ é€’å›¾ç‰‡ä¿¡æ¯ä¾› schedule_reply å†…éƒ¨å¤„ç†
                        'product_data': product
                    }
                    if not rule_enabled:
                        logger.info(f"å•†å“ {product['id']} è§„åˆ™å·²ç¦ç”¨ï¼Œå‡†å¤‡å‘é€è‡ªå®šä¹‰å›å¤")
                    elif has_custom_images:
                        logger.info(f"å•†å“ {product['id']} é…ç½®äº†è‡ªå®šä¹‰å›¾ç‰‡ï¼Œå‡†å¤‡å‘é€è‡ªå®šä¹‰å›å¤")

                # ä½¿ç”¨ schedule_reply ç»Ÿä¸€å‘é€
                await self.schedule_reply(message, product, custom_reply)
            else:
                # æ²¡æœ‰æ‰¾åˆ°å•†å“ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                logger.info(f'å…³é”®è¯æœç´¢æ— ç»“æœ: {search_query}')

        except Exception as e:
            logger.error(f'Error handling keyword search: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def search_products_by_keyword(self, keyword):
        """æ ¹æ®å…³é”®è¯æœç´¢å•†å“"""
        try:
            # è®¾ç½®è¶…æ—¶æ—¶é—´
            timeout = aiohttp.ClientTimeout(total=10)  # 10ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # æ„å»ºæœç´¢è¯·æ±‚
                search_data = {
                    'query': keyword,
                    'limit': 10  # æœç´¢æ›´å¤šç»“æœï¼Œä½†åªæ˜¾ç¤ºå‰5ä¸ª
                }

                # è°ƒç”¨åç«¯æœç´¢API
                async with session.post(f'{config.BACKEND_API_URL}/api/search_similar_text',
                                      json=search_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'Keyword search API error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error searching products by keyword: {e}')
            return None

    async def recognize_image(self, image_data, user_shops=None):
        try:
            # å¢åŠ è¶…æ—¶æ—¶é—´ï¼ŒFAISSæœç´¢å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´
            timeout = aiohttp.ClientTimeout(total=30)  # 30ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # å‡†å¤‡å›¾ç‰‡æ•°æ®
                form_data = aiohttp.FormData()
                form_data.add_field('image', image_data, filename='image.jpg', content_type='image/jpeg')
                # ä½¿ç”¨é…ç½®çš„é˜ˆå€¼
                # ä½¿ç”¨ç”¨æˆ·ä¸ªæ€§åŒ–é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                api_threshold = config.DISCORD_SIMILARITY_THRESHOLD
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # å¼‚æ­¥è·å–ç”¨æˆ·è®¾ç½®
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            api_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                form_data.add_field('threshold', str(api_threshold))
                form_data.add_field('limit', '1')  # Discordåªè¿”å›æœ€ç›¸ä¼¼çš„ä¸€ä¸ªç»“æœ

                # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
                if user_shops:
                    form_data.add_field('user_shops', json.dumps(user_shops))

                # è°ƒç”¨ DINOv2 + FAISS æœåŠ¡ï¼ˆæœ¬åœ°ï¼‰
                async with session.post(f'{config.BACKEND_API_URL.replace("/api", "")}/search_similar', data=form_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        return None

        except asyncio.TimeoutError:
            logger.error('Error recognizing image: Request timeout (30s)')
            return None
        except aiohttp.ClientError as e:
            logger.error(f'Error recognizing image: Network error - {type(e).__name__}: {e}')
            return None
        except Exception as e:
            logger.error(f'Error recognizing image: {type(e).__name__}: {e}')
            return None

async def get_all_accounts_from_backend():
    """ä»åç«¯ API è·å–æ‰€æœ‰å¯ç”¨çš„ Discord è´¦å·"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f'{config.BACKEND_API_URL}/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    # åªè¿”å›çŠ¶æ€ä¸ºonlineçš„è´¦å·
                    return [account for account in accounts if account.get('status') == 'online']
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def bot_loop(client):
    """ä¸»å¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥å¹¶é‡è¿"""
    while True:
        try:
            token = await get_token_from_backend()
            if token:
                if not client.is_ready():
                    logger.info('Starting Discord bot with token from database...')
                    await client.start(token, reconnect=True)
                elif client.current_token != token:
                    logger.info('Token changed, reconnecting...')
                    await client.close()
                    await asyncio.sleep(2)
                    client.current_token = token
                    await client.start(token, reconnect=True)
            else:
                logger.warning('No active token found in database, waiting...')
                if client.is_ready():
                    await client.close()
                client.current_token = None

        except Exception as e:
            logger.error(f'Bot loop error: {e}')
            if client.is_ready():
                await client.close()

        # ç­‰å¾… 30 ç§’åå†æ¬¡æ£€æŸ¥
        await asyncio.sleep(30)

async def start_multi_bot_loop():
    """å¯åŠ¨å¤šè´¦å·æœºå™¨äººå¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥è´¦å·çŠ¶æ€"""
    global bot_clients, bot_tasks

    while True:
        try:
            # è·å–å½“å‰æ‰€æœ‰è´¦å·
            accounts = await get_all_accounts_from_backend()
            current_account_ids = {account['id'] for account in accounts}

            # åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº
            to_remove = []
            for i, client in enumerate(bot_clients):
                if client.account_id not in current_account_ids:
                    logger.info(f'åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº: {client.account_id}')
                    try:
                        if not client.is_closed():
                            await client.close()
                    except Exception as e:
                        logger.error(f'åœæ­¢æœºå™¨äººæ—¶å‡ºé”™: {e}')

                    # å–æ¶ˆå¯¹åº”çš„ä»»åŠ¡
                    if i < len(bot_tasks) and bot_tasks[i] and not bot_tasks[i].done():
                        bot_tasks[i].cancel()

                    to_remove.append(i)

            # ä»åˆ—è¡¨ä¸­ç§»é™¤å·²åœæ­¢çš„æœºå™¨äºº
            for i in reversed(to_remove):
                bot_clients.pop(i)
                if i < len(bot_tasks):
                    bot_tasks.pop(i)

            # ä¸ºæ–°è´¦å·å¯åŠ¨æœºå™¨äºº
            existing_account_ids = {client.account_id for client in bot_clients}
            for account in accounts:
                account_id = account['id']
                if account_id not in existing_account_ids:
                    token = account['token']
                    username = account.get('username', f'account_{account_id}')

                    logger.info(f'å¯åŠ¨æ–°è´¦å·æœºå™¨äºº: {username}')

                    # åˆ›å»ºæœºå™¨äººå®ä¾‹
                    client = DiscordBotClient(account_id=account_id)

                    # å¯åŠ¨æœºå™¨äºº
                    try:
                        task = asyncio.create_task(client.start(token, reconnect=True))
                        bot_clients.append(client)
                        bot_tasks.append(task)
                        logger.info(f'æœºå™¨äººå¯åŠ¨æˆåŠŸ: {username}')
                    except Exception as e:
                        logger.error(f'å¯åŠ¨æœºå™¨äººå¤±è´¥ {username}: {e}')

            # ç­‰å¾…ä¸€æ®µæ—¶é—´åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(30)

        except Exception as e:
            logger.error(f'å¤šè´¦å·æœºå™¨äººå¾ªç¯é”™è¯¯: {e}')
            await asyncio.sleep(30)

async def main():
    client = DiscordBotClient()

    # å¯åŠ¨ä¸»å¾ªç¯
    await bot_loop(client)

if __name__ == '__main__':
    asyncio.run(main())

===== backend/config.py =====
"""
é…ç½®æ–‡ä»¶ - Discord è‡ªåŠ¨è¥é”€æœºå™¨äººç³»ç»Ÿ
"""
import os


class Config:
    """åº”ç”¨é…ç½®ç±»"""

    # Flask æœåŠ¡é…ç½®
    FLASK_HOST = "127.0.0.1"
    FLASK_PORT = 5001
    FLASK_DEBUG = False

    # åç«¯ API URL (ç”¨äºå†…éƒ¨é€šä¿¡)
    BACKEND_API_URL = f"http://{FLASK_HOST}:{FLASK_PORT}/api"

    # æ•°æ®åº“é…ç½®
    DATABASE_PATH = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

    # Discord é…ç½®
    DISCORD_SIMILARITY_THRESHOLD = 0.6  # å›¾ç‰‡ç›¸ä¼¼åº¦é˜ˆå€¼

    # ä¸‹è½½é…ç½®
    DOWNLOAD_THREADS = 4  # ä¸‹è½½çº¿ç¨‹æ•°
    FEATURE_EXTRACT_THREADS = 4  # ç‰¹å¾æå–çº¿ç¨‹æ•°
    SCRAPE_THREADS = 2  # æŠ“å–çº¿ç¨‹æ•°

    # æ¶ˆæ¯è½¬å‘é…ç½® (å¯é€‰)
    FORWARD_KEYWORDS = []  # è§¦å‘è½¬å‘çš„å…³é”®è¯åˆ—è¡¨
    FORWARD_TARGET_CHANNEL_ID = None  # è½¬å‘ç›®æ ‡é¢‘é“ ID

    # ç‰¹å®šå¹³å°é¢‘é“ ID (å¯é€‰ï¼Œç”¨äºå‘é€ç‰¹å®šå¹³å°é“¾æ¥)
    CNFANS_CHANNEL_ID = None
    ACBUY_CHANNEL_ID = None

    # è‡ªåŠ¨å‘é€é»˜è®¤é…ç½®
    DEFAULT_SEND_INTERVAL = 60  # é»˜è®¤å‘é€é—´éš”ï¼ˆç§’ï¼‰
    MIN_SEND_INTERVAL = 10  # æœ€å°å‘é€é—´éš”ï¼ˆç§’ï¼‰
    MAX_SEND_INTERVAL = 3600  # æœ€å¤§å‘é€é—´éš”ï¼ˆç§’ï¼‰

    # è®¸å¯è¯æ¿€æ´»æœåŠ¡é…ç½®
    LICENSE_SERVER_URL = "http://107.172.1.7:8888"
    LICENSE_ALLOW_TEST_KEYS = True
    LICENSE_TEST_KEYS = [
        "TEST-FOREVER-0001",
        "TEST-FOREVER-0002",
        "TEST-FOREVER-0003"
    ]


# å…¨å±€é…ç½®å®ä¾‹
config = Config()

===== backend/database.py =====
import sqlite3
import numpy as np
import os
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager
try:
    from config import config
except ImportError:
    from .config import config

logger = logging.getLogger(__name__)

class Database:
    def __init__(self):
        # SQLite æ•°æ®åº“è·¯å¾„ (ç”¨äºå­˜å‚¨å•†å“å…ƒæ•°æ®å’ŒDiscordè´¦å·ä¿¡æ¯)
        self.db_path = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

        # ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # åˆå§‹åŒ– SQLite æ•°æ®åº“
        self.init_sqlite_database()

    def init_sqlite_database(self):
        """åˆå§‹åŒ– SQLite æ•°æ®åº“ (ç”¨äºå…ƒæ•°æ®å­˜å‚¨)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # åˆ›å»ºå•†å“è¡¨ï¼ˆç§»é™¤å•†å“çº§åˆ«å»¶è¿Ÿï¼Œä½¿ç”¨å…¨å±€å»¶è¿Ÿï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_url TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    english_title TEXT,
                    cnfans_url TEXT,
                    acbuy_url TEXT,
                    shop_name TEXT,
                    ruleEnabled BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_shop_name ON products(shop_name)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_rule_enabled ON products(ruleEnabled)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_image_index ON product_images(image_index)')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºåº—é“ºè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS shops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    shop_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    product_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # ä¸ºç°æœ‰è¡¨æ·»åŠ æ–°å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN ruleEnabled BOOLEAN DEFAULT 1')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN min_delay INTEGER DEFAULT 3')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN max_delay INTEGER DEFAULT 8')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # æ–°å¢è‹±æ–‡æ ‡é¢˜ä¸ cnfans é“¾æ¥å­—æ®µï¼ˆå…¼å®¹å·²æœ‰æ•°æ®åº“ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN english_title TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN cnfans_url TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN acbuy_url TEXT')
            except sqlite3.OperationalError:
                pass

            # æ·»åŠ è‡ªå®šä¹‰å›å¤å­—æ®µ
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_text TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_images TEXT')  # JSONæ ¼å¼å­˜å‚¨å›¾ç‰‡ç´¢å¼•æ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_image_urls TEXT')  # JSONæ ¼å¼å­˜å‚¨è‡ªå®šä¹‰å›¾ç‰‡URLæ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN image_source TEXT DEFAULT \'product\'')  # å›¾ç‰‡æ¥æºï¼š'product'(å•†å“å›¾ç‰‡), 'upload'(æœ¬åœ°ä¸Šä¼ ), 'custom'(URL)
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN shop_name TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN item_id TEXT')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN updated_at TIMESTAMP')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN uploaded_reply_images TEXT')  # JSONæ ¼å¼å­˜å‚¨ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡æ–‡ä»¶åæ•°ç»„
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN cnfans_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN acbuy_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºå›¾ç‰‡è¡¨ (milvus_id æ›¿ä»£ faiss_id)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS product_images (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    image_index INTEGER NOT NULL,
                    features TEXT,  -- å­˜å‚¨åºåˆ—åŒ–çš„ç‰¹å¾å‘é‡
                    milvus_id INTEGER UNIQUE,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE,
                    UNIQUE(product_id, image_index)
                )
            ''')

            # åˆ›å»ºç”¨æˆ·è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT DEFAULT 'user',  -- admin, user
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç”¨æˆ·-åº—é“ºæƒé™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_shop_permissions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    shop_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id, shop_id)
                )
            ''')

            # åˆ›å»º Discord è´¦å·è¡¨ï¼ˆå…³è”åˆ°ç”¨æˆ·ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS discord_accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    token TEXT UNIQUE NOT NULL,
                    user_id INTEGER,
                    status TEXT DEFAULT 'offline',
                    last_active TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL
                )
            ''')

            # æ’å…¥é»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO users (id, username, password_hash, role, is_active)
                    VALUES (1, 'admin', 'hashed_admin123', 'admin', 1)
                ''')  # å¯†ç : admin123
            except sqlite3.Error as e:
                logger.warning(f"åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜å¤±è´¥: {e}")

            # åˆ›å»ºè´¦å·è½®æ¢é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS account_rotation_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    enabled BOOLEAN DEFAULT 0,
                    rotation_interval INTEGER DEFAULT 10,
                    current_account_id INTEGER,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤è½®æ¢é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO account_rotation_config (id, enabled, rotation_interval)
                VALUES (1, 0, 10)
            ''')

            # åˆ›å»ºæœç´¢å†å²è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS search_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    query_image_path TEXT NOT NULL,
                    matched_product_id INTEGER,
                    matched_image_index INTEGER,
                    similarity REAL NOT NULL,
                    threshold REAL NOT NULL,
                    search_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (matched_product_id) REFERENCES products (id) ON DELETE SET NULL
                )
            ''')

            # ã€æ–°å¢ä¼˜åŒ–ã€‘ä¸ºæœç´¢å†å²åˆ›å»ºæ—¶é—´ç´¢å¼•ï¼Œæå¤§æå‡ç¿»é¡µé€Ÿåº¦
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_search_history_time ON search_history(search_time DESC)')
            except Exception:
                pass

            # åˆ›å»ºå…¨å±€å»¶è¿Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS global_reply_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    min_delay REAL DEFAULT 3.0,
                    max_delay REAL DEFAULT 8.0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    discord_channel_id TEXT DEFAULT '',
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    cnfans_channel_id TEXT DEFAULT '',
                    acbuy_channel_id TEXT DEFAULT '',
                    scrape_threads INTEGER DEFAULT 2,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç³»ç»Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                VALUES (1, '', 4, 4, 0.6, '', '')
            ''')

            # ä¸ºç°æœ‰è®°å½•æ·»åŠ scrape_threadså­—æ®µ
            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN scrape_threads INTEGER DEFAULT 2')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # åˆ›å»ºç½‘ç«™é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_configs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    display_name TEXT NOT NULL,
                    url_template TEXT NOT NULL,
                    id_pattern TEXT NOT NULL,
                    badge_color TEXT DEFAULT 'blue',
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨è½®æ¢åŠŸèƒ½ (1=å¯ç”¨, 0=ç¦ç”¨)
                    message_filters TEXT DEFAULT '[]',  -- JSONæ ¼å¼å­˜å‚¨è¿‡æ»¤æ¡ä»¶æ•°ç»„
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # ä¸ºwebsite_configsè¡¨æ·»åŠ rotation_intervalå­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_interval INTEGER DEFAULT 180')
            except sqlite3.OperationalError:
                pass

            # ä¸ºwebsite_configsè¡¨æ·»åŠ message_filterså­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN message_filters TEXT DEFAULT \'[]\'')
            except sqlite3.OperationalError:
                pass

            # ä¸ºwebsite_configsè¡¨æ·»åŠ rotation_enabledå­—æ®µ
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # 1. æ¶ˆæ¯å¤„ç†å»é‡è¡¨ï¼ˆé˜²æ­¢å¤šä¸ªBotå›å¤åŒä¸€æ¡æ¶ˆæ¯ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS processed_messages (
                    message_id TEXT PRIMARY KEY,
                    processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºè‡ªå®šä¹‰å›å¤å†…å®¹è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS custom_replies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reply_type TEXT NOT NULL, -- 'text', 'image', 'text_and_link', 'custom_only'
                    content TEXT, -- æ–‡å­—å†…å®¹æˆ–å›¾ç‰‡URL
                    image_url TEXT, -- å¦‚æœæ˜¯å›¾ç‰‡å›å¤
                    is_active BOOLEAN DEFAULT 1,
                    priority INTEGER DEFAULT 0, -- ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 2. ä¿®æ”¹é¢‘é“ç»‘å®šè¡¨ï¼Œå¢åŠ  user_id å®ç°ç”¨æˆ·éš”ç¦»
            try:
                cursor.execute('ALTER TABLE website_channel_bindings ADD COLUMN user_id INTEGER')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºç½‘ç«™é¢‘é“ç»‘å®šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_channel_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    channel_id TEXT NOT NULL,
                    user_id INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(website_id, channel_id)
                )
            ''')

            # åˆ›å»ºç½‘ç«™è´¦å·ç»‘å®šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_account_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    account_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    role TEXT NOT NULL CHECK (role IN ('listener', 'sender', 'both')),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    FOREIGN KEY (account_id) REFERENCES discord_accounts (id) ON DELETE CASCADE,
                    UNIQUE(website_id, account_id)
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿå…¬å‘Šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_announcements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºæ¶ˆæ¯è¿‡æ»¤è§„åˆ™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS message_filters (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filter_type TEXT NOT NULL, -- 'contains', 'starts_with', 'ends_with', 'regex'
                    filter_value TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç”¨æˆ·è®¾ç½®è¡¨ï¼ˆæ¯ä¸ªç”¨æˆ·çš„ä¸ªæ€§åŒ–è®¾ç½®ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    global_reply_min_delay REAL DEFAULT 3.0,
                    global_reply_max_delay REAL DEFAULT 8.0,
                    user_blacklist TEXT DEFAULT '',  -- ç”¨æˆ·é»‘åå•ï¼Œé€—å·åˆ†éš”
                    keyword_filters TEXT DEFAULT '',  -- å…³é”®è¯è¿‡æ»¤ï¼Œé€—å·åˆ†éš”
                    keyword_reply_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨å…³é”®è¯å›å¤
                    image_reply_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å¯ç”¨å›¾ç‰‡å›å¤
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id)
                )
            ''')

            # ä¸º user_settings è¡¨æ·»åŠ æ–°å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN keyword_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN image_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºç”¨æˆ·çº§åˆ«çš„ç½‘ç«™è®¾ç½®è¡¨ï¼ˆè½®æ¢è®¾ç½®å’Œæ¶ˆæ¯è¿‡æ»¤ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_website_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    website_id INTEGER NOT NULL,
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,
                    message_filters TEXT DEFAULT '[]',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(user_id, website_id)
                )
            ''')

            # åˆ›å»ºæŠ“å–çŠ¶æ€è¡¨ï¼ˆæŒä¹…åŒ–å­˜å‚¨æŠ“å–çŠ¶æ€ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scrape_status (
                    id INTEGER PRIMARY KEY CHECK (id = 1),  -- åªå…è®¸ä¸€æ¡è®°å½•
                    is_scraping BOOLEAN DEFAULT 0,
                    stop_signal BOOLEAN DEFAULT 0,
                    current_shop_id TEXT,
                    total INTEGER DEFAULT 0,
                    processed INTEGER DEFAULT 0,
                    success INTEGER DEFAULT 0,
                    progress REAL DEFAULT 0,
                    message TEXT DEFAULT 'ç­‰å¾…å¼€å§‹...',
                    completed BOOLEAN DEFAULT 0,
                    thread_id TEXT,  -- è®°å½•å½“å‰çº¿ç¨‹ID
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç½‘ç«™é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                VALUES
                    ('cnfans', 'CNFans', 'https://cnfans.com/product?id={id}&platform=WEIDIAN', '{id}', 'blue'),
                    ('acbuy', 'AcBuy', 'https://www.acbuy.com/product?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD', '{id}', 'orange'),
                    ('weidian', 'å¾®åº—', 'https://weidian.com/item.html?itemID={id}', '{id}', 'gray')
            ''')

            # æ’å…¥é»˜è®¤çŠ¶æ€è®°å½•
            cursor.execute('''
                INSERT OR IGNORE INTO scrape_status (id, is_scraping, stop_signal, message)
                VALUES (1, 0, 0, 'ç­‰å¾…å¼€å§‹...')
            ''')

            # æ’å…¥é»˜è®¤å…¨å±€å»¶è¿Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO global_reply_config (id, min_delay, max_delay)
                VALUES (1, 3.0, 8.0)
            ''')

            conn.commit()

    def cleanup_processed_messages(self):
        """æ¸…ç†æ—§çš„æ¶ˆæ¯å¤„ç†è®°å½•ï¼Œåªä¿ç•™æœ€è¿‘1å°æ—¶çš„è®°å½•"""
        try:
            with self.get_connection() as conn:
                conn.execute("DELETE FROM processed_messages WHERE processed_at < datetime('now', '-1 hour')")
                conn.commit()
        except Exception as e:
            logger.error(f"æ¸…ç†æ¶ˆæ¯è®°å½•å¤±è´¥: {e}")


    @contextmanager
    def get_connection(self):
        """è·å– SQLite æ•°æ®åº“è¿æ¥çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0) # å¢åŠ è¶…æ—¶æ—¶é—´
            conn.row_factory = sqlite3.Row

            # å…³é”®ä¼˜åŒ–ï¼šå¼€å¯ WAL æ¨¡å¼
            conn.execute('PRAGMA journal_mode=WAL;')
            conn.execute('PRAGMA synchronous=NORMAL;') # ç¨å¾®é™ä½å®‰å…¨æ€§ä»¥æ¢å–æ€§èƒ½

            yield conn
        except sqlite3.IntegrityError:
            # è¿™æ˜¯ä¸€ä¸ªé€»è¾‘æ§åˆ¶ä¿¡å·ï¼ˆå¦‚å”¯ä¸€æ€§çº¦æŸï¼‰ï¼Œç›´æ¥æŠ›å‡ºç»™ä¸Šå±‚å¤„ç†ï¼Œä¸è®°å½•ä¸ºè¿æ¥é”™è¯¯
            raise
        except Exception as e:
            logger.error("æ•°æ®åº“è¿æ¥å¤±è´¥: %s", str(e))
            raise
        finally:
            if conn:
                conn.close()

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> List[Dict]:
        """æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›ç»“æœ"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            if fetch:
                results = [dict(row) for row in cursor.fetchall()]
                conn.commit()
                return results
            conn.commit()
            return []

    def insert_product(self, product_data: Dict) -> int:
        """æ’å…¥å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO products
                (product_url, title, description, english_title, cnfans_url, acbuy_url, shop_name, ruleEnabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                product_data['product_url'],
                product_data.get('title', ''),
                product_data.get('description', ''),
                product_data.get('english_title', ''),
                product_data.get('cnfans_url', ''),
                product_data.get('acbuy_url', ''),
                product_data.get('shop_name', ''),
                product_data.get('ruleEnabled', True)
            ))
            product_id = cursor.lastrowid
            conn.commit()
            return product_id

    def insert_image_record(self, product_id: int, image_path: str, image_index: int, features: np.ndarray = None) -> int:
        """æ’å…¥å›¾åƒè®°å½•åˆ°æ•°æ®åº“ï¼Œè¿”å›è®°å½•IDä¾›FAISSä½¿ç”¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # å°†ç‰¹å¾å‘é‡åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²å­˜å‚¨
                features_str = None
                if features is not None:
                    import json
                    features_str = json.dumps(features.tolist())

                cursor.execute('''
                    INSERT INTO product_images
                    (product_id, image_path, image_index, features)
                    VALUES (?, ?, ?, ?)
                ''', (product_id, image_path, image_index, features_str))
                conn.commit()
                record_id = cursor.lastrowid
                logger.info(f"å›¾åƒè®°å½•æ’å…¥æˆåŠŸ: product_id={product_id}, image_index={image_index}, record_id={record_id}")
                return record_id

        except Exception as e:
            logger.error(f"æ’å…¥å›¾åƒè®°å½•å¤±è´¥: {e}")
            raise e

    def search_similar_images(self, query_vector: np.ndarray, limit: int = 1,
                             threshold: float = 0.6, user_shops: Optional[List[str]] = None) -> List[Dict]:
        """ä½¿ç”¨FAISSæœç´¢ç›¸ä¼¼å›¾åƒ"""
        import time
        start_time = time.time()

        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine

            logger.info(f"å¼€å§‹è·å–FAISSå¼•æ“...")
            engine_start = time.time()
            engine = get_vector_engine()
            logger.info(f"è·å–FAISSå¼•æ“è€—æ—¶: {time.time() - engine_start:.3f}ç§’")

            print(f"DEBUG DB: Starting FAISS search, threshold: {threshold}, limit: {limit}")
            print(f"DEBUG DB: Query vector length: {len(query_vector) if hasattr(query_vector, '__len__') else 'unknown'}")

            # æ‰§è¡ŒFAISSæœç´¢
            faiss_start = time.time()
            faiss_results = engine.search(query_vector, top_k=min(limit * 3, 50))
            logger.info(f"FAISSæœç´¢è€—æ—¶: {time.time() - faiss_start:.3f}ç§’")
            print(f"DEBUG DB: FAISS search returned {len(faiss_results)} results")

            matched_results = []

            for result in faiss_results:
                score = result['score']
                db_id = result['db_id']

                print(f"DEBUG DB: Processing result - db_id: {db_id}, score: {score}, threshold: {threshold}")

                # é€šè¿‡image_db_idè·å–äº§å“ä¿¡æ¯
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    print(f"DEBUG DB: Found image info for db_id {db_id}: product_id={image_info['product_id']}")
                    product_info = self._get_product_info_by_id(image_info['product_id'])

                    if product_info:
                        # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œè¿›è¡Œè¿‡æ»¤
                        if user_shops and product_info.get('shop_name') not in user_shops:
                            print(f"DEBUG DB: Skipping product from shop {product_info.get('shop_name')} - not in user shops {user_shops}")
                            continue

                        print(f"DEBUG DB: Found product info for product_id {image_info['product_id']}: ruleEnabled={product_info.get('ruleEnabled', True)}")
                        result_dict = {
                            **product_info,
                            'similarity': score,
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added result with similarity {score}")

                        # å¦‚æœæ‰¾åˆ°äº†è¶³å¤Ÿçš„ç»“æœï¼Œå°±åœæ­¢
                        if len(matched_results) >= limit:
                            break
                    else:
                        print(f"DEBUG DB: Product info not found for product_id {image_info['product_id']}")
                else:
                    print(f"DEBUG DB: Image info not found for db_id {db_id}")

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç»“æœï¼Œè¿”å›æœ€ä½³åŒ¹é…ï¼ˆå³ä½¿ä½äºé˜ˆå€¼ï¼‰
            if not matched_results and faiss_results:
                print(f"DEBUG DB: No results above threshold {threshold}, returning best match")
                best_result = faiss_results[0]
                db_id = best_result['db_id']
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    product_info = self._get_product_info_by_id(image_info['product_id'])
                    if product_info:
                        result_dict = {
                            **product_info,
                            'similarity': best_result['score'],
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added best match with similarity {best_result['score']}")

            return matched_results

        except Exception as e:
            logger.error(f"FAISSæœç´¢å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _get_product_url_by_id(self, product_id: int) -> Optional[str]:
        """æ ¹æ®äº§å“IDè·å–äº§å“URL"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT product_url FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return row['product_url'] if row else None

    def get_image_info_by_id(self, image_id: int) -> Optional[Dict]:
        """æ ¹æ®å›¾åƒè®°å½•IDè·å–å›¾åƒä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM product_images WHERE id = ?", (image_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def _get_product_info_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®äº§å“IDè·å–å®Œæ•´çš„äº§å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_indexed_product_ids(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT p.product_url
                FROM products p
                JOIN product_images pi ON p.id = pi.product_id
            ''')
            return [row['product_url'] for row in cursor.fetchall()]

    def get_product_images(self, product_id: int) -> List[Dict]:
        """è·å–å•†å“çš„æ‰€æœ‰å›¾ç‰‡åŠå…¶ç‰¹å¾å‘é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, image_path, image_index, features
                    FROM product_images
                    WHERE product_id = ?
                    ORDER BY image_index
                ''', (product_id,))

                images = []
                for row in cursor.fetchall():
                    image_data = dict(row)
                    # ååºåˆ—åŒ–ç‰¹å¾å‘é‡
                    if image_data.get('features'):
                        import json
                        try:
                            features_list = json.loads(image_data['features'])
                            image_data['features'] = np.array(features_list, dtype='float32')
                        except Exception as e:
                            logger.warning(f"ååºåˆ—åŒ–ç‰¹å¾å‘é‡å¤±è´¥: {e}")
                            image_data['features'] = None
                    else:
                        image_data['features'] = None
                    images.append(image_data)

                return images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def delete_product_images(self, product_id: int) -> bool:
        """åˆ é™¤å•†å“çš„æ‰€æœ‰å›¾åƒå’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾åƒè®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_records = []
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ?", (product_id,))
                image_records = [{'id': row['id'], 'path': row['image_path']} for row in cursor.fetchall()]

            if image_records:
                # ä»FAISSä¸­åˆ é™¤å‘é‡
                try:
                    # ä¼˜å…ˆå°è¯•ç»å¯¹å¯¼å…¥
                    from vector_engine import get_vector_engine
                except ImportError:
                    try:
                        # å°è¯•ç›¸å¯¹å¯¼å…¥
                        from .vector_engine import get_vector_engine
                    except ImportError:
                        # å¦‚æœéƒ½å¤±è´¥ï¼Œè·³è¿‡FAISSæ“ä½œ
                        logger.warning("æ— æ³•å¯¼å…¥vector_engineï¼Œè·³è¿‡FAISSå‘é‡åˆ é™¤")
                        engine = None
                    else:
                        engine = get_vector_engine()
                else:
                    engine = get_vector_engine()

                # å¦‚æœæˆåŠŸè·å–åˆ°å¼•æ“ï¼Œåˆ é™¤å‘é‡
                if engine:
                    for record in image_records:
                        try:
                            engine.remove_vector_by_db_id(record['id'])
                        except Exception as e:
                            logger.warning(f"åˆ é™¤FAISSå‘é‡å¤±è´¥ {record['id']}: {e}")

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            for record in image_records:
                if record['path'] and os.path.exists(record['path']):
                    try:
                        os.remove(record['path'])
                        logger.info(f"å·²åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶: {record['path']}")
                    except Exception as e:
                        logger.warning(f"åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ?", (product_id,))
                cursor.execute("DELETE FROM products WHERE id = ?", (product_id,))
                conn.commit()

            # ä¿å­˜FAISSç´¢å¼•
            if image_records and engine:
                try:
                    engine.save()
                    logger.info("FAISSç´¢å¼•å·²ä¿å­˜")
                except Exception as e:
                    logger.warning(f"ä¿å­˜FAISSç´¢å¼•å¤±è´¥: {e}")

            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å•†å“å›¾åƒå¤±è´¥: {e}")
            return False

    def delete_image_record(self, image_id: int) -> bool:
        """æ ¹æ®å›¾ç‰‡IDåˆ é™¤å›¾ç‰‡è®°å½•ï¼ˆç”¨äºå›æ»šæ“ä½œï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE id = ?", (image_id,))
                deleted = cursor.rowcount > 0
                if deleted:
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡è®°å½•: id={image_id}")
                return deleted
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾ç‰‡è®°å½•å¤±è´¥: {e}")
            return False

    def delete_image_vector(self, product_id: int, image_index: int) -> bool:
        """åˆ é™¤ç‰¹å®šçš„å›¾åƒå‘é‡å’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å›¾åƒçš„è®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_path = None
            image_id = None
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))
                row = cursor.fetchone()
                if row:
                    image_id = row['id']
                    image_path = row['image_path']

            if not image_id:
                logger.warning(f"å›¾ç‰‡ä¸å­˜åœ¨: product_id={product_id}, image_index={image_index}")
                return False

            # ä»FAISSä¸­åˆ é™¤å‘é‡å¹¶é‡å»ºç´¢å¼•
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            success = engine.remove_vector_by_db_id(image_id)
            if not success:
                logger.error(f"FAISSåˆ é™¤å‘é‡å¤±è´¥: db_id={image_id}")
                return False

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            if image_path and os.path.exists(image_path):
                try:
                    os.remove(image_path)
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡æ–‡ä»¶: {image_path}")
                except Exception as e:
                    logger.warning(f"åˆ é™¤å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤è®°å½•
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))

               
                conn.commit()

            logger.info(f"å›¾ç‰‡åˆ é™¤æˆåŠŸ: product_id={product_id}, image_index={image_index}")
            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾åƒå‘é‡å¤±è´¥: {e}")
            return False

    def get_product_by_url(self, product_url: str) -> Optional[Dict]:
        """æ ¹æ®å•†å“URLè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_product_by_item_id(self, item_id: str) -> Optional[Dict]:
        """æ ¹æ®å¾®åº—å•†å“IDè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE item_id = ?", (item_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_all_existing_item_ids(self) -> set:
        """è·å–æ•°æ®åº“ä¸­æ‰€æœ‰å·²å­˜åœ¨çš„å•†å“item_idï¼Œç”¨äºå¿«é€ŸæŸ¥é‡"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT item_id FROM products WHERE item_id IS NOT NULL")
            return {row[0] for row in cursor.fetchall()}

    def cleanup_unused_images(self, days_old: int = 30) -> int:
        """
        æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶
        åˆ é™¤é‚£äº›åœ¨æ•°æ®åº“ä¸­ä¸å­˜åœ¨è®°å½•çš„å›¾ç‰‡æ–‡ä»¶ï¼Œæˆ–è€…åˆ é™¤è¶…è¿‡æŒ‡å®šå¤©æ•°çš„æ—§å›¾ç‰‡

        Args:
            days_old: åˆ é™¤å¤šå°‘å¤©å‰çš„å›¾ç‰‡ï¼ˆé»˜è®¤30å¤©ï¼‰

        Returns:
            åˆ é™¤çš„æ–‡ä»¶æ•°é‡
        """
        try:
            import os
            import time

            # è·å–æ‰€æœ‰æ•°æ®åº“ä¸­å­˜åœ¨çš„å›¾ç‰‡è·¯å¾„
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT image_path FROM product_images")
                db_image_paths = set(row['image_path'] for row in cursor.fetchall())

            # è·å–data/imagesç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
            images_dir = os.path.join('data', 'images')
            if not os.path.exists(images_dir):
                return 0

            deleted_count = 0
            cutoff_time = time.time() - (days_old * 24 * 60 * 60)

            for filename in os.listdir(images_dir):
                filepath = os.path.join(images_dir, filename)

                # åªå¤„ç†jpgæ–‡ä»¶
                if not filename.endswith('.jpg'):
                    continue

                # æ£€æŸ¥æ˜¯å¦åœ¨æ•°æ®åº“ä¸­å­˜åœ¨
                if filepath not in db_image_paths:
                    try:
                        os.remove(filepath)
                        logger.info(f"æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶: {filepath}")
                        deleted_count += 1
                    except Exception as e:
                        logger.warning(f"åˆ é™¤æ–‡ä»¶å¤±è´¥ {filepath}: {e}")
                # æˆ–è€…æ£€æŸ¥æ˜¯å¦å¤ªæ—§ï¼ˆå³ä½¿åœ¨æ•°æ®åº“ä¸­ï¼‰
                elif os.path.getmtime(filepath) < cutoff_time:
                    # è¿™é‡Œå¯ä»¥é€‰æ‹©æ˜¯å¦åˆ é™¤æ—§æ–‡ä»¶
                    # æš‚æ—¶ä¿ç•™ï¼Œé¿å…è¯¯åˆ 
                    pass

            if deleted_count > 0:
                logger.info(f"å›¾ç‰‡æ¸…ç†å®Œæˆï¼Œå…±åˆ é™¤ {deleted_count} ä¸ªæœªä½¿ç”¨çš„æ–‡ä»¶")

            return deleted_count

        except Exception as e:
            logger.error(f"å›¾ç‰‡æ¸…ç†å¤±è´¥: {e}")
            return 0

    def get_product_id_by_url(self, product_url: str) -> Optional[int]:
        """æ ¹æ®å•†å“URLè·å–å•†å“å†…éƒ¨ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return row['id'] if row else None

    def get_total_indexed_images(self) -> int:
        """è·å–å·²ç´¢å¼•çš„æ€»å›¾ç‰‡æ•°é‡"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            return engine.count()
        except Exception as e:
            logger.error(f"è·å–ç´¢å¼•å›¾ç‰‡æ•°é‡å¤±è´¥: {e}")
            return 0

    def get_indexed_product_urls(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT DISTINCT p.product_url
                    FROM products p
                    JOIN product_images pi ON p.id = pi.product_id
                ''')
                return [row['product_url'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–å·²ç´¢å¼•å•†å“URLå¤±è´¥: {e}")
            return []

    def add_search_history(self, query_image_path: str, matched_product_id: int,
                          matched_image_index: int, similarity: float, threshold: float) -> bool:
        """æ·»åŠ æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO search_history
                    (query_image_path, matched_product_id, matched_image_index, similarity, threshold)
                    VALUES (?, ?, ?, ?, ?)
                ''', (query_image_path, matched_product_id, matched_image_index, similarity, threshold))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def get_search_history(self, limit: int = 50, offset: int = 0) -> Dict:
        """è·å–æœç´¢å†å²è®°å½•ï¼ˆæ”¯æŒåˆ†é¡µï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–æ€»æ•°
                cursor.execute('SELECT COUNT(*) FROM search_history')
                total = cursor.fetchone()[0]

                # è·å–åˆ†é¡µæ•°æ®
                cursor.execute('''
                    SELECT
                        sh.id,
                        sh.query_image_path,
                        sh.matched_product_id,
                        sh.matched_image_index,
                        sh.similarity,
                        sh.threshold,
                        sh.search_time,
                        p.title,
                        p.english_title,
                        p.product_url as weidian_url,
                        p.cnfans_url,
                        p.acbuy_url,
                        p.ruleEnabled,
                        pi.image_path as matched_image_path
                    FROM search_history sh
                    LEFT JOIN products p ON sh.matched_product_id = p.id
                    LEFT JOIN product_images pi ON sh.matched_product_id = pi.product_id AND sh.matched_image_index = pi.image_index
                    ORDER BY sh.search_time DESC
                    LIMIT ? OFFSET ?
                ''', (limit, offset))
                rows = cursor.fetchall()
                history = []
                for row in rows:
                    history.append({
                        'id': row['id'],
                        'query_image_path': row['query_image_path'],
                        'matched_product_id': row['matched_product_id'],
                        'matched_image_index': row['matched_image_index'],
                        'similarity': row['similarity'],
                        'threshold': row['threshold'],
                        'search_time': row['search_time'],
                        'title': row['title'],
                        'english_title': row['english_title'],
                        'weidian_url': row['weidian_url'],
                        'cnfans_url': row['cnfans_url'],
                        'acbuy_url': row['acbuy_url'],
                        'ruleEnabled': row['ruleEnabled'],
                        'matched_image_path': row['matched_image_path']
                    })

                return {
                    'history': history,
                    'total': total,
                    'limit': limit,
                    'offset': offset,
                    'has_more': offset + limit < total
                }
        except Exception as e:
            logger.error(f"è·å–æœç´¢å†å²å¤±è´¥: {e}")
            return []

    def delete_search_history(self, history_id: int) -> bool:
        """åˆ é™¤æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history WHERE id = ?', (history_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def clear_search_history(self) -> bool:
        """æ¸…ç©ºæ‰€æœ‰æœç´¢å†å²"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history')
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ¸…ç©ºæœç´¢å†å²å¤±è´¥: {e}")
            return False

    # ===== ç”¨æˆ·æƒé™ç®¡ç†æ–¹æ³• =====

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """ç”¨æˆ·è®¤è¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, role, is_active, created_at
                    FROM users
                    WHERE username = ? AND is_active = 1
                ''', (username,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    stored_hash = user_dict.get('password_hash')

                    # éªŒè¯å¯†ç 
                    authenticated = False

                    if stored_hash:
                        # é¦–å…ˆå°è¯•Werkzeugå“ˆå¸ŒéªŒè¯ï¼ˆæ–°ç”¨æˆ·ï¼‰
                        from werkzeug.security import check_password_hash
                        if check_password_hash(stored_hash, password):
                            authenticated = True
                        # å¦‚æœå¤±è´¥ï¼Œå°è¯•æ—§çš„å“ˆå¸Œæ–¹å¼ï¼ˆå…¼å®¹æ—§ç”¨æˆ·ï¼‰
                        elif stored_hash == f"hashed_{password}":
                            authenticated = True

                    if authenticated:
                        # è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º
                        user_dict['shops'] = self.get_user_shops(user_dict['id'])
                        return user_dict
                return None
        except Exception as e:
            logger.error(f"ç”¨æˆ·è®¤è¯å¤±è´¥: {e}")
            return None

    def create_user(self, username: str, password_hash: str, role: str = 'user') -> bool:
        """åˆ›å»ºæ–°ç”¨æˆ·ï¼ˆpassword_hash ç”±ä¸Šå±‚ç”Ÿæˆï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute('''
                    INSERT INTO users (username, password_hash, role, is_active)
                    VALUES (?, ?, ?, 1)
                ''', (username, password_hash, role))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            logger.warning(f"ç”¨æˆ·åå·²å­˜åœ¨: {username}")
            return False
        except Exception as e:
            logger.error(f"åˆ›å»ºç”¨æˆ·å¤±è´¥: {e}")
            return False

    def get_all_users(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    ORDER BY created_at DESC
                ''')
                users = []
                for row in cursor.fetchall():
                    user = dict(row)
                    user['shops'] = self.get_user_shops(user['id'])
                    users.append(user)
                return users
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_user_shops(self, user_id: int) -> List[str]:
        """è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT shop_id FROM user_shop_permissions
                    WHERE user_id = ?
                ''', (user_id,))
                return [row['shop_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return []

    def update_user_shops(self, user_id: int, shop_ids: List[str]) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„åº—é“ºæƒé™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # å…ˆåˆ é™¤æ—§çš„æƒé™
                cursor.execute('DELETE FROM user_shop_permissions WHERE user_id = ?', (user_id,))

                # æ·»åŠ æ–°çš„æƒé™
                for shop_id in shop_ids:
                    cursor.execute('''
                        INSERT INTO user_shop_permissions (user_id, shop_id)
                        VALUES (?, ?)
                    ''', (user_id, shop_id))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return False

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    WHERE id = ?
                ''', (user_id,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    user_dict['shops'] = self.get_user_shops(user_id)
                    return user_dict
                return None
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_discord_account_user(self, account_id: int, user_id: Optional[int]) -> bool:
        """æ›´æ–°Discordè´¦å·å…³è”çš„ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET user_id = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°Discordè´¦å·ç”¨æˆ·å…³è”å¤±è´¥: {e}")
            return False

    def get_discord_accounts_by_user(self, user_id: Optional[int]) -> List[Dict]:
        """è·å–ç”¨æˆ·å…³è”çš„Discordè´¦å·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id is None:
                    # ç®¡ç†å‘˜æŸ¥è¯¢æ‰€æœ‰è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                    FROM discord_accounts
                    ORDER BY created_at DESC
                    ''')
                else:
                    # æ™®é€šç”¨æˆ·æŸ¥è¯¢è‡ªå·±çš„è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                        FROM discord_accounts
                        WHERE user_id = ?
                        ORDER BY created_at DESC
                    ''', (user_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·Discordè´¦å·å¤±è´¥: {e}")
            return []

    def update_product_title(self, product_id: int, title: str) -> bool:
        """æ›´æ–°å•†å“æ ‡é¢˜"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE products
                    SET title = ?, updated_at = datetime('now')
                    WHERE id = ?
                ''', (title, product_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return False

    def update_product(self, product_id: int, updates: Dict) -> bool:
        """æ›´æ–°å•†å“ä¿¡æ¯ï¼ˆé€šç”¨æ–¹æ³•ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºåŠ¨æ€æ›´æ–°è¯­å¥
                set_parts = []
                params = []
                allowed_fields = [
                    'title', 'english_title', 'ruleEnabled',
                    'custom_reply_text', 'custom_reply_images', 'custom_image_urls',
                    'image_source', 'uploaded_reply_images'
                ]

                for field in allowed_fields:
                    if field in updates:
                        set_parts.append(f'{field} = ?')
                        if (field == 'custom_reply_images' or field == 'custom_image_urls') and isinstance(updates[field], list):
                            # å°†å›¾ç‰‡ç´¢å¼•æˆ–URLæ•°ç»„è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                            params.append(json.dumps(updates[field]))
                        else:
                            params.append(updates[field])

                if not set_parts:
                    return False

                set_parts.append('updated_at = datetime(\'now\')')

                query = f'''
                    UPDATE products
                    SET {', '.join(set_parts)}
                    WHERE id = ?
                '''
                params.append(product_id)

                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“å¤±è´¥: {e}")
            return False

    def get_product_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM products WHERE id = ?', (product_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            logger.error(f"è·å–å•†å“å¤±è´¥: {e}")
            return None

    def delete_user(self, user_id: int) -> bool:
        """åˆ é™¤ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # é¦–å…ˆåˆ é™¤ç”¨æˆ·çš„æ‰€æœ‰ç›¸å…³æ•°æ®
                # åˆ é™¤ç”¨æˆ·çš„ç½‘ç«™è´¦å·ç»‘å®š
                cursor.execute('DELETE FROM website_account_bindings WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·çš„Discordè´¦å·
                cursor.execute('DELETE FROM discord_accounts WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·çš„è®¾ç½®
                cursor.execute('DELETE FROM user_settings WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·
                cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç”¨æˆ·å¤±è´¥: {e}")
            return False

    def update_account_status(self, account_id: int, status: str) -> bool:
        """æ›´æ–°Discordè´¦å·çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET status = ?, last_active = datetime('now')
                    WHERE id = ?
                ''', (status, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}")
            return False

    def get_website_configs(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç½‘ç«™é…ç½®åŠå…¶é¢‘é“ç»‘å®šï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œé¿å…N+1æŸ¥è¯¢ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ä½¿ç”¨LEFT JOINä¸€æ¬¡æ€§è·å–æ‰€æœ‰ç½‘ç«™å’Œå…¶é¢‘é“ç»‘å®š
                cursor.execute('''
                    SELECT
                        wc.id, wc.name, wc.display_name, wc.url_template,
                        wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at,
                        GROUP_CONCAT(wcb.channel_id) as channels
                    FROM website_configs wc
                    LEFT JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                    GROUP BY wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at
                    ORDER BY wc.created_at
                ''')

                configs = []
                for row in cursor.fetchall():
                    config = dict(row)
                    # å°†channelså­—ç¬¦ä¸²è§£æä¸ºæ•°ç»„
                    if config.get('channels'):
                        config['channels'] = config['channels'].split(',') if config['channels'] else []
                    else:
                        config['channels'] = []
                    configs.append(config)

                return configs
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return []

    def add_website_config(self, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str = 'blue', rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """æ·»åŠ ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO website_configs (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def update_website_config(self, config_id: int, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str, rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET name = ?, display_name = ?, url_template = ?, id_pattern = ?, badge_color = ?, rotation_interval = ?, rotation_enabled = ?, message_filters = ?
                    WHERE id = ?
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def delete_website_config(self, config_id: int) -> bool:
        """åˆ é™¤ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM website_configs WHERE id = ?', (config_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def get_website_channel_bindings(self, website_id: int, user_id: int = None) -> List[str]:
        """è·å–ç½‘ç«™ç»‘å®šçš„é¢‘é“åˆ—è¡¨ï¼ˆå¯é€‰æŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ? AND user_id = ?
                        ORDER BY created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ?
                        ORDER BY created_at
                    ''', (website_id,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return []

    def add_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO website_channel_bindings (website_id, channel_id, user_id)
                    VALUES (?, ?, ?)
                ''', (website_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šï¼ˆæŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ã€ä¿®å¤ã€‘å…¼å®¹å®Œæ•´URLå’Œé¢‘é“IDä¸¤ç§æ ¼å¼
                # å¦‚æœä¼ å…¥çš„æ˜¯é¢‘é“IDï¼Œä¹Ÿè¦åŒ¹é…æ•°æ®åº“ä¸­å¯èƒ½å­˜å‚¨çš„å®Œæ•´URL
                # æ„é€ ä¸¤ç§å¯èƒ½çš„åŒ¹é…æ¨¡å¼
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                    AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, channel_id, channel_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_channel_binding_admin(self, website_id: int, channel_id: str) -> bool:
        """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šï¼ˆç®¡ç†å‘˜æƒé™ï¼Œåˆ é™¤æ‰€æœ‰ç”¨æˆ·çš„ç»‘å®šï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ã€ä¿®å¤ã€‘å…¼å®¹å®Œæ•´URLå’Œé¢‘é“IDä¸¤ç§æ ¼å¼
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                ''', (website_id, channel_id, channel_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç®¡ç†å‘˜ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def get_website_config_by_channel(self, channel_id: str, user_id: int = None) -> Dict:
        """æ ¹æ®é¢‘é“IDè·å–ç»‘å®šçš„ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ? AND wcb.user_id = ?
                        LIMIT 1
                    ''', (str(channel_id), user_id))
                else:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ?
                        LIMIT 1
                    ''', (str(channel_id),))
                row = cursor.fetchone()
                if row:
                    return dict(row)
                return None
        except Exception as e:
            logger.error(f"æ ¹æ®é¢‘é“è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return None

    def get_all_bound_channel_ids(self) -> set:
        """ã€æ–°å¢ã€‘é«˜æ•ˆè·å–æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDåˆ—è¡¨ï¼ˆç”¨äºBotç™½åå•ç¼“å­˜ï¼‰

        è¿”å›æ‰€æœ‰å·²ç»‘å®šçš„é¢‘é“IDé›†åˆï¼ŒåŒ…æ‹¬:
        1. website_channel_bindings è¡¨ä¸­çš„æ‰€æœ‰é¢‘é“
        2. ç³»ç»Ÿé…ç½®ä¸­çš„ CNFANS_CHANNEL_ID å’Œ ACBUY_CHANNEL_ID

        Returns:
            set: é¢‘é“IDå­—ç¬¦ä¸²é›†åˆï¼Œç”¨äºO(1)å¿«é€ŸæŸ¥æ‰¾
        """
        try:
            channel_ids = set()

            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 1. ä»ç»‘å®šè¡¨ä¸­è·å–æ‰€æœ‰é¢‘é“ID
                cursor.execute('SELECT DISTINCT channel_id FROM website_channel_bindings')
                rows = cursor.fetchall()
                for row in rows:
                    channel_id = row[0]
                    if channel_id:
                        # å…¼å®¹å®Œæ•´URLæ ¼å¼ï¼Œæå–é¢‘é“ID
                        if 'discord.com/channels/' in channel_id:
                            parts = channel_id.rstrip('/').split('/')
                            if len(parts) >= 1:
                                channel_id = parts[-1]
                        channel_ids.add(str(channel_id))

            # 2. æ·»åŠ ç³»ç»Ÿé…ç½®ä¸­çš„é¢‘é“IDï¼ˆå…¼å®¹æ—§é…ç½®ï¼‰
            try:
                from config import config
                if hasattr(config, 'CNFANS_CHANNEL_ID') and config.CNFANS_CHANNEL_ID:
                    channel_ids.add(str(config.CNFANS_CHANNEL_ID))
                if hasattr(config, 'ACBUY_CHANNEL_ID') and config.ACBUY_CHANNEL_ID:
                    channel_ids.add(str(config.ACBUY_CHANNEL_ID))
            except Exception as e:
                logger.debug(f"è¯»å–ç³»ç»Ÿé…ç½®é¢‘é“IDå¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}")

            logger.debug(f"è·å–åˆ° {len(channel_ids)} ä¸ªå·²ç»‘å®šçš„é¢‘é“ID")
            return channel_ids

        except Exception as e:
            logger.error(f"è·å–å·²ç»‘å®šé¢‘é“IDåˆ—è¡¨å¤±è´¥: {e}")
            return set()

    def generate_website_urls(self, weidian_id: str) -> List[Dict]:
        """æ ¹æ®å¾®åº—IDç”Ÿæˆæ‰€æœ‰ç½‘ç«™çš„URL"""
        try:
            website_configs = self.get_website_configs()
            urls = []

            for config in website_configs:
                try:
                    # æ›¿æ¢URLæ¨¡æ¿ä¸­çš„{id}å ä½ç¬¦
                    url = config['url_template'].replace('{id}', weidian_id)
                    urls.append({
                        'name': config['name'],
                        'display_name': config['display_name'],
                        'url': url,
                        'badge_color': config['badge_color'],
                        'channels': self.get_website_channel_bindings(config['id'])
                    })
                except Exception as e:
                    logger.warning(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥ {config['name']}: {e}")

            return urls
        except Exception as e:
            logger.error(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥: {e}")
            return []

    # ===== ç½‘ç«™è´¦å·ç»‘å®šæ–¹æ³• =====

    def add_website_account_binding(self, website_id: int, account_id: int, role: str, user_id: int) -> bool:
        """æ·»åŠ ç½‘ç«™è´¦å·ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO website_account_bindings
                    (website_id, account_id, role, user_id)
                    VALUES (?, ?, ?, ?)
                ''', (website_id, account_id, role, user_id))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_account_binding(self, website_id: int, account_id: int, user_id: int) -> bool:
        """ç§»é™¤ç½‘ç«™è´¦å·ç»‘å®šï¼ˆæŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM website_account_bindings
                    WHERE website_id = ? AND account_id = ? AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, account_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç§»é™¤ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return False

    def get_website_account_bindings(self, website_id: int, user_id: int = None) -> List[Dict]:
        """è·å–ç½‘ç«™çš„æ‰€æœ‰è´¦å·ç»‘å®šï¼ˆå¯é€‰æŒ‰ç”¨æˆ·è¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ? AND wab.user_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™è´¦å·ç»‘å®šå¤±è´¥: {e}")
            return []

    def get_account_website_bindings(self, account_id: int) -> List[Dict]:
        """è·å–è´¦å·çš„æ‰€æœ‰ç½‘ç«™ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT wab.id, wab.website_id, wab.role, wab.created_at,
                           wc.name, wc.display_name
                    FROM website_account_bindings wab
                    JOIN website_configs wc ON wab.website_id = wc.id
                    WHERE wab.account_id = ?
                    ORDER BY wab.created_at
                ''', (account_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–è´¦å·ç½‘ç«™ç»‘å®šå¤±è´¥: {e}")
            return []

    def get_website_senders(self, website_id: int) -> List[int]:
        """è·å–ç½‘ç«™çš„å‘é€è´¦å·IDåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('sender', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™å‘é€è´¦å·å¤±è´¥: {e}")
            return []

    def get_website_listeners(self, website_id: int) -> List[int]:
        """è·å–ç½‘ç«™çš„ç›‘å¬è´¦å·IDåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('listener', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™ç›‘å¬è´¦å·å¤±è´¥: {e}")
            return []

    def update_website_config_rotation(self, config_id: int, rotation_interval: int) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„è½®æ¢é—´éš”"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_interval = ?
                    WHERE id = ?
                ''', (rotation_interval, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™è½®æ¢é—´éš”å¤±è´¥: {e}")
            return False

    def update_website_config_rotation_enabled(self, config_id: int, rotation_enabled: int) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„è½®æ¢å¯ç”¨çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_enabled = ?
                    WHERE id = ?
                ''', (rotation_enabled, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®è½®æ¢å¯ç”¨çŠ¶æ€å¤±è´¥: {e}")
            return False

    def update_website_message_filters(self, config_id: int, message_filters: str) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®çš„æ¶ˆæ¯è¿‡æ»¤æ¡ä»¶"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET message_filters = ?
                    WHERE id = ?
                ''', (message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤æ¡ä»¶å¤±è´¥: {e}")
            return False

    # ===== ç”¨æˆ·çº§åˆ«çš„ç½‘ç«™è®¾ç½®æ–¹æ³• =====

    def get_user_website_settings(self, user_id: int, website_id: int) -> Dict:
        """è·å–ç”¨æˆ·çš„ç½‘ç«™è®¾ç½®ï¼ˆè½®æ¢å’Œè¿‡æ»¤ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT rotation_interval, rotation_enabled, message_filters
                    FROM user_website_settings
                    WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                row = cursor.fetchone()
                if row:
                    return {
                        'rotation_interval': row['rotation_interval'],
                        'rotation_enabled': row['rotation_enabled'],
                        'message_filters': row['message_filters']
                    }
                # è¿”å›é»˜è®¤å€¼
                return {
                    'rotation_interval': 180,
                    'rotation_enabled': 1,
                    'message_filters': '[]'
                }
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·ç½‘ç«™è®¾ç½®å¤±è´¥: {e}")
            return {'rotation_interval': 180, 'rotation_enabled': 1, 'message_filters': '[]'}

    def update_user_website_rotation(self, user_id: int, website_id: int, rotation_interval: int = None, rotation_enabled: int = None) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„ç½‘ç«™è½®æ¢è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # å…ˆæ£€æŸ¥æ˜¯å¦å­˜åœ¨è®°å½•
                cursor.execute('''
                    SELECT id FROM user_website_settings WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                exists = cursor.fetchone()

                if exists:
                    # æ›´æ–°ç°æœ‰è®°å½•
                    updates = []
                    params = []
                    if rotation_interval is not None:
                        updates.append('rotation_interval = ?')
                        params.append(rotation_interval)
                    if rotation_enabled is not None:
                        updates.append('rotation_enabled = ?')
                        params.append(rotation_enabled)
                    if updates:
                        updates.append('updated_at = CURRENT_TIMESTAMP')
                        params.extend([user_id, website_id])
                        cursor.execute(f'''
                            UPDATE user_website_settings
                            SET {', '.join(updates)}
                            WHERE user_id = ? AND website_id = ?
                        ''', params)
                else:
                    # æ’å…¥æ–°è®°å½•
                    cursor.execute('''
                        INSERT INTO user_website_settings (user_id, website_id, rotation_interval, rotation_enabled)
                        VALUES (?, ?, ?, ?)
                    ''', (user_id, website_id, rotation_interval or 180, rotation_enabled if rotation_enabled is not None else 1))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·ç½‘ç«™è½®æ¢è®¾ç½®å¤±è´¥: {e}")
            return False

    def update_user_website_filters(self, user_id: int, website_id: int, message_filters: str) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # ä½¿ç”¨ INSERT OR REPLACE
                cursor.execute('''
                    INSERT INTO user_website_settings (user_id, website_id, message_filters)
                    VALUES (?, ?, ?)
                    ON CONFLICT(user_id, website_id) DO UPDATE SET
                        message_filters = excluded.message_filters,
                        updated_at = CURRENT_TIMESTAMP
                ''', (user_id, website_id, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·ç½‘ç«™æ¶ˆæ¯è¿‡æ»¤å¤±è´¥: {e}")
            return False

    def get_system_stats(self) -> Dict:
        """è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–åº—é“ºæ•°é‡ï¼ˆä»shopsè¡¨ç»Ÿè®¡ï¼‰
                cursor.execute("SELECT COUNT(*) FROM shops")
                shop_count = cursor.fetchone()[0] or 0

                # è·å–å•†å“æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM products")
                product_count = cursor.fetchone()[0] or 0

                # è·å–å›¾ç‰‡æ•°é‡ï¼ˆåªç»Ÿè®¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡ï¼‰
                cursor.execute("""
                    SELECT COUNT(*) FROM product_images
                    WHERE product_id IN (SELECT id FROM products)
                """)
                image_count = cursor.fetchone()[0] or 0

                # è·å–ç”¨æˆ·æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
                user_count = cursor.fetchone()[0] or 0

                return {
                    'shop_count': shop_count,
                    'product_count': product_count,
                    'image_count': image_count,
                    'user_count': user_count
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {e}")
            return {'shop_count': 0, 'product_count': 0, 'image_count': 0, 'user_count': 0}

    def cleanup_orphaned_images(self) -> int:
        """æ¸…ç†å­¤ç«‹çš„å›¾ç‰‡è®°å½•ï¼ˆæ²¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # åˆ é™¤æ²¡æœ‰å¯¹åº”å•†å“çš„å›¾ç‰‡è®°å½•
                cursor.execute("""
                    DELETE FROM product_images
                    WHERE product_id NOT IN (SELECT id FROM products)
                """)
                deleted_count = cursor.rowcount
                conn.commit()
                if deleted_count > 0:
                    logger.info(f"æ¸…ç†äº† {deleted_count} æ¡å­¤ç«‹çš„å›¾ç‰‡è®°å½•")
                return deleted_count
        except Exception as e:
            logger.error(f"æ¸…ç†å­¤ç«‹å›¾ç‰‡è®°å½•å¤±è´¥: {e}")
            return 0

    def get_active_announcements(self) -> List[Dict]:
        """è·å–æ´»è·ƒçš„ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, title, content, created_at, updated_at
                    FROM system_announcements
                    WHERE is_active = 1
                    ORDER BY updated_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return []

    def create_announcement(self, title: str, content: str) -> bool:
        """åˆ›å»ºç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO system_announcements (title, content)
                    VALUES (?, ?)
                ''', (title, content))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"åˆ›å»ºç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def update_announcement(self, announcement_id: int, title: str, content: str, is_active: bool) -> bool:
        """æ›´æ–°ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE system_announcements
                    SET title = ?, content = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (title, content, is_active, announcement_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def delete_announcement(self, announcement_id: int) -> bool:
        """åˆ é™¤ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM system_announcements WHERE id = ?', (announcement_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def get_message_filters(self) -> List[Dict]:
        """è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, filter_type, filter_value, is_active, created_at
                    FROM message_filters
                    WHERE is_active = 1
                    ORDER BY created_at
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return []

    def add_message_filter(self, filter_type: str, filter_value: str) -> bool:
        """æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO message_filters (filter_type, filter_value)
                    VALUES (?, ?)
                ''', (filter_type, filter_value))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def update_message_filter(self, filter_id: int, filter_type: str, filter_value: str, is_active: bool) -> bool:
        """æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE message_filters
                    SET filter_type = ?, filter_value = ?, is_active = ?
                    WHERE id = ?
                ''', (filter_type, filter_value, is_active, filter_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def delete_message_filter(self, filter_id: int) -> bool:
        """åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM message_filters WHERE id = ?', (filter_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def get_custom_replies(self) -> List[Dict]:
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, reply_type, content, image_url, is_active, priority, created_at
                    FROM custom_replies
                    WHERE is_active = 1
                    ORDER BY priority DESC, created_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return []

    def add_custom_reply(self, reply_type: str, content: str = None, image_url: str = None, priority: int = 0) -> bool:
        """æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO custom_replies (reply_type, content, image_url, priority)
                    VALUES (?, ?, ?, ?)
                ''', (reply_type, content, image_url, priority))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def update_custom_reply(self, reply_id: int, reply_type: str, content: str = None, image_url: str = None, priority: int = 0, is_active: bool = True) -> bool:
        """æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE custom_replies
                    SET reply_type = ?, content = ?, image_url = ?, priority = ?, is_active = ?
                    WHERE id = ?
                ''', (reply_type, content, image_url, priority, is_active, reply_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def delete_custom_reply(self, reply_id: int) -> bool:
        """åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM custom_replies WHERE id = ?', (reply_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def get_products_by_user_shops(self, user_shops: List[str], limit: int = None, offset: int = 0) -> Dict:
        """æ ¹æ®ç”¨æˆ·åº—é“ºæƒé™è·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor = conn.cursor()

                if user_shops is None:
                    # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°æ‰€æœ‰å•†å“ï¼ˆä¸é™åˆ¶åº—é“ºï¼‰- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
                    if limit is None or limit <= 0:
                        # ä¸€æ¬¡æ€§è·å–æ‰€æœ‰å•†å“å’Œå¯¹åº”çš„å›¾ç‰‡ç´¢å¼•
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                        '''
                        cursor.execute(query)
                        rows = cursor.fetchall()

                        # è·å–æ€»æ•°
                        cursor.execute('SELECT COUNT(*) FROM products')
                        total = cursor.fetchone()[0]
                    else:
                        # åˆ†é¡µæŸ¥è¯¢ - ä½¿ç”¨å­æŸ¥è¯¢ä¼˜åŒ–æ€§èƒ½
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                            LIMIT ? OFFSET ?
                        '''
                        cursor.execute(query, [limit, offset])
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    cursor.execute('SELECT COUNT(*) FROM products')
                    total = cursor.fetchone()[0]

                    products = []
                    for row in rows:
                        prod = dict(row)
                        # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                        if prod.get('image_indices'):
                            image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                            prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                        else:
                            prod['images'] = []

                        # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                        prod['weidianUrl'] = prod.get('product_url')
                        prod['englishTitle'] = prod.get('english_title') or ''
                        prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                        prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                        prod['createdAt'] = prod.get('created_at')
                        prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                        prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'

                        # æå–å¾®åº—ID
                        try:
                            import re
                            m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                            prod['weidianId'] = m.group(1) if m else ''
                        except:
                            prod['weidianId'] = ''

                        products.append(prod)

                    return {'products': products, 'total': total}

                elif not user_shops:
                    # å¦‚æœç”¨æˆ·æ²¡æœ‰åº—é“ºæƒé™ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # ç¡®ä¿user_shopsæ˜¯listç±»å‹
                if not isinstance(user_shops, list):
                    user_shops = []

                # æ ¹æ®shop_idæ‰¾åˆ°å¯¹åº”çš„shop_name
                shop_names = []
                for shop_id in user_shops:
                    cursor.execute("SELECT name FROM shops WHERE shop_id = ?", (shop_id,))
                    shop_row = cursor.fetchone()
                    if shop_row:
                        shop_names.append(shop_row[0])

                if not shop_names:
                    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åº—é“ºåç§°ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # æ„å»ºINæŸ¥è¯¢ - ä¼˜åŒ–æ€§èƒ½
                placeholders = ','.join('?' * len(shop_names))
                if limit is None or limit <= 0:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                    '''
                    cursor.execute(query, shop_names)
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                    cursor.execute(count_query, shop_names)
                    total = cursor.fetchone()[0]
                else:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                        LIMIT ? OFFSET ?
                    '''
                    cursor.execute(query, shop_names + [limit, offset])
                rows = cursor.fetchall()

                # è·å–æ€»æ•°
                count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                cursor.execute(count_query, shop_names)
                total = cursor.fetchone()[0]

                products = []
                for row in rows:
                    prod = dict(row)
                    # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                    if prod.get('image_indices'):
                        image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                        prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                    else:
                        prod['images'] = []

                    # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                    prod['weidianUrl'] = prod.get('product_url')
                    prod['englishTitle'] = prod.get('english_title') or ''
                    prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                    prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                    prod['createdAt'] = prod.get('created_at')
                    prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                    prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'
                    prod['customReplyText'] = prod.get('custom_reply_text') or ''
                    # è§£æè‡ªå®šä¹‰å›å¤å›¾ç‰‡ç´¢å¼•
                    try:
                        custom_reply_images = prod.get('custom_reply_images')
                        if custom_reply_images:
                            prod['selectedImageIndexes'] = json.loads(custom_reply_images)
                        else:
                            prod['selectedImageIndexes'] = []
                    except:
                        prod['selectedImageIndexes'] = []

                    # ä¿®å¤ï¼šè§£ææœ¬åœ°ä¸Šä¼ çš„è‡ªå®šä¹‰å›å¤å›¾ç‰‡ (uploaded_reply_images)
                    # å‰ç«¯ç»„ä»¶ ScraperView éœ€è¦ uploadedImages å­—æ®µ (URLåˆ—è¡¨) æ¥æ˜¾ç¤º"å·²ä¿å­˜å›¾ç‰‡"
                    try:
                        if prod.get('uploaded_reply_images'):
                            import json
                            filenames = json.loads(prod['uploaded_reply_images'])
                            prod['uploadedImages'] = [f"/api/custom_reply_image/{prod['id']}/{fn}" for fn in filenames]
                        else:
                            prod['uploadedImages'] = []
                    except:
                        prod['uploadedImages'] = []

                    # æå–å¾®åº—ID
                    try:
                        import re
                        m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                        prod['weidianId'] = m.group(1) if m else ''
                    except:
                        prod['weidianId'] = ''

                    products.append(prod)

                return {'products': products, 'total': total}

        except Exception as e:
            print(f"DEBUG: Exception in get_products_by_user_shops: {type(e).__name__}: {e}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            logger.error("è·å–ç”¨æˆ·å•†å“å¤±è´¥: %s", str(e))
            return {'products': [], 'total': 0}

    def get_global_reply_config(self) -> Dict[str, float]:
        """è·å–å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT min_delay, max_delay FROM global_reply_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {'min_delay': row[0], 'max_delay': row[1]}
                return {'min_delay': 3.0, 'max_delay': 8.0}  # é»˜è®¤å€¼
        except Exception as e:
            logger.error(f"è·å–å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return {'min_delay': 3.0, 'max_delay': 8.0}

    def update_global_reply_config(self, min_delay: float, max_delay: float) -> bool:
        """æ›´æ–°å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE global_reply_config
                    SET min_delay = ?, max_delay = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''', (min_delay, max_delay))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return False

    def get_system_config(self) -> Dict[str, any]:
        """è·å–ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads FROM system_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_channel_id': row[0] or '',
                        'download_threads': row[1] or 4,
                        'feature_extract_threads': row[2] or 4,
                        'discord_similarity_threshold': row[3] or 0.6,
                        'cnfans_channel_id': row[4] or '',
                        'acbuy_channel_id': row[5] or '',
                        'scrape_threads': row[6] or 2
                    }
                # å¦‚æœæ²¡æœ‰é…ç½®è®°å½•ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads)
                    VALUES (1, '', 4, 4, 0.6, '', '', 2)
                ''')
                conn.commit()
                return {
                    'discord_channel_id': '',
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'cnfans_channel_id': '',
                    'acbuy_channel_id': '',
                    'scrape_threads': 2
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return {
                'discord_channel_id': '',
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'cnfans_channel_id': '',
                'acbuy_channel_id': '',
                'scrape_threads': 2
            }

    def get_user_settings(self, user_id: int) -> Dict[str, any]:
        """è·å–ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT download_threads, feature_extract_threads, discord_similarity_threshold,
                           global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                           keyword_reply_enabled, image_reply_enabled
                    FROM user_settings WHERE user_id = ?
                ''', (user_id,))
                row = cursor.fetchone()
                if row:
                    return {
                        'download_threads': row[0] or 4,
                        'feature_extract_threads': row[1] or 4,
                        'discord_similarity_threshold': row[2] or 0.6,
                        'global_reply_min_delay': row[3] or 3.0,
                        'global_reply_max_delay': row[4] or 8.0,
                        'user_blacklist': row[5] or '',
                        'keyword_filters': row[6] or '',
                        'keyword_reply_enabled': row[7] if row[7] is not None else 1,
                        'image_reply_enabled': row[8] if row[8] is not None else 1,
                    }
                # å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®ï¼Œè¿”å›é»˜è®¤å€¼
                return {
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'global_reply_min_delay': 3.0,
                    'global_reply_max_delay': 8.0,
                    'user_blacklist': '',
                    'keyword_filters': '',
                    'keyword_reply_enabled': 1,
                    'image_reply_enabled': 1,
                }
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return {
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'global_reply_min_delay': 3.0,
                'global_reply_max_delay': 8.0,
                'user_blacklist': '',
                'keyword_filters': '',
                'keyword_reply_enabled': 1,
                'image_reply_enabled': 1,
            }

    def update_user_settings(self, user_id: int, download_threads: int = None,
                           feature_extract_threads: int = None, discord_similarity_threshold: float = None,
                           global_reply_min_delay: float = None, global_reply_max_delay: float = None,
                           user_blacklist: str = None, keyword_filters: str = None,
                           keyword_reply_enabled: int = None, image_reply_enabled: int = None) -> bool:
        """æ›´æ–°ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰è®¾ç½®
                cursor.execute('SELECT id FROM user_settings WHERE user_id = ?', (user_id,))
                existing = cursor.fetchone()

                if existing:
                    # æ›´æ–°ç°æœ‰è®¾ç½®
                    update_fields = []
                    params = []

                    if download_threads is not None:
                        update_fields.append('download_threads = ?')
                        params.append(download_threads)

                    if feature_extract_threads is not None:
                        update_fields.append('feature_extract_threads = ?')
                        params.append(feature_extract_threads)

                    if discord_similarity_threshold is not None:
                        update_fields.append('discord_similarity_threshold = ?')
                        params.append(discord_similarity_threshold)

                    if global_reply_min_delay is not None:
                        update_fields.append('global_reply_min_delay = ?')
                        params.append(global_reply_min_delay)

                    if global_reply_max_delay is not None:
                        update_fields.append('global_reply_max_delay = ?')
                        params.append(global_reply_max_delay)

                    if user_blacklist is not None:
                        update_fields.append('user_blacklist = ?')
                        params.append(user_blacklist)

                    if keyword_filters is not None:
                        update_fields.append('keyword_filters = ?')
                        params.append(keyword_filters)

                    if keyword_reply_enabled is not None:
                        update_fields.append('keyword_reply_enabled = ?')
                        params.append(keyword_reply_enabled)

                    if image_reply_enabled is not None:
                        update_fields.append('image_reply_enabled = ?')
                        params.append(image_reply_enabled)

                    if update_fields:
                        update_fields.append('updated_at = CURRENT_TIMESTAMP')
                        sql = f'UPDATE user_settings SET {", ".join(update_fields)} WHERE user_id = ?'
                        params.append(user_id)
                        cursor.execute(sql, params)
                else:
                    # æ’å…¥æ–°è®¾ç½®
                    cursor.execute('''
                        INSERT INTO user_settings
                        (user_id, download_threads, feature_extract_threads, discord_similarity_threshold,
                         global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                         keyword_reply_enabled, image_reply_enabled)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        user_id,
                        download_threads or 4,
                        feature_extract_threads or 4,
                        discord_similarity_threshold or 0.6,
                        global_reply_min_delay or 3.0,
                        global_reply_max_delay or 8.0,
                        user_blacklist or '',
                        keyword_filters or '',
                        keyword_reply_enabled if keyword_reply_enabled is not None else 1,
                        image_reply_enabled if image_reply_enabled is not None else 1
                    ))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return False

    def update_system_config(self, discord_channel_id: str = None, discord_similarity_threshold: float = None,
                           cnfans_channel_id: str = None, acbuy_channel_id: str = None) -> bool:
        """æ›´æ–°ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # é¦–å…ˆç¡®ä¿é…ç½®è®°å½•å­˜åœ¨
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')

                # æ„å»ºæ›´æ–°è¯­å¥
                update_fields = []
                params = []

                if discord_channel_id is not None:
                    update_fields.append('discord_channel_id = ?')
                    params.append(discord_channel_id)

                if discord_similarity_threshold is not None:
                    update_fields.append('discord_similarity_threshold = ?')
                    params.append(discord_similarity_threshold)

                if cnfans_channel_id is not None:
                    update_fields.append('cnfans_channel_id = ?')
                    params.append(cnfans_channel_id)

                if acbuy_channel_id is not None:
                    update_fields.append('acbuy_channel_id = ?')
                    params.append(acbuy_channel_id)

                if update_fields:
                    update_fields.append('updated_at = CURRENT_TIMESTAMP')
                    sql = f'UPDATE system_config SET {", ".join(update_fields)} WHERE id = 1'
                    cursor.execute(sql, params)
                    conn.commit()
                    return True
                return False
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return False

    # ===== åº—é“ºç®¡ç†æ–¹æ³• =====

    def add_shop(self, shop_id: str, name: str) -> bool:
        """æ·»åŠ æ–°åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥åº—é“ºæ˜¯å¦å·²å­˜åœ¨
                cursor.execute('SELECT id FROM shops WHERE shop_id = ?', (shop_id,))
                if cursor.fetchone():
                    logger.warning(f"åº—é“º {shop_id} å·²å­˜åœ¨")
                    return False

                cursor.execute('''
                    INSERT INTO shops (shop_id, name, product_count)
                    VALUES (?, ?, 0)
                ''', (shop_id, name))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ åº—é“ºå¤±è´¥: {e}")
            return False

    def get_all_shops(self) -> List[Dict]:
        """è·å–æ‰€æœ‰åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops ORDER BY created_at DESC')
                rows = cursor.fetchall()

                shops = []
                for row in rows:
                    shops.append({
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    })
                return shops
        except Exception as e:
            logger.error(f"è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_shop_by_id(self, shop_id: str) -> Optional[Dict]:
        """æ ¹æ®shop_idè·å–åº—é“ºä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops WHERE shop_id = ?', (shop_id,))
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    }
                return None
        except Exception as e:
            logger.error(f"è·å–åº—é“ºä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_shop_product_count(self, shop_id: str, product_count: int) -> bool:
        """æ›´æ–°åº—é“ºçš„å•†å“æ•°é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE shops
                    SET product_count = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE shop_id = ?
                ''', (product_count, shop_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°åº—é“ºå•†å“æ•°é‡å¤±è´¥: {e}")
            return False

    def delete_shop(self, shop_id: str) -> bool:
        """åˆ é™¤åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM shops WHERE shop_id = ?', (shop_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤åº—é“ºå¤±è´¥: {e}")
            return False

    # ========== æŠ“å–çŠ¶æ€ç®¡ç†æ–¹æ³• ==========

    def get_scrape_status(self) -> Dict:
        """è·å–æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM scrape_status WHERE id = 1')
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'is_scraping': bool(row[1]),
                        'stop_signal': bool(row[2]),
                        'current_shop_id': row[3],
                        'total': row[4] or 0,
                        'processed': row[5] or 0,
                        'success': row[6] or 0,
                        'progress': row[7] or 0.0,
                        'message': row[8] or 'ç­‰å¾…å¼€å§‹...',
                        'completed': bool(row[9]),
                        'thread_id': row[10],
                        'updated_at': row[11]
                    }
                else:
                    # å¦‚æœæ²¡æœ‰è®°å½•ï¼Œåˆ›å»ºé»˜è®¤è®°å½•
                    return self.reset_scrape_status()

        except Exception as e:
            logger.error(f"è·å–æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'è·å–çŠ¶æ€å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

    def update_scrape_status(self, **kwargs) -> bool:
        """æ›´æ–°æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºæ›´æ–°è¯­å¥
                fields = []
                values = []
                for key, value in kwargs.items():
                    if key in ['is_scraping', 'stop_signal', 'completed']:
                        fields.append(f'{key} = ?')
                        values.append(1 if value else 0)
                    elif key in ['total', 'processed', 'success']:
                        fields.append(f'{key} = ?')
                        values.append(int(value) if value is not None else 0)
                    elif key == 'progress':
                        fields.append(f'{key} = ?')
                        values.append(float(value) if value is not None else 0.0)
                    elif key in ['current_shop_id', 'message', 'thread_id']:
                        fields.append(f'{key} = ?')
                        values.append(str(value) if value is not None else None)

                if fields:
                    fields.append('updated_at = CURRENT_TIMESTAMP')
                    query = f'UPDATE scrape_status SET {", ".join(fields)} WHERE id = 1'
                    cursor.execute(query, values)
                    conn.commit()
                    return cursor.rowcount > 0

                return False

        except Exception as e:
            logger.error(f"æ›´æ–°æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return False

    def reset_scrape_status(self) -> Dict:
        """é‡ç½®æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scrape_status SET
                        is_scraping = 0,
                        stop_signal = 0,
                        current_shop_id = NULL,
                        total = 0,
                        processed = 0,
                        success = 0,
                        progress = 0,
                        message = 'ç­‰å¾…å¼€å§‹...',
                        completed = 0,
                        thread_id = NULL,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''')
                conn.commit()

                return {
                    'is_scraping': False,
                    'stop_signal': False,
                    'current_shop_id': None,
                    'total': 0,
                    'processed': 0,
                    'success': 0,
                    'progress': 0.0,
                    'message': 'ç­‰å¾…å¼€å§‹...',
                    'completed': False,
                    'thread_id': None,
                    'updated_at': None
                }

        except Exception as e:
            logger.error(f"é‡ç½®æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'é‡ç½®å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

# å…¨å±€æ•°æ®åº“å®ä¾‹
db = Database()


# ===== è´¦å·ç®¡ç†æ–¹æ³•æ‰©å±• =====

def get_all_accounts() -> List[Dict]:
    """è·å–æ‰€æœ‰Discordè´¦å·"""
    return db.get_discord_accounts_by_user(None)


def add_account(token: str, username: str = '') -> int:
    """æ·»åŠ æ–°çš„Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO discord_accounts (token, username, status)
                VALUES (?, ?, 'offline')
            ''', (token, username or f'è´¦å·_{token[:8]}'))
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        logger.error(f"æ·»åŠ Discordè´¦å·å¤±è´¥: {e}")
        raise e


def get_account_by_id(account_id: int) -> Optional[Dict]:
    """æ ¹æ®IDè·å–Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, username, token, status, last_active, created_at FROM discord_accounts WHERE id = ?',
                (account_id,)
            )
            row = cursor.fetchone()
            return dict(row) if row else None
    except Exception as e:
        logger.error(f"è·å–è´¦å·å¤±è´¥: {e}")
        return None


def delete_account(account_id: int) -> bool:
    """åˆ é™¤Discordè´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM discord_accounts WHERE id = ?', (account_id,))
            conn.commit()
            return cursor.rowcount > 0
    except Exception as e:
        logger.error(f"åˆ é™¤è´¦å·å¤±è´¥: {e}")
        return False


def get_products_by_shop(shop_name: str) -> List[Dict]:
    """æ ¹æ®åº—é“ºåè·å–å•†å“åˆ—è¡¨"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, product_url, title, cnfans_url, acbuy_url, shop_name FROM products WHERE shop_name = ?',
                (shop_name,)
            )
            return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        logger.error(f"è·å–å•†å“åˆ—è¡¨å¤±è´¥: {e}")
        return []


# ä¸º Database ç±»æ·»åŠ æ–¹æ³•åˆ«å
Database.get_all_accounts = lambda self: self.get_discord_accounts_by_user(None)
Database.add_account = lambda self, token, username='': add_account(token, username)
Database.get_account_by_id = lambda self, account_id: get_account_by_id(account_id)
Database.delete_account = lambda self, account_id: delete_account(account_id)
Database.get_products_by_shop = lambda self, shop_name: get_products_by_shop(shop_name)

===== backend/license_manager.py =====
import datetime as dt
import hashlib
import json
import os
import platform
import uuid
from typing import Any, Dict, Optional, Tuple

import requests

from config import config

LICENSE_FILE = os.path.join(os.path.dirname(__file__), 'data', 'license.json')


def generate_hwid() -> str:
    """ç”Ÿæˆç¨³å®šçš„ç¡¬ä»¶æ ‡è¯†ï¼Œç”¨äºè®¸å¯è¯ç»‘å®šã€‚"""
    try:
        mac = ':'.join(
            ['{:02x}'.format((uuid.getnode() >> i) & 0xff) for i in range(0, 48, 8)]
        )[0:17]
        system_info = f"{platform.machine()}-{platform.system()}-{platform.node()}-{mac}"
        return hashlib.sha256(system_info.encode()).hexdigest()[:32].upper()
    except Exception:
        return uuid.uuid4().hex[:32].upper()


def _ensure_data_dir() -> None:
    os.makedirs(os.path.dirname(LICENSE_FILE), exist_ok=True)


def load_license() -> Optional[Dict[str, Any]]:
    try:
        with open(LICENSE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return None
    except Exception:
        return None


def save_license(data: Dict[str, Any]) -> bool:
    try:
        _ensure_data_dir()
        with open(LICENSE_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=True, indent=2)
        return True
    except Exception:
        return False


def mask_license_key(key: Optional[str]) -> str:
    if not key:
        return ''
    if len(key) <= 8:
        return f"{key[:2]}{'*' * max(len(key) - 4, 0)}{key[-2:]}"
    return f"{key[:4]}{'*' * 4}{key[-4:]}"


def _parse_datetime(value: Optional[str]) -> Optional[dt.datetime]:
    if not value:
        return None
    try:
        return dt.datetime.fromisoformat(value)
    except ValueError:
        return None


def validate_local_license() -> Tuple[bool, Dict[str, Any]]:
    data = load_license()
    if not data:
        return False, {'reason': 'missing', 'message': 'æœªæ‰¾åˆ°è®¸å¯è¯ï¼Œè¯·å…ˆæ¿€æ´»'}

    saved_hwid = data.get('hwid')
    current_hwid = generate_hwid()
    if saved_hwid != current_hwid:
        return False, {'reason': 'hwid_mismatch', 'message': 'è®¸å¯è¯ä¸å½“å‰è®¾å¤‡ä¸åŒ¹é…'}

    days = data.get('days')
    activated_at = _parse_datetime(data.get('activated_at'))
    if days is None or activated_at is None:
        return False, {'reason': 'invalid', 'message': 'è®¸å¯è¯ä¿¡æ¯ä¸å®Œæ•´'}

    if int(days) != -1:
        expires_at = activated_at + dt.timedelta(days=int(days))
        if dt.datetime.utcnow() > expires_at:
            return False, {'reason': 'expired', 'message': 'è®¸å¯è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°æ¿€æ´»'}
        expires_at_str = expires_at.isoformat()
    else:
        expires_at_str = None

    return True, {
        'license_key': mask_license_key(data.get('license_key')),
        'days': int(days),
        'activated_at': activated_at.isoformat(),
        'expires_at': expires_at_str
    }


def activate_license(license_key: str) -> Tuple[bool, Dict[str, Any]]:
    normalized_key = license_key.strip().upper()
    if config.LICENSE_ALLOW_TEST_KEYS:
        allowed = {key.upper() for key in config.LICENSE_TEST_KEYS}
        if normalized_key in allowed:
            license_data = {
                'license_key': license_key,
                'hwid': generate_hwid(),
                'days': -1,
                'activated_at': dt.datetime.utcnow().isoformat()
            }
            if not save_license(license_data):
                return False, {'message': 'ä¿å­˜è®¸å¯è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç£ç›˜æƒé™'}
            return True, {'message': 'æœ¬åœ°æµ‹è¯•å¯†é’¥æ¿€æ´»æˆåŠŸ', 'days': -1}

    hwid = generate_hwid()
    try:
        response = requests.post(
            f"{config.LICENSE_SERVER_URL}/api/activate",
            json={'key': license_key, 'hwid': hwid},
            timeout=10
        )
    except requests.exceptions.Timeout:
        return False, {'message': 'è¿æ¥æœåŠ¡å™¨è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ'}
    except requests.exceptions.ConnectionError:
        return False, {'message': 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ'}
    except Exception as exc:
        return False, {'message': f'æ¿€æ´»å¤±è´¥: {exc}'}

    if response.status_code == 200:
        try:
            data = response.json()
        except ValueError:
            return False, {'message': 'æœåŠ¡å™¨è¿”å›æ— æ•ˆæ•°æ®'}

        if data.get('status') == 'success':
            days = data.get('days', -1)
            license_data = {
                'license_key': license_key,
                'hwid': hwid,
                'days': int(days),
                'activated_at': dt.datetime.utcnow().isoformat()
            }
            if not save_license(license_data):
                return False, {'message': 'ä¿å­˜è®¸å¯è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç£ç›˜æƒé™'}
            return True, {
                'message': data.get('msg', 'æ¿€æ´»æˆåŠŸ'),
                'days': int(days)
            }

        return False, {'message': data.get('detail', 'æ¿€æ´»å¤±è´¥')}

    if response.status_code == 403:
        return False, {'message': 'è¯¥å¯†é’¥å·²è¢«å…¶ä»–è®¾å¤‡æ¿€æ´»ï¼Œæ— æ³•é‡å¤ä½¿ç”¨'}
    if response.status_code == 404:
        return False, {'message': 'å¯†é’¥ä¸å­˜åœ¨æˆ–å·²å¤±æ•ˆ'}

    return False, {'message': f'æœåŠ¡å™¨é”™è¯¯: {response.status_code}'}

===== backend/weidian_scraper.py =====
import os
import requests
import re
import json
import time
import logging
from urllib.parse import urlparse, parse_qs, quote
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

COOKIE_FILE = os.path.join(os.path.dirname(__file__), 'data', 'weidian_cookies.txt')


def load_cookie_string() -> Optional[str]:
    try:
        with open(COOKIE_FILE, 'r', encoding='utf-8') as f:
            value = f.read().strip()
            return value if value else None
    except FileNotFoundError:
        return None
    except Exception as e:
        logger.warning(f"åŠ è½½Cookieså¤±è´¥: {e}")
        return None


def save_cookie_string(cookie_string: str) -> bool:
    try:
        os.makedirs(os.path.dirname(COOKIE_FILE), exist_ok=True)
        with open(COOKIE_FILE, 'w', encoding='utf-8') as f:
            f.write(cookie_string.strip())
        return True
    except Exception as e:
        logger.error(f"ä¿å­˜Cookieså¤±è´¥: {e}")
        return False


class WeidianScraper:
    """å¾®åº—å•†å“ä¿¡æ¯çˆ¬è™« - ä½¿ç”¨å®˜æ–¹API"""

    def __init__(self):
        self.session = requests.Session()

        # [æ–°å¢] ä¼˜åŒ–è¿æ¥æ± ï¼Œé˜²æ­¢å¤šçº¿ç¨‹æŠ“å–æ—¶è¿æ¥æ•°ä¸å¤Ÿ
        from requests.adapters import HTTPAdapter
        # è®¾ç½®è¿æ¥æ± å¤§å°ä¸º 50ï¼Œé‡è¯•æ¬¡æ•° 3
        adapter = HTTPAdapter(pool_connections=50, pool_maxsize=50, max_retries=3)
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)

        # ä¿®å¤ï¼šæ›´æ–° Headersï¼Œå®Œå…¨åŒ¹é…ä½ çš„ CURL è¯·æ±‚
        self.session.headers.update({
            'accept': 'application/json, */*',  # æ³¨æ„ï¼šcurlä¸­æ˜¯ application/json, / ä½†å®é™…åº”è¯¥æ˜¯ /*
            'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'origin': 'https://weidian.com',
            'priority': 'u=1, i',
            'referer': 'https://weidian.com/',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-site',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
        })

        # ä¿®å¤ï¼šæ›´æ–° Cookies
        self.session.cookies.update({
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '6',
            '__spider__sessionid': 'e0e858ac8efb20a2'
        })
        stored_cookies = load_cookie_string()
        if stored_cookies:
            self.update_cookies(stored_cookies)

    def update_cookies(self, cookie_string: str):
        """å…è®¸ç”¨æˆ·ä»å¤–éƒ¨æ›´æ–° Cookies"""
        try:
            from http.cookies import SimpleCookie

            cookie = SimpleCookie()
            cookie.load(cookie_string)
            cookies_dict = {k: v.value for k, v in cookie.items()}
            self.session.cookies.update(cookies_dict)
            logger.info("Cookies å·²æ›´æ–°")
        except Exception as e:
            logger.warning(f"æ›´æ–°Cookieså¤±è´¥: {e}")

    def extract_item_id(self, url: str) -> Optional[str]:
        """ä»å¾®åº—URLä¸­æå–å•†å“ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # å°è¯•ä»è·¯å¾„ä¸­æå–
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # å°è¯•å…¶ä»–æ ¼å¼
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"æå–å•†å“IDå¤±è´¥: {e}")
            return None

    def scrape_product_info(self, url: str) -> Optional[Dict]:
        """
        æŠ“å–å¾®åº—å•†å“ä¿¡æ¯ - ä½¿ç”¨å®˜æ–¹API
        è¿”å›åŒ…å«æ ‡é¢˜ã€æè¿°ã€å›¾ç‰‡ç­‰ä¿¡æ¯çš„å­—å…¸
        """
        try:
            item_id = self.extract_item_id(url)
            if not item_id:
                logger.error(f"æ— æ³•ä»URLæå–å•†å“ID: {url}")
                return None

            logger.info(f"å¼€å§‹æŠ“å–å•†å“: {item_id}")

            # è·å–åº—é“ºä¿¡æ¯
            shop_name = self._get_shop_name(url)
            if shop_name == "æœªçŸ¥åº—é“º":
                logger.info("åº—é“ºåç§°è·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°
                        shop_name_pattern = r'"shopName"[^:]*:[^"]*"([^"]+)"'
                        match = re.search(shop_name_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            shop_name = match.group(1).strip()
                            logger.info(f"âœ… ä»JavaScriptæ•°æ®è·å–åˆ°åº—é“ºåç§°: {shop_name}")
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢æå–åº—é“ºåç§°å¤±è´¥: {e}")

            # ä½¿ç”¨å®˜æ–¹APIè·å–å•†å“ä¿¡æ¯
            product_info = self._scrape_by_api(item_id, url, shop_name)
            if product_info:
                logger.info(f"âœ… å•†å“ä¿¡æ¯æŠ“å–æˆåŠŸ: {product_info.get('title', 'Unknown')}")
                return product_info

            # å¦‚æœAPIå¤±è´¥ï¼Œè¿”å›None
            logger.error("APIæŠ“å–å¤±è´¥ï¼Œæ²¡æœ‰å¤‡ç”¨æ–¹æ³•")
            return None

        except Exception as e:
            logger.error(f"å•†å“ä¿¡æ¯æŠ“å–å¤±è´¥: {e}")
            return None

    def _scrape_by_api(self, item_id: str, url: str, shop_name: str = '') -> Optional[Dict]:
        """ä½¿ç”¨å¾®åº—å®˜æ–¹APIæŠ“å–å•†å“ä¿¡æ¯"""
        try:
            # è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯
            title_info = self._get_item_title_and_sku(item_id)
            title = title_info.get('title', '') if title_info else ''

            # å¦‚æœAPIè·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
            if not title:
                logger.info("APIè·å–æ ‡é¢˜å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
                        title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                        match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            title = match.group(1).strip()
                            logger.info(f"âœ… ä»é¡µé¢HTMLè·å–åˆ°å•†å“æ ‡é¢˜: {title}")
                        else:
                            title = f'å¾®åº—å•†å“ {item_id}'
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢HTMLæå–æ ‡é¢˜å¤±è´¥: {e}")
                    title = f'å¾®åº—å•†å“ {item_id}'
            else:
                title = title

            # è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ï¼ˆå³ä½¿æ ‡é¢˜è·å–å¤±è´¥ä¹Ÿè¦å°è¯•è·å–å›¾ç‰‡ï¼‰
            image_info = self._get_item_images(item_id)
            images = image_info if image_info else []

            # å¦‚æœæ—¢æ²¡æœ‰æ ‡é¢˜ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œè¿”å›None
            if not title and not images:
                logger.error("æ— æ³•è·å–å•†å“æ ‡é¢˜å’Œå›¾ç‰‡ä¿¡æ¯")
                return None

            # æ„å»ºå•†å“ä¿¡æ¯
            product_info = {
                'id': item_id,
                'weidian_url': url,
                'cnfans_url': f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN",
                'acbuy_url': f"https://www.acbuy.com/product?url=https%253A%252F%252Fweidian.com%252Fitem.html%253FitemID%253D{item_id}%2526spider_token%253D43fe&id={item_id}&source=WD",
                'images': images,
                'title': title,
                'english_title': self._generate_english_title(title),
                'description': f"å¾®åº—å•†å“ID: {item_id}",
                'shop_name': shop_name
            }

            return product_info

        except Exception as e:
            logger.error(f"APIæŠ“å–å¤±è´¥: {e}")
            return None

    def _get_item_title_and_sku(self, item_id: str) -> Optional[Dict]:
        """è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯"""
        try:
            # æ„é€ API URL - ä½¿ç”¨æ›´æ–°çš„æ ¼å¼
            param = json.dumps({"itemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getItemSkuInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.info(f"è°ƒç”¨SKU API: {api_url}")  # ä¿®æ”¹æ—¥å¿—çº§åˆ«ä¸º INFO ä»¥ä¾¿è°ƒè¯•

            # ä½¿ç”¨ä¸å‰ç«¯ fetch å®Œå…¨ä¸€è‡´çš„ headers
            headers = {
                "accept": "application/json, */*",
                "accept-language": "en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"macOS"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "referrer": "https://weidian.com/",
                "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
            }

            # ä¸å¸¦ cookies å‘é€è¯·æ±‚ (æœ‰æ—¶å€™ cookies ä¼šå¯¼è‡´æ ¡éªŒå¤±è´¥)
            response = requests.get(api_url, headers=headers, timeout=15)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"æ ‡é¢˜APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                title = result.get('itemTitle', '')
                if title:
                    return {'title': title, 'sku_info': result}

            # APIè°ƒç”¨å¤±è´¥ï¼Œè®°å½•è­¦å‘Šä½†ä¸å°è¯•HTML fallback

            return None

        except Exception as e:
            logger.error(f"è·å–å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return None

    def _get_item_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ - åŒæ—¶è°ƒç”¨ä¸¤ä¸ªAPIå¹¶å»é‡"""
        try:
            all_images = []

            # 1. è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)
            detail_images = self._get_detail_images(item_id)
            all_images.extend(detail_images)

            # 2. è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API)
            sku_images = self._get_sku_images(item_id)
            all_images.extend(sku_images)

            # 3. ç®€å•URLå»é‡
            unique_images = []
            seen_urls = set()
            for img_url in all_images:
                if img_url and img_url not in seen_urls:
                    unique_images.append(img_url)
                    seen_urls.add(img_url)

            logger.info(f"âœ… å•†å“ {item_id} å›¾ç‰‡è·å–å®Œæˆ: å…± {len(unique_images)} å¼  (è¯¦æƒ…:{len(detail_images)}, SKU:{len(sku_images)})")
            if len(unique_images) > 0:
                logger.info(f"ğŸ“¸ å›¾ç‰‡URLæ ·ä¾‹: {unique_images[:3]}")
            return unique_images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_detail_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)"""
        try:
            # æ„é€ API URL
            param = json.dumps({"vItemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getDetailDesc/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.debug(f"è°ƒç”¨è¯¦æƒ…å›¾ç‰‡API: {api_url}")

            # ä½¿ç”¨æ›´ç¨³å®šçš„è¯·æ±‚å¤´ï¼Œæ¨¡æ‹Ÿæµè§ˆå™¨è¡Œä¸º
            import requests
            headers = {
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'origin': 'https://weidian.com',
                'priority': 'u=1, i',
                'referer': 'https://weidian.com/',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-site',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            # è®¾ç½®cookies
            cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }

            response = requests.get(api_url, timeout=15, proxies={'http': None, 'https': None}, headers=headers, cookies=cookies)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"è¯¦æƒ…å›¾ç‰‡APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            images = []
            if data.get('status', {}).get('code') == 0:
                item_detail = data.get('result', {}).get('item_detail', {})
                desc_content = item_detail.get('desc_content', [])

                for item in desc_content:
                    if item.get('type') == 2 and item.get('url'):
                        images.append(item['url'])

            return images

        except Exception as e:
            logger.error(f"è·å–è¯¦æƒ…å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_sku_images(self, item_id: str) -> List[str]:
        """è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API + attrListè§£æ)"""
        try:
            logger.info(f"å¼€å§‹è·å–SKUå›¾ç‰‡ï¼Œå•†å“ID: {item_id}")
            title_info = self._get_item_title_and_sku(item_id)
            if not title_info or 'sku_info' not in title_info:
                logger.warning(f"æ— æ³•è·å–SKUä¿¡æ¯ï¼Œè·³è¿‡å›¾ç‰‡æå–: {item_id}")
                return []

            result = title_info['sku_info']
            images = []
            seen_urls = set()

            # 1. å°è¯•ä» attrList ä¸­æå– (è¿™æ˜¯ä½ æä¾›çš„JSONä¸­çš„ç»“æ„)
            attr_list = result.get('attrList', [])
            if attr_list:
                logger.info(f"è§£æ attrListï¼Œå…± {len(attr_list)} ç»„å±æ€§")
                for attr in attr_list:
                    attr_values = attr.get('attrValues', [])
                    for val in attr_values:
                        img_url = val.get('img')
                        if img_url:
                            # ä¿®å¤ URL æ ¼å¼
                            if img_url.startswith('//'):
                                img_url = 'https:' + img_url

                            if img_url not in seen_urls:
                                images.append(img_url)
                                seen_urls.add(img_url)

            # 2. å°è¯•ä» skuInfos ä¸­æå– (ä½œä¸ºè¡¥å……)
            sku_infos = result.get('skuInfos', [])
            if sku_infos:
                logger.info(f"è§£æ skuInfosï¼Œå…± {len(sku_infos)} ä¸ªSKU")
                for sku in sku_infos:
                    # æ³¨æ„ï¼šskuInfo å¯¹è±¡å¯èƒ½åµŒå¥—
                    info = sku.get('skuInfo', {})
                    img_url = info.get('img')
                    if img_url:
                        if img_url.startswith('//'):
                            img_url = 'https:' + img_url
                        if img_url not in seen_urls:
                            images.append(img_url)
                            seen_urls.add(img_url)

            logger.info(f"ä»SKUå±æ€§ä¸­æˆåŠŸæå– {len(images)} å¼ å›¾ç‰‡")
            return images
        except Exception as e:
            logger.error(f"è·å–SKUå›¾ç‰‡å¤±è´¥: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return []


    def _generate_english_title(self, chinese_title: str) -> str:
        """æ ¹æ®ä¸­æ–‡æ ‡é¢˜ç”Ÿæˆè‹±æ–‡æ ‡é¢˜ - ä½¿ç”¨å…è´¹ç¿»è¯‘API"""
        if not chinese_title or len(chinese_title.strip()) == 0:
            return ""
        # ä¼˜å…ˆä½¿ç”¨ Google å…è´¹æ¥å£ï¼Œå¤±è´¥å†å›é€€åˆ°ç™¾åº¦ï¼Œå†å›é€€åˆ°ç®€å•æ˜ å°„
        try:
            return self._translate_with_google(chinese_title)
        except Exception as e:
            logger.debug(f"Google ç¿»è¯‘å¤±è´¥: {e}")
        try:
            res = self._translate_with_baidu(chinese_title)
            if res:
                return res
        except Exception as e:
            logger.debug(f"ç™¾åº¦ç¿»è¯‘å¤±è´¥: {e}")
        # æœ€åå¤‡ç”¨ï¼šç®€å•æ˜ å°„
        return self._simple_chinese_to_english(chinese_title)

    def _translate_with_baidu(self, text: str) -> str:
        """ä½¿ç”¨ç™¾åº¦ç¿»è¯‘API"""
        try:
            # ç™¾åº¦ç¿»è¯‘å…è´¹API
            url = "https://fanyi.baidu.com/transapi"

            params = {
                'from': 'zh',
                'to': 'en',
                'query': text[:200]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            data = response.json()
            # å°è¯•å¤šç§å¯èƒ½çš„è¿”å›ç»“æ„ï¼Œé¿å…ç›´æ¥æŠ›å‡ºå¼‚å¸¸
            translated = ""
            if isinstance(data, dict):
                try:
                    translated = data.get('data', {}).get('result', [{}])[0].get('dst', '') or ''
                except Exception:
                    translated = ''
                if not translated:
                    if 'trans_result' in data:
                        try:
                            translated = data.get('trans_result', [{}])[0].get('dst', '') or ''
                        except Exception:
                            translated = ''
            if translated:
                return translated.strip()
            logger.debug("ç™¾åº¦ç¿»è¯‘è¿”å›ç©ºç»“æœ")
            return ""
        except Exception as e:
            logger.warning(f"ç™¾åº¦ç¿»è¯‘APIè°ƒç”¨å¼‚å¸¸: {e}")
            return ""

    def _translate_with_google(self, text: str) -> str:
        """ä½¿ç”¨Google Translate APIçš„å…è´¹ç‰ˆæœ¬"""
        try:
            # ä½¿ç”¨Google Translateçš„å…è´¹API
            url = "https://translate.googleapis.com/translate_a/single"

            params = {
                'client': 'gtx',
                'sl': 'zh-CN',
                'tl': 'en',
                'dt': 't',
                'q': text[:500]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # Googleè¿”å›çš„æ˜¯JSONæ•°ç»„
            data = response.json()
            if data and len(data) > 0 and len(data[0]) > 0:
                translated = data[0][0][0]
                if translated:
                    return translated.strip()

            raise Exception("Googleç¿»è¯‘è¿”å›ç©ºç»“æœ")

        except Exception as e:
            logger.error(f"Googleç¿»è¯‘APIè°ƒç”¨å¤±è´¥: {e}")
            raise e

    def _simple_chinese_to_english(self, text: str) -> str:
        """ç®€å•çš„ä¸­è‹±æ˜ å°„ - æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ"""
        # ç®€å•çš„å•†å“å…³é”®è¯æ˜ å°„
        mappings = {
            'é‹': 'shoes',
            'è¿åŠ¨é‹': 'sports shoes',
            'è¢œå­': 'socks',
            'é‹å­': 'shoes',
            'è¡£æœ': 'clothes',
            'ä¸Šè¡£': 'top',
            'è£¤å­': 'pants',
            'åŒ…': 'bag',
            'åŒ…åŒ…': 'bag',
            'æ‰‹æœº': 'phone',
            'ç”µè„‘': 'computer',
            'è€³æœº': 'headphones',
            'æ‰‹è¡¨': 'watch',
            'çœ¼é•œ': 'glasses',
            'å¸½å­': 'hat',
            'ä¹¦': 'book',
            'ç©å…·': 'toy',
            'æ¸¸æˆ': 'game'
        }

        result = text
        for cn, en in mappings.items():
            result = result.replace(cn, en)

        # å¦‚æœæœ‰æ˜æ˜¾çš„å˜åŒ–ï¼Œè¿”å›ç¿»è¯‘ç»“æœï¼Œå¦åˆ™è¿”å›ç©º
        if result != text:
            return result.strip()
        else:
            return ""


    def download_images(self, image_urls: List[str], save_dir: str, item_id: str) -> List[str]:
        """å¤šçº¿ç¨‹ä¸‹è½½å•†å“å›¾ç‰‡åˆ°æœ¬åœ°"""
        import os
        import concurrent.futures
        import threading

        saved_paths = []
        os.makedirs(save_dir, exist_ok=True)

        # ç§»é™¤å›¾ç‰‡æ•°é‡é™åˆ¶ï¼ŒæŠ“å–æ‰€æœ‰å¯ç”¨çš„å›¾ç‰‡
        # SKUå›¾ç‰‡é€šå¸¸æ’åœ¨è¯¦æƒ…å›¾ä¹‹åï¼Œç°åœ¨å¯ä»¥è·å–æ‰€æœ‰å›¾ç‰‡
        logger.info(f"å‡†å¤‡ä¸‹è½½ {len(image_urls)} å¼ å›¾ç‰‡ï¼ˆæ— æ•°é‡é™åˆ¶ï¼‰")

        def download_single_image(args):
            """ä¸‹è½½å•å¼ å›¾ç‰‡çš„å‡½æ•°"""
            i, img_url = args
            try:
                # ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºç‹¬ç«‹çš„session
                thread_session = requests.Session()
                thread_session.headers.update(self.session.headers)
                thread_session.cookies.update(self.session.cookies)

                response = thread_session.get(img_url, timeout=10, proxies={'http': None, 'https': None})
                response.raise_for_status()

                # ä¿å­˜å›¾ç‰‡
                img_path = os.path.join(save_dir, f"{item_id}_{i}.jpg")
                with open(img_path, 'wb') as f:
                    f.write(response.content)

                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸ: {img_path}")
                return img_path

            except Exception as e:
                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ {img_url}: {e}")
                return None

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘ä¸‹è½½å›¾ç‰‡
        try:
            from config import config
        except ImportError:
            from .config import config
        max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))  # ä½¿ç”¨é…ç½®çš„ä¸‹è½½çº¿ç¨‹æ•°

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æäº¤æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
            future_to_image = {
                executor.submit(download_single_image, (i, img_url)): (i, img_url)
                for i, img_url in enumerate(image_urls)
            }

            # æ”¶é›†ç»“æœ
            for future in concurrent.futures.as_completed(future_to_image):
                result = future.result()
                if result:
                    saved_paths.append(result)

        # æŒ‰ç´¢å¼•æ’åºç»“æœ
        saved_paths.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

        return saved_paths

    def _get_shop_name(self, url: str) -> str:
        """ä»å•†å“é¡µé¢è·å–åº—é“ºåç§°"""
        try:
            logger.debug(f"å¼€å§‹è·å–åº—é“ºåç§°: {url}")

            # ä½¿ç”¨ä¸“é—¨çš„HTMLè¯·æ±‚headersï¼ˆä¸åŒäºAPIè¯·æ±‚çš„headersï¼‰
            html_headers = {
                'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'cache-control': 'max-age=0',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'document',
                'sec-fetch-mode': 'navigate',
                'sec-fetch-site': 'none',
                'sec-fetch-user': '?1',
                'upgrade-insecure-requests': '1',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            html_cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                '__spider__sessionid': '4cb270eb969f316c'
            }

            # è¯·æ±‚å•†å“é¡µé¢ï¼ˆä½¿ç”¨HTMLä¸“ç”¨headersï¼‰
            response = requests.get(url, headers=html_headers, cookies=html_cookies, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # è§£ç HTMLå®ä½“ï¼ˆ&#34; -> " ç­‰ï¼‰
            html_content = response.text
            html_content = html_content.replace('&#34;', '"').replace('&#39;', "'").replace('&quot;', '"')

            # é¦–å…ˆå°è¯•æœ€ç²¾ç¡®çš„åŒ¹é…ï¼šemæ ‡ç­¾ä¸­çš„shop-name-strç±»ï¼ˆæ ¹æ®ç”¨æˆ·æä¾›çš„HTMLç»“æ„ï¼‰
            shop_name_pattern1 = r'<em[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</em>'
            match = re.search(shop_name_pattern1, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (em shop-name-str): {shop_name}")
                return shop_name

            # ç„¶åå°è¯•æ›´å®½æ³›çš„åŒ¹é…ï¼ŒæŸ¥æ‰¾åŒ…å«shop-name-strç±»çš„ä»»ä½•å…ƒç´ 
            shop_name_pattern2 = r'<[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</[^>]*>'
            match = re.search(shop_name_pattern2, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (é€šç”¨shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•åŒ¹é…class="shop-name-str"çš„å…ƒç´ ï¼ˆä¸é™å®šæ ‡ç­¾ç±»å‹ï¼‰
            shop_name_pattern3 = r'class="shop-name-str"[^>]*>([^<]+)</'
            match = re.search(shop_name_pattern3, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°ï¼ˆå¤šç§æ ¼å¼ï¼‰
            # æ ¼å¼1: "shopName":"Aiseo"
            shop_name_pattern4 = r'"shopName"\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern4, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScript): {shop_name}")
                return shop_name

            # æ ¼å¼2: \"shopName\":\"Aiseo\" (åœ¨HTMLä¸­è¢«è½¬ä¹‰)
            shop_name_pattern5 = r'\\"shopName\\"\s*:\s*\\"([^\\"]+)\\"'
            match = re.search(shop_name_pattern5, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptè½¬ä¹‰): {shop_name}")
                return shop_name

            # æ ¼å¼3: shopName:"Aiseo" (æ— å¼•å·)
            shop_name_pattern6 = r'shopName\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern6, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptæ— å¼•å·): {shop_name}")
                return shop_name

            logger.warning("æœªæ‰¾åˆ°åº—é“ºåç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°")
            return "æœªçŸ¥åº—é“º"

        except Exception as e:
            logger.error(f"è·å–åº—é“ºåç§°å¤±è´¥: {e}")
            return "æœªçŸ¥åº—é“º"

    def close(self):
        """å…³é—­èµ„æº - å ä½æ–¹æ³•"""
        pass

# å…¨å±€çˆ¬è™«å®ä¾‹
_scraper = None

def get_weidian_scraper() -> WeidianScraper:
    """è·å–å¾®åº—çˆ¬è™«å®ä¾‹"""
    global _scraper
    if _scraper is None:
        _scraper = WeidianScraper()
    return _scraper

===== src-tauri/src/main.rs =====
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use tauri::api::process::{Command, CommandEvent};
use std::sync::Mutex;
use tauri::Manager;

struct BackendState {
    child: Option<tauri::api::process::CommandChild>,
}

fn main() {
    tauri::Builder::default()
        .manage(Mutex::new(BackendState { child: None }))
        .setup(|app| {
            // å¯åŠ¨ Python åç«¯ sidecar
            let (mut rx, child) = Command::new_sidecar("backend")
                .expect("failed to create sidecar command")
                .spawn()
                .expect("failed to spawn sidecar");

            // ä¿å­˜å­è¿›ç¨‹å¼•ç”¨
            let state = app.state::<Mutex<BackendState>>();
            state.lock().unwrap().child = Some(child);

            // ç›‘å¬åç«¯è¾“å‡º
            tauri::async_runtime::spawn(async move {
                while let Some(event) = rx.recv().await {
                    match event {
                        CommandEvent::Stdout(line) => {
                            println!("[Backend] {}", line);
                        }
                        CommandEvent::Stderr(line) => {
                            eprintln!("[Backend Error] {}", line);
                        }
                        _ => {}
                    }
                }
            });

            Ok(())
        })
        .on_window_event(|event| {
            if let tauri::WindowEvent::CloseRequested { .. } = event.event() {
                // å…³é—­çª—å£æ—¶åœæ­¢åç«¯
                let child = {
                    let state = event.window().state::<Mutex<BackendState>>();
                    let mut guard = state.lock().unwrap();
                    guard.child.take()
                };
                if let Some(child) = child {
                    let _ = child.kill();
                }
            }
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

===== src/App.tsx =====
import { useEffect, useState, type ReactNode } from 'react'
import { HashRouter, Routes, Route, NavLink } from 'react-router-dom'
import { Toaster } from 'sonner'
import { Users, Store, Send } from 'lucide-react'

import AccountsPage from './pages/AccountsPage'
import ShopsPage from './pages/ShopsPage'
import AutoSenderPage from './pages/AutoSenderPage'
import LicenseGate from './components/LicenseGate'

const API_BASE = 'http://127.0.0.1:5001/api'

function App() {
  const [licenseLoading, setLicenseLoading] = useState(true)
  const [licenseActive, setLicenseActive] = useState(false)
  const [serverReady, setServerReady] = useState(false)

  const checkServerAndLicense = async () => {
    setLicenseLoading(true)
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 2000)

    try {
      const healthRes = await fetch(`${API_BASE}/health`, {
        method: 'GET',
        signal: controller.signal
      })
      if (!healthRes.ok) {
        throw new Error('Backend not ready')
      }
      setServerReady(true)

      const res = await fetch(`${API_BASE}/license/status`)
      const data = await res.json()
      if (data.success && data.activated) {
        setLicenseActive(true)
      } else {
        setLicenseActive(false)
      }
    } catch (error) {
      console.error('Connection failed:', error)
      setServerReady(false)
      setLicenseActive(false)
    } finally {
      clearTimeout(timeoutId)
      setLicenseLoading(false)
    }
  }

  useEffect(() => {
    checkServerAndLicense()
    const timer = setInterval(() => {
      if (!serverReady) {
        checkServerAndLicense()
      }
    }, 3000)
    return () => clearInterval(timer)
  }, [serverReady])

  let content: ReactNode
  if (licenseLoading || !serverReady) {
    content = (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 space-y-4">
        <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600" />
        <div className="text-gray-500">
          {!serverReady ? 'æ­£åœ¨å¯åŠ¨åå°æœåŠ¡...' : 'éªŒè¯è®¸å¯è¯...'}
        </div>
      </div>
    )
  } else if (!licenseActive) {
    content = <LicenseGate onActivated={checkServerAndLicense} />
  } else {
    content = (
      <HashRouter>
        <div className="flex min-h-screen bg-gray-50">
          {/* ä¾§è¾¹æ  */}
          <nav className="w-64 bg-white border-r border-gray-200 p-4 flex flex-col h-screen">
            <div className="mb-8">
              <h1 className="text-xl font-bold text-gray-800">Discord è¥é”€</h1>
              <p className="text-sm text-gray-500">è‡ªåŠ¨å‘é€ç³»ç»Ÿ</p>
            </div>

            <ul className="space-y-2 flex-1">
              <li>
                <NavLink
                  to="/"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Send size={20} />
                  <span>è‡ªåŠ¨å‘é€</span>
                </NavLink>
              </li>
              <li>
                <NavLink
                  to="/accounts"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Users size={20} />
                  <span>è´¦å·ç®¡ç†</span>
                </NavLink>
              </li>
              <li>
                <NavLink
                  to="/shops"
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      isActive
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-100'
                    }`
                  }
                >
                  <Store size={20} />
                  <span>åº—é“ºç®¡ç†</span>
                </NavLink>
              </li>
            </ul>
          </nav>

          {/* ä¸»å†…å®¹åŒº */}
          <main className="flex-1 p-6 overflow-auto h-screen">
            <Routes>
              <Route path="/" element={<AutoSenderPage />} />
              <Route path="/accounts" element={<AccountsPage />} />
              <Route path="/shops" element={<ShopsPage />} />
            </Routes>
          </main>
        </div>
      </HashRouter>
    )
  }

  return (
    <>
      {content}
      <Toaster position="top-right" richColors />
    </>
  )
}

export default App

===== src/components/LicenseGate.tsx =====
import { useState } from 'react'

const API_BASE = 'http://127.0.0.1:5001/api'

interface LicenseGateProps {
  onActivated: () => Promise<void>
}

export default function LicenseGate({ onActivated }: LicenseGateProps) {
  const [licenseKey, setLicenseKey] = useState('')
  const [submitting, setSubmitting] = useState(false)

  const handleActivate = async () => {
    const trimmedKey = licenseKey.trim()
    if (!trimmedKey) {
      return
    }

    setSubmitting(true)
    try {
      const res = await fetch(`${API_BASE}/license/activate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ key: trimmedKey })
      })
      const data = await res.json()
      if (data.success) {
        await onActivated()
      }
    } catch (err) {
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-6">
      <div className="w-full max-w-md bg-white border rounded-xl p-6 space-y-4">
        <div>
          <h1 className="text-xl font-bold text-gray-900">è½¯ä»¶æ¿€æ´»</h1>
          <p className="text-sm text-gray-500">è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥ä»¥ç»§ç»­ä½¿ç”¨ã€‚</p>
        </div>

        <div className="space-y-2">
          <label className="block text-sm font-medium text-gray-700">è®¸å¯è¯å¯†é’¥</label>
          <input
            type="text"
            value={licenseKey}
            onChange={(e) => setLicenseKey(e.target.value)}
            placeholder="è¯·è¾“å…¥è®¸å¯è¯å¯†é’¥"
            className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
        </div>

        <button
          onClick={handleActivate}
          disabled={submitting}
          className="w-full px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {submitting ? 'æ¿€æ´»ä¸­...' : 'æ¿€æ´»'}
        </button>
      </div>
    </div>
  )
}

===== src/main.tsx =====
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

===== src/pages/AccountsPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Plus, Trash2, Power, PowerOff, RefreshCw } from 'lucide-react'

interface Account {
  id: number
  username: string
  token: string
  status: string
  is_online: boolean
  last_active: string | null
  created_at: string
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function AccountsPage() {
  const [accounts, setAccounts] = useState<Account[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddModal, setShowAddModal] = useState(false)
  const [newToken, setNewToken] = useState('')
  const [newUsername, setNewUsername] = useState('')

  const fetchAccounts = async () => {
    try {
      const res = await fetch(`${API_BASE}/accounts`)
      const data = await res.json()
      if (data.success) {
        setAccounts(data.accounts || [])
      }
    } catch (error) {
      toast.error('è·å–è´¦å·åˆ—è¡¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchAccounts()
    // å®šæœŸåˆ·æ–°çŠ¶æ€
    const interval = setInterval(fetchAccounts, 5000)
    return () => clearInterval(interval)
  }, [])

  const handleAddAccount = async () => {
    if (!newToken.trim()) {
      toast.error('è¯·è¾“å…¥ Token')
      return
    }

    try {
      const res = await fetch(`${API_BASE}/accounts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: newToken, username: newUsername })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('è´¦å·æ·»åŠ æˆåŠŸ')
        setNewToken('')
        setNewUsername('')
        setShowAddModal(false)
        fetchAccounts()
      } else {
        toast.error(data.error || 'æ·»åŠ å¤±è´¥')
      }
    } catch (error) {
      toast.error('æ·»åŠ è´¦å·å¤±è´¥')
    }
  }

  const handleDeleteAccount = async (id: number) => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè´¦å·å—ï¼Ÿ')) return

    try {
      const res = await fetch(`${API_BASE}/accounts/${id}`, { method: 'DELETE' })
      const data = await res.json()
      if (data.success) {
        toast.success('è´¦å·å·²åˆ é™¤')
        fetchAccounts()
      } else {
        toast.error(data.error || 'åˆ é™¤å¤±è´¥')
      }
    } catch (error) {
      toast.error('åˆ é™¤è´¦å·å¤±è´¥')
    }
  }

  const handleToggleAccount = async (id: number, isOnline: boolean) => {
    const action = isOnline ? 'stop' : 'start'
    try {
      const res = await fetch(`${API_BASE}/accounts/${id}/${action}`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success(isOnline ? 'è´¦å·å·²åœæ­¢' : 'è´¦å·å¯åŠ¨ä¸­...')
        setTimeout(fetchAccounts, 1000)
      } else {
        toast.error(data.error || 'æ“ä½œå¤±è´¥')
      }
    } catch (error) {
      toast.error('æ“ä½œå¤±è´¥')
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">è´¦å·ç®¡ç†</h2>
          <p className="text-gray-500">ç®¡ç†ä½ çš„ Discord è´¦å·ï¼Œé€šè¿‡ Token ç™»å½•</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={fetchAccounts}
            className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
          >
            <RefreshCw size={18} />
            åˆ·æ–°
          </button>
          <button
            onClick={() => setShowAddModal(true)}
            className="flex items-center gap-2 px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
          >
            <Plus size={18} />
            æ·»åŠ è´¦å·
          </button>
        </div>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-500">åŠ è½½ä¸­...</div>
      ) : accounts.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg border">
          <p className="text-gray-500">æš‚æ— è´¦å·ï¼Œè¯·æ·»åŠ  Discord è´¦å·</p>
        </div>
      ) : (
        <div className="bg-white rounded-lg border overflow-hidden">
          <table className="w-full">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">ç”¨æˆ·å</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">çŠ¶æ€</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">Token</th>
                <th className="px-6 py-3 text-left text-sm font-medium text-gray-500">æœ€åæ´»è·ƒ</th>
                <th className="px-6 py-3 text-right text-sm font-medium text-gray-500">æ“ä½œ</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {accounts.map((account) => (
                <tr key={account.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4 text-sm font-medium text-gray-900">
                    {account.username || `è´¦å· ${account.id}`}
                  </td>
                  <td className="px-6 py-4">
                    <span
                      className={`inline-flex items-center px-2 py-1 text-xs rounded-full ${
                        account.is_online
                          ? 'bg-green-100 text-green-700'
                          : 'bg-gray-100 text-gray-600'
                      }`}
                    >
                      {account.is_online ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                    </span>
                  </td>
                  <td className="px-6 py-4 text-sm text-gray-500 font-mono">
                    {account.token?.substring(0, 20)}...
                  </td>
                  <td className="px-6 py-4 text-sm text-gray-500">
                    {account.last_active || '-'}
                  </td>
                  <td className="px-6 py-4 text-right space-x-2">
                    <button
                      onClick={() => handleToggleAccount(account.id, account.is_online)}
                      className={`p-2 rounded-lg ${
                        account.is_online
                          ? 'text-red-600 hover:bg-red-50'
                          : 'text-green-600 hover:bg-green-50'
                      }`}
                      title={account.is_online ? 'åœæ­¢' : 'å¯åŠ¨'}
                    >
                      {account.is_online ? <PowerOff size={18} /> : <Power size={18} />}
                    </button>
                    <button
                      onClick={() => handleDeleteAccount(account.id)}
                      className="p-2 text-red-600 rounded-lg hover:bg-red-50"
                      title="åˆ é™¤"
                    >
                      <Trash2 size={18} />
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* æ·»åŠ è´¦å·å¼¹çª— */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-bold mb-4">æ·»åŠ  Discord è´¦å·</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  ç”¨æˆ·å (å¯é€‰)
                </label>
                <input
                  type="text"
                  value={newUsername}
                  onChange={(e) => setNewUsername(e.target.value)}
                  placeholder="ç”¨äºè¯†åˆ«è´¦å·"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Token <span className="text-red-500">*</span>
                </label>
                <input
                  type="password"
                  value={newToken}
                  onChange={(e) => setNewToken(e.target.value)}
                  placeholder="Discord è´¦å· Token"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
                <p className="mt-1 text-xs text-gray-500">
                  Token ç”¨äºç™»å½• Discord è´¦å·ï¼Œè¯·å¦¥å–„ä¿ç®¡
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2 mt-6">
              <button
                onClick={() => setShowAddModal(false)}
                className="px-4 py-2 text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200"
              >
                å–æ¶ˆ
              </button>
              <button
                onClick={handleAddAccount}
                className="px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
              >
                æ·»åŠ 
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

===== src/pages/AutoSenderPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Play, Square, RefreshCw, CheckCircle, Circle } from 'lucide-react'

interface Shop {
  id: number
  shop_id: string
  name: string
  product_count: number
}

interface Account {
  id: number
  username: string
  is_online: boolean
}

interface TaskStatus {
  is_running: boolean
  shop_id: number | null
  channel_id: string | null
  total_products: number
  sent_count: number
  current_product: string | null
  current_account: string | null
  started_at: string | null
  last_sent_at: string | null
  error: string | null
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function AutoSenderPage() {
  const [shops, setShops] = useState<Shop[]>([])
  const [accounts, setAccounts] = useState<Account[]>([])
  const [status, setStatus] = useState<TaskStatus | null>(null)

  // è¡¨å•çŠ¶æ€
  const [selectedShop, setSelectedShop] = useState('')
  const [targetChannel, setTargetChannel] = useState('')
  const [selectedAccounts, setSelectedAccounts] = useState<number[]>([])
  const [interval, setInterval] = useState('60')
  const [loading, setLoading] = useState(false)

  // è·å–åº—é“ºå’Œè´¦å·æ•°æ®
  const fetchData = async () => {
    try {
      const [shopsRes, accountsRes, statusRes] = await Promise.all([
        fetch(`${API_BASE}/shops`),
        fetch(`${API_BASE}/accounts`),
        fetch(`${API_BASE}/sender/status`)
      ])

      const shopsData = await shopsRes.json()
      const accountsData = await accountsRes.json()
      const statusData = await statusRes.json()

      if (shopsData.success) {
        setShops(shopsData.shops || [])
      }
      if (accountsData.success) {
        // åªæ˜¾ç¤ºåœ¨çº¿è´¦å·
        const onlineAccounts = (accountsData.accounts || []).filter(
          (a: Account) => a.is_online
        )
        setAccounts(onlineAccounts)
      }
      if (statusData.success) {
        setStatus(statusData.status)
      }
    } catch (error) {
      console.error('è·å–æ•°æ®å¤±è´¥:', error)
    }
  }

  useEffect(() => {
    fetchData()
    // å®šæœŸåˆ·æ–°çŠ¶æ€
    const interval = setInterval(fetchData, 3000)
    return () => clearInterval(interval)
  }, [])

  const toggleAccount = (id: number) => {
    setSelectedAccounts((prev) =>
      prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]
    )
  }

  const handleStart = async () => {
    if (!selectedShop) {
      toast.error('è¯·é€‰æ‹©åº—é“º')
      return
    }
    if (!targetChannel) {
      toast.error('è¯·è¾“å…¥ç›®æ ‡é¢‘é“ ID')
      return
    }
    if (selectedAccounts.length === 0) {
      toast.error('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªè´¦å·')
      return
    }

    setLoading(true)
    try {
      const res = await fetch(`${API_BASE}/sender/start`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopId: selectedShop,
          channelId: targetChannel,
          accountIds: selectedAccounts,
          interval: parseInt(interval)
        })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('è‡ªåŠ¨å‘é€å·²å¯åŠ¨')
        fetchData()
      } else {
        toast.error(data.error || 'å¯åŠ¨å¤±è´¥')
      }
    } catch (error) {
      toast.error('å¯åŠ¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  const handleStop = async () => {
    setLoading(true)
    try {
      const res = await fetch(`${API_BASE}/sender/stop`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success('å·²åœæ­¢å‘é€')
        fetchData()
      } else {
        toast.error(data.error || 'åœæ­¢å¤±è´¥')
      }
    } catch (error) {
      toast.error('åœæ­¢å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  const isRunning = status?.is_running || false

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">è‡ªåŠ¨å‘é€æ§åˆ¶å°</h2>
          <p className="text-gray-500">é…ç½®å¹¶å¯åŠ¨è‡ªåŠ¨å‘é€ä»»åŠ¡</p>
        </div>
        <button
          onClick={fetchData}
          className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
        >
          <RefreshCw size={18} />
          åˆ·æ–°
        </button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* å·¦ä¾§ï¼šé…ç½®åŒº */}
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">ä»»åŠ¡é…ç½®</h3>

          <div className="space-y-4">
            {/* é€‰æ‹©åº—é“º */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                é€‰æ‹©åº—é“º (æ•°æ®æº)
              </label>
              <select
                value={selectedShop}
                onChange={(e) => setSelectedShop(e.target.value)}
                disabled={isRunning}
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              >
                <option value="">é€‰æ‹©è¦å‘é€çš„åº—é“º</option>
                {shops.map((shop) => (
                  <option key={shop.id} value={shop.id}>
                    {shop.name} ({shop.product_count || 0} ä¸ªå•†å“)
                  </option>
                ))}
              </select>
            </div>

            {/* ç›®æ ‡é¢‘é“ */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                ç›®æ ‡ Discord é¢‘é“ ID
              </label>
              <input
                type="text"
                value={targetChannel}
                onChange={(e) => setTargetChannel(e.target.value)}
                disabled={isRunning}
                placeholder="ä¾‹å¦‚: 123456789012345678"
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              />
            </div>

            {/* å‘é€é¢‘ç‡ */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                å‘é€é—´éš” (ç§’)
              </label>
              <input
                type="number"
                value={interval}
                onChange={(e) => setInterval(e.target.value)}
                disabled={isRunning}
                min="10"
                max="3600"
                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              />
              <p className="mt-1 text-xs text-gray-500">å»ºè®®è®¾ç½® 60 ç§’ä»¥ä¸Šï¼Œé¿å…è§¦å‘é™åˆ¶</p>
            </div>

            {/* æ“ä½œæŒ‰é’® */}
            <div className="pt-4 flex gap-4">
              <button
                onClick={handleStart}
                disabled={isRunning || loading}
                className="flex-1 flex items-center justify-center gap-2 px-4 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Play size={18} />
                å¯åŠ¨ä»»åŠ¡
              </button>
              <button
                onClick={handleStop}
                disabled={!isRunning || loading}
                className="flex-1 flex items-center justify-center gap-2 px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Square size={18} />
                åœæ­¢ä»»åŠ¡
              </button>
            </div>
          </div>
        </div>

        {/* å³ä¾§ï¼šè´¦å·é€‰æ‹©åŒº */}
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">è´¦å·è½®æ¢æ± </h3>

          {accounts.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              æš‚æ— åœ¨çº¿è´¦å·ï¼Œè¯·åœ¨è´¦å·ç®¡ç†é¡µå¯åŠ¨è´¦å·
            </div>
          ) : (
            <div className="space-y-2 max-h-[300px] overflow-y-auto">
              {accounts.map((account) => (
                <div
                  key={account.id}
                  onClick={() => !isRunning && toggleAccount(account.id)}
                  className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors ${
                    selectedAccounts.includes(account.id)
                      ? 'bg-blue-50 border-blue-200 border'
                      : 'bg-gray-50 hover:bg-gray-100'
                  } ${isRunning ? 'opacity-50 cursor-not-allowed' : ''}`}
                >
                  {selectedAccounts.includes(account.id) ? (
                    <CheckCircle size={20} className="text-blue-600" />
                  ) : (
                    <Circle size={20} className="text-gray-400" />
                  )}
                  <div className="flex-1">
                    <span className="font-medium text-gray-800">
                      {account.username || `è´¦å· ${account.id}`}
                    </span>
                    <span className="ml-2 text-xs text-green-600">åœ¨çº¿</span>
                  </div>
                </div>
              ))}
            </div>
          )}

          <p className="mt-4 text-xs text-gray-500">
            ç³»ç»Ÿå°†æŒ‰ç…§å‹¾é€‰é¡ºåºï¼Œæ¯éš” {interval} ç§’åˆ‡æ¢ä¸‹ä¸€ä¸ªè´¦å·å‘é€ä¸€æ¡é“¾æ¥
          </p>
        </div>
      </div>

      {/* ä»»åŠ¡çŠ¶æ€ */}
      {status && (
        <div className="bg-white rounded-lg border p-6">
          <h3 className="text-lg font-bold text-gray-800 mb-4">ä»»åŠ¡çŠ¶æ€</h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div>
              <p className="text-sm text-gray-500">çŠ¶æ€</p>
              <p className={`font-medium ${isRunning ? 'text-green-600' : 'text-gray-600'}`}>
                {isRunning ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">è¿›åº¦</p>
              <p className="font-medium text-gray-800">
                {status.sent_count} / {status.total_products}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">å½“å‰å•†å“</p>
              <p className="font-medium text-gray-800 truncate">
                {status.current_product || '-'}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">å½“å‰è´¦å·</p>
              <p className="font-medium text-gray-800">{status.current_account || '-'}</p>
            </div>
          </div>
          {status.error && (
            <div className="mt-4 p-3 bg-red-50 text-red-600 rounded-lg text-sm">
              {status.error}
            </div>
          )}
        </div>
      )}
    </div>
  )
}

===== src/pages/ShopsPage.tsx =====
import { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { Plus, Trash2, Download, RefreshCw } from 'lucide-react'

interface Shop {
  id: number
  shop_id: string
  name: string
  product_count: number
  created_at: string
  updated_at: string
}

const API_BASE = 'http://127.0.0.1:5001/api'

export default function ShopsPage() {
  const [shops, setShops] = useState<Shop[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddModal, setShowAddModal] = useState(false)
  const [newShopId, setNewShopId] = useState('')
  const [newShopName, setNewShopName] = useState('')

  const fetchShops = async () => {
    try {
      const res = await fetch(`${API_BASE}/shops`)
      const data = await res.json()
      if (data.success) {
        setShops(data.shops || [])
      }
    } catch (error) {
      toast.error('è·å–åº—é“ºåˆ—è¡¨å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchShops()
  }, [])

  const handleAddShop = async () => {
    if (!newShopId.trim()) {
      toast.error('è¯·è¾“å…¥åº—é“º ID')
      return
    }

    try {
      const res = await fetch(`${API_BASE}/shops`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shop_id: newShopId, name: newShopName })
      })
      const data = await res.json()
      if (data.success) {
        toast.success('åº—é“ºæ·»åŠ æˆåŠŸ')
        setNewShopId('')
        setNewShopName('')
        setShowAddModal(false)
        fetchShops()
      } else {
        toast.error(data.error || 'æ·»åŠ å¤±è´¥')
      }
    } catch (error) {
      toast.error('æ·»åŠ åº—é“ºå¤±è´¥')
    }
  }

  const handleDeleteShop = async (id: number) => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåº—é“ºå—ï¼Ÿ')) return

    try {
      const res = await fetch(`${API_BASE}/shops/${id}`, { method: 'DELETE' })
      const data = await res.json()
      if (data.success) {
        toast.success('åº—é“ºå·²åˆ é™¤')
        fetchShops()
      } else {
        toast.error(data.error || 'åˆ é™¤å¤±è´¥')
      }
    } catch (error) {
      toast.error('åˆ é™¤åº—é“ºå¤±è´¥')
    }
  }

  const handleScrapeShop = async (id: number) => {
    try {
      const res = await fetch(`${API_BASE}/shops/${id}/scrape`, { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        toast.success('æŠ“å–ä»»åŠ¡å·²å¯åŠ¨')
      } else {
        toast.error(data.error || 'å¯åŠ¨æŠ“å–å¤±è´¥')
      }
    } catch (error) {
      toast.error('å¯åŠ¨æŠ“å–å¤±è´¥')
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-800">åº—é“ºç®¡ç†</h2>
          <p className="text-gray-500">ç®¡ç†ä½ çš„å¾®åº—åº—é“ºï¼ŒæŠ“å–å•†å“æ•°æ®</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={fetchShops}
            className="flex items-center gap-2 px-4 py-2 text-gray-600 bg-white border rounded-lg hover:bg-gray-50"
          >
            <RefreshCw size={18} />
            åˆ·æ–°
          </button>
          <button
            onClick={() => setShowAddModal(true)}
            className="flex items-center gap-2 px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
          >
            <Plus size={18} />
            æ·»åŠ åº—é“º
          </button>
        </div>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-500">åŠ è½½ä¸­...</div>
      ) : shops.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg border">
          <p className="text-gray-500">æš‚æ— åº—é“ºï¼Œè¯·æ·»åŠ å¾®åº—åº—é“º</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {shops.map((shop) => (
            <div key={shop.id} className="bg-white rounded-lg border p-4">
              <div className="flex items-start justify-between">
                <div>
                  <h3 className="font-bold text-gray-800">{shop.name}</h3>
                  <p className="text-sm text-gray-500">ID: {shop.shop_id}</p>
                </div>
                <div className="flex gap-1">
                  <button
                    onClick={() => handleScrapeShop(shop.id)}
                    className="p-2 text-blue-600 rounded-lg hover:bg-blue-50"
                    title="æŠ“å–å•†å“"
                  >
                    <Download size={18} />
                  </button>
                  <button
                    onClick={() => handleDeleteShop(shop.id)}
                    className="p-2 text-red-600 rounded-lg hover:bg-red-50"
                    title="åˆ é™¤"
                  >
                    <Trash2 size={18} />
                  </button>
                </div>
              </div>
              <div className="mt-4 pt-4 border-t flex justify-between text-sm">
                <span className="text-gray-500">å•†å“æ•°é‡</span>
                <span className="font-medium text-gray-800">{shop.product_count || 0}</span>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* æ·»åŠ åº—é“ºå¼¹çª— */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-bold mb-4">æ·»åŠ å¾®åº—åº—é“º</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  åº—é“ºåç§° (å¯é€‰)
                </label>
                <input
                  type="text"
                  value={newShopName}
                  onChange={(e) => setNewShopName(e.target.value)}
                  placeholder="ç”¨äºè¯†åˆ«åº—é“º"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  åº—é“º ID <span className="text-red-500">*</span>
                </label>
                <input
                  type="text"
                  value={newShopId}
                  onChange={(e) => setNewShopId(e.target.value)}
                  placeholder="ä¾‹å¦‚: 1713062461"
                  className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
                <p className="mt-1 text-xs text-gray-500">
                  å¾®åº—åº—é“º IDï¼Œå¯ä»åº—é“º URL ä¸­è·å–
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2 mt-6">
              <button
                onClick={() => setShowAddModal(false)}
                className="px-4 py-2 text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200"
              >
                å–æ¶ˆ
              </button>
              <button
                onClick={handleAddShop}
                className="px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700"
              >
                æ·»åŠ 
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
